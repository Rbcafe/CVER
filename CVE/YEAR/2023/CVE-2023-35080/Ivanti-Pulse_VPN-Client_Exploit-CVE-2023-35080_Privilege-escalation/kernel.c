#include "kernel.h"

BOOL BuildDevicePath(LPWSTR DevicePath, LPWSTR DEVICE_NAME_W)
{
    // Allocate memory which will hold the device path
    DevicePath = (LPWSTR)malloc(MAX_PATH * sizeof(WCHAR));
    if (DevicePath == NULL) {
        PrintError(TEXT("malloc"));
    }
    int ret = swprintf_s(DevicePath, MAX_PATH, L"\\\\.\\%ws", DEVICE_NAME_W);
    if (ret == -1) {
        return FALSE;
    }

    return TRUE;
}

BOOL OpenDevice(HANDLE* hDevice, LPWSTR DevicePath)
{
    *hDevice = CreateFileW(
        DevicePath,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (*hDevice == INVALID_HANDLE_VALUE) {
        PrintError(TEXT("CreateFileW"));
        return FALSE;
    }

    return TRUE;
}

// Function for cleanup
void CloseDevice(HANDLE* hDevice, LPWSTR devicePath)
{
    if (devicePath) {
        printf("[+] Freeing : %ws\n", devicePath);
        free(devicePath);
    }
    if (hDevice) {
        printf("[+] Closing hDevice located at : %p\n", hDevice);
        CloseHandle(hDevice);
    }
}

void GetFunctionOffset(LPCSTR fnName, uint64_t* FnOffset)
{
    HMODULE KernelImage = LoadLibraryA(
        "C:\\Windows\\System32\\ntoskrnl.exe"
    );
    if (KernelImage == NULL) {
        PrintError(TEXT("LoadLibraryA"));
        return;
    }

    FARPROC FnBaseAddress = GetProcAddress(
        KernelImage,
        fnName
    );
    if (FnBaseAddress == NULL) {
        PrintError(TEXT("GetProcAddress"));
        return;
    }

    *FnOffset = (uint64_t)FnBaseAddress - (uint64_t)KernelImage;

    //printf("[+] Kernel Image : %p\r\n", KernelImage);
    //printf("[+] %s Base Address : %p\r\n", fnName, FnBaseAddress);
    //printf("[+] %s Offset : %p\r\n", fnName, FnOffset);
}

void GetKernelBase(uint64_t* KernelBase)
{
    ULONG processModuleInformationLength = 0;
    ULONG returnLength = 0;

    HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
    if (ntdll == NULL) {
        PrintError(TEXT("GetModuleHandle(TEXT(\"ntdll\"))"));
        return;
    }
    PNtQuerySystemInformation NtQuerySystemInformationDyn = (PNtQuerySystemInformation)GetProcAddress(
        ntdll,
        "NtQuerySystemInformation"
    );
    if (NtQuerySystemInformationDyn == NULL) {
        PrintError(TEXT("GetProcAddress"));
        return;
    }

    // Call NtQuerySystemInformation to obtain the size of the RTL_PROCESS_MODULES structure that will be returned
    NtQuerySystemInformationDyn(
        SystemModuleInformation,
        NULL,
        processModuleInformationLength,
        &returnLength
    );

    // Allocate the memory which will hold the structure
    RTL_PROCESS_MODULES* processModules = (RTL_PROCESS_MODULES*)VirtualAlloc(
        NULL,
        returnLength,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );
    if (processModules == NULL) {
        PrintError(TEXT("VirtualAlloc processModules"));
        return;
    }

    // Get the RTL_PROCESS_MODULES structure
    NtQuerySystemInformationDyn(
        SystemModuleInformation,
        processModules,
        returnLength,
        &returnLength
    );

    // Save Kernel Base Address and free RTL_PROCESS_MODULES structure
    uint64_t* tempKernelBase = (uint64_t*)&(processModules->Modules[0].ImageBase);
    memcpy(KernelBase, tempKernelBase, sizeof(uint64_t));

    if (processModules == NULL) {
        PrintError(TEXT("processModules is null"));
        return;
    }

    BOOL result = VirtualFree(processModules, 0, MEM_RELEASE);
    if (!result) {
        PrintError(TEXT("VirtualFree processModules"));
        return;
    }
}

PVOID GetObjectPointedByHandle(HANDLE h)
{
    PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
    ULONG processModuleInformationLength = 0;
    ULONG returnLength = 0;

    HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
    if (ntdll == NULL) {
        PrintError(TEXT("GetModuleHandle(TEXT(\"ntdll\"))"));
        return NULL;
    }

    PNtQuerySystemInformation NtQuerySystemInformationDyn = (PNtQuerySystemInformation)GetProcAddress(
        ntdll,
        "NtQuerySystemInformation"
    );
    if (NtQuerySystemInformationDyn == NULL) {
        PrintError(TEXT("GetProcAddress() failed.\n"));
        return NULL;
    }

    // Call NtQuerySystemInformation to obtain the size of the RTL_PROCESS_MODULES structure that will be returned
    NtQuerySystemInformationDyn(
        SystemExtendedHandleInformation,
        NULL,
        processModuleInformationLength,
        &returnLength
    );

    NTSTATUS status = (NTSTATUS)0xc0000004;
    do {
        //returnLength *= 2;

        // Allocate the memory which will hold the structure
        pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            returnLength
        );
        if (pHandleInfo == NULL) {
            PrintError(TEXT("[!] Could no allocate memory  for pHandleInfo\n"));
            return NULL;
        }

        // Query all the open handles on the system
        status = NtQuerySystemInformationDyn(
            SystemExtendedHandleInformation,
            pHandleInfo,
            returnLength,
            &returnLength
        );
    } while (status == (NTSTATUS)0xc0000004);
    if (status != (NTSTATUS)0x0)
    {
        PrintError(TEXT("NtQuerySystemInformationDyn in GetObjectPointerByHandle"));
        return NULL;
    }

    // Retrieve Current process ID
    DWORD pid = GetCurrentProcessId();

    /*
     *  Loop through the handles and find the one that matches the specified handle
     *  and belongs to the current process
     */
    if (pHandleInfo == NULL) {
        PrintError(TEXT("pHandleInfo is null"));
        return NULL;
    }

    for (int i = 0; i < pHandleInfo->HandleCount; i++)
    {
        //printf("PID: %d\t", pHandleInfo->Handles[i].UniqueProcessId);
        //printf("Object 0x%llx\t", pHandleInfo->Handles[i].Object);
        //printf("Handle 0x%x\r\n", pHandleInfo->Handles[i].HandleValue);

        if (pid == pHandleInfo->Handles[i].UniqueProcessId
            && h == pHandleInfo->Handles[i].HandleValue)
        {
            printf("[+] Successfully found handle for PID : %d - 0x%x\n", pid, pid);
            printf("\tHandle PID: %d\n", pHandleInfo->Handles[i].UniqueProcessId);
            printf("\tHandleObject 0x%llx\n", pHandleInfo->Handles[i].Object);
            printf("\tHandle Value 0x%x\n", pHandleInfo->Handles[i].HandleValue);

            return (uint64_t)pHandleInfo->Handles[i].Object;
        }
    }

    return NULL;
}