// PoC CVE-2021-37980 : Inappropriate implementation in Sandbox (windows only)
// https://twitter.com/Zeusb0x

// Chrome sandboxed processes don't start fully secured. According to the default policy they start at integrity level "LOW"
// and are later downgraded to integrity level "UNTRUSTED". The latter is also called a delayed integrity level.

ResultCode AddDefaultPolicyForSandboxedProcess(TargetPolicy* policy) {
    //.....
    // Prevents the renderers from manipulating low-integrity processes.
    result = policy->SetDelayedIntegrityLevel(INTEGRITY_LEVEL_UNTRUSTED);
      if (result != SBOX_ALL_OK)
    return result;
    result = policy->SetIntegrityLevel(INTEGRITY_LEVEL_LOW);
    //.....
}

// The reason for this is to allow them to get hold of critical resources, load libraries, or read configuration files.

// Code that does this follows this pattern:

TargetServices* target_services = SandboxFactory::GetTargetServices();
if (target_services) {
     // We are the child process.
     target_services->Init();
     // Do work that requires higher privileges here.
     // ....
     // When ready to enter lock-down mode call LowerToken:
     target_services->LowerToken();
}

// TargetServices is an abstract class consisting only of pure virtual methods. It is implemented only by TargetServicesBase.
// Its LowerToken method changes the integrity level of a child process based on a global variable called "g_shared_delayed_integrity_level".

// This is initialized to a default value that prevents the integrity level from being changed:

SANDBOX_INTERCEPT IntegrityLevel g_shared_delayed_integrity_level = INTEGRITY_LEVEL_LAST;

DWORD SetProcessIntegrityLevel(IntegrityLevel integrity_level) {
  // We don't check for an invalid level here because we'll just let it
  // fail on the SetTokenIntegrityLevel call later on.
  if (integrity_level == INTEGRITY_LEVEL_LAST) {
    // No mandatory level specified, we don't change it.
    return ERROR_SUCCESS;
  }
  //.....
}

// In renderer processes however, before enabling the sandbox the broker takes care of patching the "g_shared_delayed_integrity_level"
// variable so that the integrity level would be lowered to "UNTRUSTED".

ResultCode PolicyBase::AddTarget(std::unique_ptr<TargetProcess> target) {
    //.....
    g_shared_delayed_integrity_level = delayed_integrity_level_;
    ret = target->TransferVariable("g_shared_delayed_integrity_level",
                                 &g_shared_delayed_integrity_level,
                                 sizeof(g_shared_delayed_integrity_level));
    g_shared_delayed_integrity_level = INTEGRITY_LEVEL_LAST;
    //.....
}

// This is done using WriteProcessMemory, leveraging the fact that on Windows we have "per boot ASLR".
// Basically the contents of the variable from the chrome.exe broker image will be written to the exact same address in
// the renderer process.

// The sandbox library is compiled and linked first as a static library. This will be used to build chrome.exe,
// chrome.dll and other binaries requiring it like NaCl and the cleanup tool.

// In a chrome.exe process context this means we have two implementations of LowerToken: one in chrome.exe and one chrome.dll.
// The latter binary houses the method that enables the sandbox:

void NaClMainPlatformDelegate::EnableSandbox(const content::MainFunctionParams& parameters) {
  sandbox::TargetServices* target_services = parameters.sandbox_info->target_services;

  CHECK(target_services) << "NaCl-Win EnableSandbox: No Target Services!";
  // Cause advapi32 to load before the sandbox is turned on.
  unsigned int dummy_rand;
  rand_s(&dummy_rand);

  // Turn the sandbox on.
  target_services->LowerToken();
}

// The TargetServices object is created by code from chrome.exe and it crosses module boundaries. Since LowerToken
// is a virtual function, the version from chrome.exe should be called.

// What would happend if we could get the version from chrome.dll to be called?

// Well, a diferent "g_shared_delayed_integrity_level" would be checked which will remain initialized to its default
// value. The broker will only path the "g_shared_delayed_integrity_level" from the chrome.exe image.

// This is exactly what happens in the case of this bug. The reason for this is related to a feature of the clang 
// toolchain called "whole-program devirtualization", that is being used in official builds and due to the fact that
// the TargetServices class had what is called "hidden LTO visibility".

// Here are some links that will help you to learn more about how these work together:

// https://marcofoco.com/the-power-of-devirtualization/
// https://clang.llvm.org/docs/LTOVisibility.html

// Hey, this bug was noticeable just by using process explorer! (see the screenshot from twitter post if you don't believe it)
// Patch: https://github.com/chromium/chromium/commit/19d2be5d47e0edc406ef7d93096f54009e47937















