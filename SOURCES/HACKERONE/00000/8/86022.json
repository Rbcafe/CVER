{
  "id": 86022,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC84NjAyMg==",
  "url": "https://hackerone.com/reports/86022",
  "title": "Multiple so called  'type juggling' attacks. Most notably PhabricatorUser::validateCSRFToken() is 'bypassable' in certain cases.",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2015-09-01T01:08:56.393Z",
  "submitted_at": "2015-09-01T01:08:56.393Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "superkritisch",
    "url": "/superkritisch",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 18,
    "url": "https://hackerone.com/phabricator",
    "handle": "phabricator",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/000/018/61446f7e6f0684c8c9f7c36c918b7ecd58183588_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/000/018/61446f7e6f0684c8c9f7c36c918b7ecd58183588_original.jpg/f4a495c04fdb224bac8ec64587537e511aa8c4925e7955bee0a19e0ed7d891dc"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Phabricator",
      "twitter_handle": "phabricator",
      "website": "http://phacility.com/phabricator/",
      "about": "Phabricator is a collection of open source web applications that help software companies build better software."
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2015-10-01T22:57:15.654Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2015-09-01T22:57:01.569Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "/* MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */\r\n\r\nThe Phabricator code base is at various places vulnerable for so called \r\n'type juggling' [1] attacks. Most notably PhabricatorUser::validateCSRFToken()\r\nis 'bypassable' in certain cases.  \r\n\r\n\r\n##Type Juggling\r\nSince PHP's loose type comparison operators compare only data values but not \r\ntheir associated types, deriving variable types from context. PHP's string \r\nconversion rules [2] specify strings (when evaluated in a numeric context) with \r\nleading decimal, hexadecimal, infinity, NAN or radix (a '.') data optionally\r\nfollowed by an exponent are evaluated as floats. \r\n\r\nWhat this means is that a string like 00e13242 is cast to 0 and as such, to PHP \r\n0e94323 == 00e19384. \r\n\r\nTranslated into code, this means that the following comparison:\r\n\r\n    (hash($randomSecret) == $user_input)\r\n\r\nwill return true if hash($randomSecret) returns a hash in the form 0+[eE]\\d+ and\r\nthe $user_input is given as \"0\". This applies to various hashing algorithms, \r\nincluding (but not limited to) MD5 and SHA1. If you're not convinced, try \r\nrunning the PHP-code at the bottom of this text for a PoC with SHA1.\r\n\r\n\r\n##How this applies to Phabricator\r\nIn order to understand how this applies to Phabricator, we need to first know \r\nthat static method PhabricatorHash::digest() located at \r\nsrc/infrastructure/util/PhabricatorHash.php [3] on line 25 returns a sha1 hash\r\nvia hash_hmac();\r\n\r\nThen we need to know that in AphrontRequest::validateCSRF();[4] the static function\r\nPhabricatorUser::validateCSRFToken($token); is called with a user-supplied \r\n$token.\r\n\r\nNow, if we look at PhabricatorUser::validateCSRFToken() located at \r\nphabricator/src/applications/people/storage/PhabricatorUser.php [5], on line 409\r\nwe see that getRawCSRFToken (which also returns a sha1 hash) is called and it's \r\nreturn value is stored in $valid \r\n\r\n    $valid = $this->getRawCSRFToken($ii);\r\n\r\nthen on line 412 we see:\r\n\r\n    if ($token == $valid) {\r\n\r\nor, if the $version is 'breach' we reach this code on line 419-420:\r\n\r\n    $digest = PhabricatorHash::digest($valid, $salt);\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\r\n\r\nBoth these comparisons meets the criteria for type juggling. Since $valid is a \r\nrandomly generated sha1 hash which eventually will be of the form 0+[eE]\\d+ \r\nafter sufficient regenerations and the same goes for $digest. In addition, \r\n$token is a user-supplied value. \r\n\r\n##TL;DR\r\nSo in short, some expected CSRF-tokens will equal a user-supplied CSRF-token \r\ncontaining \"0\". In essence this is a reduction in entropy of the CSRF-tokens.\r\n\r\nto stop PHP from automatically casting either value to another type during \r\ncomparison, simply change: \r\n\r\n    if ($token == $valid) {\r\n\r\nto\r\n\r\n    if ($token === $valid) {\r\n\r\nAnd likewise:\r\n\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) == $token) {\r\n\r\nto\r\n\r\n    if (substr($digest, 0, self::CSRF_TOKEN_LENGTH) === $token) {\r\n\r\n\r\n\r\nIn addition to the above vulnerability, there are other notable misuses of PHP \r\ncomparison operators. \r\n\r\nphabricator/src/applications/conduit/method/ConduitConnectConduitAPIMethod.php:144\r\nin protected function execute(ConduitAPIRequest $request) [6]:\r\n        \r\n        $valid = sha1($token.$user->getConduitCertificate());\r\n        if ($valid != $signature) { \r\n            throw new ConduitException('ERR-INVALID-CERTIFICATE');\r\n\r\nThe != operator is not type strict and $signature is user-specified. $token is \r\nalso user-specified. To fix this != should be changed to !==.\r\n\r\n\r\nphabricator/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php\r\nin verifyMessage() on line 15 and 16 [7]:\r\n\r\n    $sig = $request->getStr('signature');\r\n    return hash_hmac('sha256', $timestamp.$token, $api_key) == $sig\r\n\r\nWhere $sig is obviously a user-supplied value and can thus be 0, and again the \r\nreturn value of hash_hmac can be of the form 0+[eE]\\d+. \r\n\r\nTo fix this, change:\r\n    hash_hmac('sha256', $timestamp.$token, $api_key) == $sig\r\n\r\nto:\r\n    hash_hmac('sha256', $timestamp.$token, $api_key) === $sig\r\n\r\n\r\n\r\n##Examples:\r\n\r\n- type juggling with sha1[8]\r\n\r\n    <?php\r\n    /* sha1 type juggling PoC values */\r\n    $v1 = sha1(\"AAJd1x3j\");\r\n    $v2 = sha1(\"AAPkbYlH\");\r\n    $v3 = sha1(\"AAZlIwOZ\");\r\n\r\n    var_dump($v1, $v2, $v3);\r\n    /* wrong way to compare these hashes */\r\n    var_dump( $v1 == $v2, $v2 == $v3, $v3 == $v1, $v1 == \"0\");\r\n\r\n    /* correct way */\r\n    var_dump( $v1 === $v2, $v2 === $v3, $v3 === $v1 );\r\n    ?>\r\n\r\n\r\n\r\nThe above will output:\r\n\r\n    string(40) \"00e6811279456694288001763399976992804485\"\r\n    string(40) \"0e51223820731210116366152413868569204545\"\r\n    string(40) \"0e13965443605273185827757762777509208778\"\r\n    bool(true)  \r\n    bool(true)\r\n    bool(true)\r\n    bool(true)\r\n    bool(false)\r\n    bool(false)\r\n    bool(false)\r\n\r\n\r\n##References:\r\n1. http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html\r\n2. http://php.net/manual/en/language.types.string.php#language.types.string.conversion\r\n3. https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25\r\n4. https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249\r\n5. https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php\r\n6. https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145\r\n7. https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15\r\n8. https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing\r\n\r\n[1]: http://turbochaos.blogspot.nl/2013/08/exploiting-exotic-bugs-php-type-juggling.html \"1\"\r\n[2]: http://php.net/manual/en/language.types.string.php#language.types.string.conversion \"2\"\r\n[3]: https://github.com/phacility/phabricator/blob/master/src/infrastructure/util/PhabricatorHash.php#L25 \"3\"\r\n[4]: https://github.com/phacility/phabricator/blob/master/src/aphront/AphrontRequest.php#L249 \"4\"\r\n[5]: https://github.com/phacility/phabricator/blob/master/src/applications/people/storage/PhabricatorUser.php \"5\"\r\n[6]: https://github.com/phacility/phabricator/blob/master//src/applications/conduit/method/ConduitConnectConduitAPIMethod.php#L145 \"6\"\r\n[7]: https://github.com/phacility/phabricator/blob/master/src/applications/metamta/controller/PhabricatorMetaMTAMailgunReceiveController.php#L15 \"7\"\r\n[8]: https://pen-testing.sans.org/blog/pen-testing/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing \"8\"\r\n\r\n\r\n\r\n\r\n/*END MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose MONGOOSE mongoose */",
  "weakness": {
    "id": 45,
    "name": "Cross-Site Request Forgery (CSRF)"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2015-10-01T22:57:01.701Z",
  "allow_singular_disclosure_after": -264084497.17317733,
  "singular_disclosure_allowed": true,
  "vote_count": 2,
  "voters": [
    "siddiki",
    "shivammusic"
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
