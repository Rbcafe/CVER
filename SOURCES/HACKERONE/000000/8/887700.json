{
  "id": 887700,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC84ODc3MDA=",
  "url": "https://hackerone.com/reports/887700",
  "title": "[H1-2006 2020]  Multiple vulnerabilities leading account takeover",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "critical",
  "readable_substate": "Resolved",
  "created_at": "2020-05-31T01:37:23.209Z",
  "submitted_at": "2020-05-31T01:37:23.209Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "nukedx",
    "url": "/nukedx",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/CejJr9DapQ8cLv4WyHaDx6LB/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": true,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 46757,
    "url": "https://hackerone.com/h1-ctf",
    "handle": "h1-ctf",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/1hYGHKjWZv64FAEYq32nP1EU/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "paused",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": false,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "h1-ctf",
      "twitter_handle": "Hacker0x01",
      "website": "",
      "about": "Let's save the holidays together! #TogetherWeHitHarder"
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2020-06-17T23:33:03.714Z",
  "bug_reporter_agreed_on_going_public_at": "2020-06-17T22:35:09.380Z",
  "team_member_agreed_on_going_public_at": "2020-06-17T23:33:03.640Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "I'm posting flag and will send my write up upcoming days when I clear my mind after this rabbit holes! :D\n`^FLAG^736c635d8842751b8aafa556154eb9f3$FLAG$`\n\n## Impact\n\nMultiple vulnerabilities leading attacker to takeover any bounty pay user.",
  "weakness": {
    "id": 75,
    "name": "Privilege Escalation"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2020-07-17T22:35:09.438Z",
  "allow_singular_disclosure_after": -112806633.25692712,
  "singular_disclosure_allowed": true,
  "vote_count": 6,
  "voters": [
    "nytr0gen",
    "brahim_boufakri01",
    "zeroxyele",
    "0xwise",
    "odinshell",
    "tobyirish"
  ],
  "severity": {
    "rating": "critical",
    "author_type": "User"
  },
  "structured_scope": {
    "databaseId": 48138,
    "asset_type": "WILDCARD",
    "asset_identifier": "*.bountypay.h1ctf.com",
    "max_severity": "none"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "id": 22762,
      "category": "researcher",
      "content": "## Start of events\nOn May 29th HackerOne announced via [twitter](https://twitter.com/Hacker0x01/status/1266454022124376064) that their lovely CEO *Mårten Mickos* needs to approve bounties on their new payment system called **BountyPay** but looks like he lost his login details and they asked help from the community.\n\nSo as a proud member of the community, I started to check what's **BountyPay** and visited their web page on https://bountypay.h1ctf.com/ for a visual reconnaissance, but that page from very start didn't look promising. They only had login links for their [customers] (https://app.bountypay.h1ctf.com/) and [staff] (https://staff.bountypay.h1ctf.com/)\n\nSince all index pages nearly had zero info from visual reconnaissance except that they are using technologies like Bootstrap and jQuery there was nothing else. So started the initial reconnaissance process.\n\n## Reconnaissance process and leaked credentials\n\nAs we all know reconnaissance is key feature for approaching to target and since I noticed **BountyPay** using different subdomains for staff and their customers, I wanted to see if there is any other subdomains available at all so for it I relied to [amass] (https://github.com/OWASP/Amass) which is really powerful subdomain enumeration and asset discovery tool and executed following:\n`amass enum --passive -d bountypay.h1ctf.com` \n\nAfter few seconds results were like this:\n{F850507}\n\nSo it looks like **BountyPay** had interesting subdomains like **api** and **software** but decided to check them later more after analyzing current initial subdomains **app** and **staff**\n\nTherefore I started directory brute forcing on **app** via using [dirsearch](https://github.com/maurosoria/dirsearch) which is a nice tool for this job and executed it as following:\n\n`python3 ~/dirsearch/dirsearch.py -u https://app.bountypay.h1ctf.com/ -e php,asp,aspx,jsp,html,zip,jar -b -w ~/dirsearch/db/dicc.txt -t 200 -x 502,503 -H 'X-FORWARDED-FOR: 127.0.0.1'` \n\nSince our target could be potentially behind WAF or has some rate limit assigned to IP address, we relied an old trick with using **X-Forwarded-For** header, after few seconds I noticed it found some interesting stuff under `.git` folder\n{F850498}\n\nSo by using **curl** viewed contents of `.git/config`\n`curl -sk https://app.bountypay.h1ctf.com/.git/config`\n\nResponse had some valuable information:\n{F850501}\n\nSo visited `https://github.com/bounty-pay-code/request-logger/` and noticed it was public repository with file called `logger.php` there and it had following source:\n\n{F850503}\n\nIt looks like developers of **BountyPay** were using it for trace logging, it was basically converting requests as json data and encoding them by using **base64** then saving it under `bp_web_trace.log` file\n\nWhen I requested a file by using curl: `curl -sk https://app.bountypay.h1ctf.com/bp_web_trace.log`\n\nInterestingly file was in present there with following data:\n{F850502}\nWhen I decoded **base64** values it became more interesting because it was leaking credentials for user called `brian.oliver`\n\nDecoded values:\n```json\n{\"IP\":\"192.168.1.1\",\"URI\":\"\\/\",\"METHOD\":\"POST\",\"PARAMS\":{\"GET\":[],\"POST\":{\"username\":\"brian.oliver\",\"password\":\"V7h0inzX\"}}}\n{\"IP\":\"192.168.1.1\",\"URI\":\"\\/\",\"METHOD\":\"POST\",\"PARAMS\":{\"GET\":[],\"POST\":{\"username\":\"brian.oliver\",\"password\":\"V7h0inzX\",\"challenge_answer\":\"bD83Jk27dQ\"}}}\n{\"IP\":\"192.168.1.1\",\"URI\":\"\\/statements\",\"METHOD\":\"GET\",\"PARAMS\":{\"GET\":{\"month\":\"04\",\"year\":\"2020\"},\"POST\":[]}\n```\n\n## Using leaked credentials and bypassing 2FA\n\nSince we got some credentials to login, I straightly went for it and credentials was working but there was another problem to deal with which is called as 2FA\n{F850499}\n\nSo I tried leaked 2FA answer `bD83Jk27dQ` which was fitting criteria of `aZ09` and 10 characters, unfortunately it didn't work well then checked the request done to the server with the help of [Burp Suite](https://portswigger.net/) which is a must have tool as bounty hunter and penetration tester.\n\n{F850505} \n\nThere was a parameter called `challenge_hash` which looked like a MD5 hash and surprisingly it wasn't on logs so giving the fact that hash was in present it must be used to verify `challenge_answer` which was actually the value I used from leaking credentials, given the fact that all combinations of `aZ09` which is already 62 elements and being 10 length, brute forcing would be unrealistic because it's 62^10 combinations which is equal to *839299365868340224* so there must be something else, then I decided to change value of `challenge_hash` to **5828c689761cce705a1c84d9b1a1ed5e** the MD5 value of `bD83Jk27dQ` and tried to login again, boom! bypassed the 2FA and we were in as Mr. Brian Oliver.\n\n{F850523}\n\nDashboard of the customers looked very simple and they only had the option to view statements for a given time period. Unfortunately there was nothing on dashboard but something was interesting:\n\n{F850510}\n\nWhen the customer views the statements, the app was actually doing a request on **api.bountypay.h1ctf.com** and retrieving value back to us, that gave me an idea what if there is a SSRF? \n\n\n##Open redirect and SSRF\nSince **api.bountypay.h1ctf.com** was used for api, I hoped it would have some documentation on it and on index of it there was a some valuable info, also it looked like api do not rely/need cookie from **app.bountypay.h1ctf.com**, so we are basically anonymous for api right now.\n\n{F850476}\n\nWhen we mouse over on `REST API` it was actually having `https://api.bountypay.h1ctf.com/redirect?url=https://www.google.com/search?q=REST+API` as a link and that was a clear open redirect but there was some url whitelist as following\n```\nhttps://www.google.com/search?q=REST+API\nhttps://bountypay.h1ctf.com/\nhttps://api.bountypay.h1ctf.com/\nhttps://software.bountypay.h1ctf.com/\nhttps://staff.bountpay.h1ctf.com/\nhttps://www.bountpay.h1ctf.com/\n```\nInterestingly it didn't have `https://app.bountypay.h1ctf.com` in the list but it's a gold in current state, the question is how can we force api to go `/redirect` endpoint and abuse it.\n\nSo I started to check URL return from statement viewing on api `https://api.bountypay.h1ctf.com/api/accounts/F8gHiqSdpK/statements?month=04&year=2020`, it looks like we were able to control the query part of URL with our request on statement viewing, so tried a couple tricks to force URL parser to fail, it didn't.\n\nFurthermore noticed **F8gHiqSdpK** which looked like our account value and our token looked like encoded as *base64* so when I decoded it:\n\n```json\n{\"account_id\":\"F8gHiqSdpK\",\"hash\":\"de235bffd23df6995ad4e0930baac1a2\"}\n```\n\nYes **F8gHiqSdpK** was there with altering now I was able to do directory traversal, luckily they were not checking account value on cookie to verify session but **hash**\n\nSince whitelist on domains were limited, it meant we can not exfiltrate metadata or similar stuff, neither view local services, then decided to check only remaining subdomain I didn't visit **software.bountypay.h1ctf.com**, it looks like our IP address was not allowed to access it.\n\n{F850508}\n\nSo it felt like this is something I must use with SSRF then coded {F850470} for this purpose since SSRF was doable via token cookie.\n\n```\n#!/bin/bash\nhost=\"https://app.bountypay.h1ctf.com/statements?month=04&year=2020\"\ntoken=$(echo '{\"account_id\":\"../../redirect?url=https://software.bountypay.h1ctf.com/'$1'#\",\"hash\":\"de235bffd23df6995ad4e0930baac1a2\"}' | base64 -w 0 | awk {'print \"token=\"$1'})\nrequest=$(curl -sk $host -b $token)\nif [[ ! $request == *\" not found\"* && ! $request == *\"404 Not Found\"* ]]; then\n        data=$(echo $request | jq -c .data)\n        url=$(echo $request | jq -c .url | cut -c 66- | cut -d \"#\" -f 1)\n        now=$(date +\"%T\")\n        echo \"$url : $data\"\nfi\n```\nIt is a simple tool which generates new token and uses it for SSRF on `https://software.bountypay.h1ctf.com`, thanks to **xargs** I was able to run it as multithreaded/multiprocess and for the wordlist I used [common.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/common.txt) \n`cat common.txt | xargs -P 30 -n 1 ./b64search.sh`\n\nAfter few minutes I found out **uploads** folder\n{F850458}\n\nIt was having some file directory listed as `/uploads/BountyPay.apk` but accessing the file with SSRF would be a pain and I hoped there was a permission issue and visited `https://software.bountypay.h1ctf.com/uploads/BountyPay.apk` and luckily, it started downloading.\n\n## Android app and leaked token\n\nSo after downloading the APK file, I started to reverse engineering using [MobSF](https://github.com/MobSF/Mobile-Security-Framework-MobSF), a cool framework for mobile application testing. APK looked like it didn't have any public URL but firebase, so no hidden reconnaissance path was revealed with it.\nI started my **Genymotion** and loaded APK with my virtual android device and continue viewing results from **MobSF**\n\nAndroid manifest revealed there are some activities and they had schemes assigned to each other:\n```xml\n <activity android:theme=\"@style/AppTheme.NoActionBar\" android:label=\"@string/title_activity_part_three\" android:name=\"bounty.pay.PartThreeActivity\">\n            <intent-filter android:label=\"\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"three\" android:host=\"part\" />\n            </intent-filter>\n        </activity>\n        <activity android:theme=\"@style/AppTheme.NoActionBar\" android:label=\"@string/title_activity_part_two\" android:name=\"bounty.pay.PartTwoActivity\">\n            <intent-filter android:label=\"\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"two\" android:host=\"part\" />\n            </intent-filter>\n        </activity>\n        <activity android:theme=\"@style/AppTheme.NoActionBar\" android:label=\"@string/title_activity_part_one\" android:name=\"bounty.pay.PartOneActivity\">\n            <intent-filter android:label=\"\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"one\" android:host=\"part\" />\n            </intent-filter>\n        </activity>\n```\n\nIt looks like APK has some intent checks and bypassing them would be easy, on PartOneActivity, it also hinted us at APK saving data on shared preferences for the process.\n{F850451}\n\nI was able to bypass PartOneActivity's intent checks with adb shell and using it as following:\n`adb shell am start -a android.intent.action.VIEW -d \"one://part?start=PartTwoActivity\" -n bounty.pay/.PartOneActivity`\n\nPartTwoActivity had similar checks:\n{F850455}\nAgain using adb shell as following let me pass intent check:\n`adb shell am start -a android.intent.action.VIEW -d \"two://part?two=light\\&switch=on\" -n bounty.pay/.PartTwoActivity`\n\nWhen we pass the check submit form appeared:\n{F850456}\n\nAs we already figured from source of **PartTwoActivity**, it's checking for if the value we submit has `X-` at very beginning and there was some interesting hash on screen `459a6f79ad9b13cbcb5f692d2cc7a94d` which also looked like a MD5 hash, by querying it via [CrackStation](https://crackstation.net/), I was able to find it was MD5 hash value for `Token`, then entered `X-Token` as answer and proceeded to PartThreeActivity\n\nPartThreeActivity also had some intent checks\n{F850453}\nThis time things were looking a bit different since *base64* involved then I started to check other parts of PartThreeActivity and noticed there was some *base64* values located:\n{F850452}\n\nSo when I decoded value of **directory** result was: `host`, and when decoded value of **directoryTwo** result was: `X-Token`\n\nIntent check also was looking value we supplied for **three** and **switch** parameters as *base64* value of `PartThreeActivity` and `on` as respectively, so encoded `PartThreeActivity` and result was: `UGFydFRocmVlQWN0aXZpdHk=`, for `on` when encoded result was: `b24=` then executed following `adb shell` command:\n\n`adb shell am start -a android.intent.action.VIEW -d \"three://part?three=UGFydFRocmVlQWN0aXZpdHk=\\&switch=b24=\\&header=X-Token\" -n bounty.pay/.PartThreeActivity`\n\nI was able to pass intent check of PartThreeActivity and next step was checking hash value \n{F850454}\n\nSince we already know APK was saving our process on shared preferences, I viewed details of with using adb shell as following:\n`adb shell cat ./data/data/bounty.pay/shared_prefs/user_created.xml`\n\n```xml\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<map>\n    <string name=\"PARTTWO\">COMPLETE</string>\n    <string name=\"USERNAME\">nukedx</string>\n    <string name=\"HOST\">http://api.bountypay.h1ctf.com</string>\n    <string name=\"PARTONE\">COMPLETE</string>\n    <string name=\"TWITTERHANDLE\">mcipekci</string>\n    <string name=\"TOKEN\">8e9998ee3137ca9ade8f372739f062c1</string>\n</map>\n```\n\nHash value needed was **8e9998ee3137ca9ade8f372739f062c1** by entering it I was able to complete APK challenge\n{F850457}\n\nCongratsActivity also had some valuable information which actually we figured out after viewing shared preferences.\n{F850450}\n\nNow we were having some token to use on **api.bountypay.h1ctf.com** \n\n## OSINT and getting staff credentials via API\n\nAfter receiving token for API, started to directory brute force and only able to find few endpoints:\n```\n/api/accounts/{any}\n/api/staff/\n```\nSo API wasn't very talkative to us and looked like very limited with using token did simple `GET` request on `/api/staff` endpoint:\n{F850432}\n\nI was able to find staff details but they were only names and their staff ids, then wanted to test `POST` request on same endpoint, since we had `staff_id` parameter on previous request did some request like this:\n{F850433}\n\nIt was giving error like **Staff Member already has an account**, since staff id's look like `STF:AZ09{10}` combination brute forcing a staff id which is not associated with account details would be hard, around same moments HackerOne made a retweet from handle **BountyPayHQ**\n{F850427}\n\nI start to check that handle and noticed they were celebrating a new team member called **Sandra**\n{F850429}\n\nShe was not in the list of previously found staff members and started to check her twitter profile, interestingly she had some ID card with **BountyPay** logo on it, which was revealing her staff id.\n{F850430}\n\nHer staff id was `STF:8FJ3KFISL3` and tried `POST` request on `/api/staff` endpoint which let me get her credentials:\n{F850431}\n\n## Staff account and privilege escalation \n\nSince I found out login credentials for Sandra, logged in to her account on `https://staff.bountypay.h1ctf.com` but it looks like Sandra didn't have admin details.\n\nStaff panel had some interesting javascript on `https://staff.bountypay.h1ctf.com/js/website.js`\n{F850463}\n\nIt looks like admins can upgrade normal users on the staff system to admin as well and if there is a location hash on URL, javascript automatically triggers a click event for context assigned to them.\n\nThere was also report function for users to report pages they are on to admins or viewing but it strictly stated that: `Pages in the /admin directory will be ignored for security` so we can not use `/admin/upgrade?username=sandra.allison` for reporting too, so there must be a way to privilege escalation.\n\nSince we know `#tab` classes auto clicks if there is a location hash with that class name we can combine multiple classes like `upgradeToAdmin tab2` but we must be able to find an injection point for it.\n\nI realized that there was a update profile option and avatar we select is actually a class defined in cascading style sheet of page, so maybe we can trick server to have some other classes in our avatar, therefore I used inspect element option of my browser and edited value of **avatar2** and saved it:\n{F850461}\n\nAfter updating avatar went to ticket page and inspected avatar of Sandra:\n{F850468}\n\nSo it was successful so decided to check if we can execute javascript with having location hash on URL:\n{F850469}\n\nIt brought some problem username is send as undefined to server, so we must check if there is another endpoint which is having **username** input, since staff portal loading templates as query parameter, tried various potential template names and only one was having **username** input which is very first `login` template, then decided to check if there is any other endpoint unfortunately none.\n{F850465}\n\nSince we know **app.bountypay.h1ctf.com** was running as PHP, only potential thing left to try was sending query string parameter as array, since PHP can read query strings as is which means if we pass `param[]=value` as query string, param will read into array, so we will simply send `template[]=home` as first try to see if it loads page at all, and it was successful then wanted to try `template[]=login&template[]=ticket` in hope of template parameter handled as array too on app itself, result was successful as well now both templates loaded, I requested following page from server `/?template[]=login&template[]=ticket&ticket_id=3582&username=sandra.allison#tab2`\n{F850460}\n\nNow we can try to see if **username** sent as undefined or not:\n{F850462}\n\nSince report to admin function relies `url` variable located on page we must alter it, we could alter request by simply intercepting with any proxy as well but for such simple stuff, I decided to use developer tools:\n{F850467}\n\nIt was executed properly:\n{F850466}\n\nSo it was time to check home page of staff portal and see if we gained admin rights:\n{F850464}\n\nWe were successfully escalated to admin rights and when viewing admin section noticed `marten.mickos` had their password available there as plain text\n{F850459}\n\n##Log in as Marten and pay all the bounties\n\nIt was incredible we find out *Mårten Mickos'* account details and now we can try login into it, looks like we had same 2FA process on very beginning of finding out login credentials for `brian.oliver` so by applying same logic, I was able to login his customer dashboard. after viewing current months statement, I noticed there was some unpaid bounties to our hacker friends:\n{F850443}\n\nIt looks like **BountyPay** had extra layer of security so for approving payments we need another 2FA:\n{F850434}\n\nInterestingly this time there was some weird request which was having parameter called `app_style` in `POST` requests data\n{F850435}\n\nIt looked like SSRF at glance was hitting any target I sent for but result was blind and since initial request had **css** as extension, this looked like either exfiltration data with CSS or some stored XSS, for eliminating stored XSS possibility, I tested simple payload like: `\"><b>x</b>` and request I got on my collab server was having `\"<>/` characters were sanitized and requested filename was looking like `file.extbxb`.\n\nSo I eliminated stored XSS, and checked next page of 2FA, realized this time it's 7 characters and trick we used on initial 2FA was not working so we must gain a 2FA code so went straightforward for exfiltration data with CSS, made {F850441} and started to send request to target.\n{F850438} \n\nAfter some time revealed first 4 chars of input which was `code`: \n{F850442} \n\nSo assumed input value was code and used {F850439} interestingly we were not getting any request at all, output for css from failed attempt was:\n{F850440}\n\nAs we can see we directly used `=code` after altering it to `\"^=code\"`, we realized we were getting two hits this time:\n{F850444}\n\nCurrently we were in misleading direction so we must figure out full input names, given habit of usage on `_` character, wanted to try `code_` as input value and we continued to get multiple requests after than figured out its sequential like `code_1` `code_2` etc and made {F850447}\n\nI think we had some network problem had struggles like:\n{F850448}\n\nAfter few tries we were able to get first 6 characters for 2FA:\n{F850446} \n\nFor last char went for brute forcing with burp intruder and result was:\n{F850437}\n\nSo we paid all the bounties to hackers :)\n\n## Rabbit holes during event\n\n1. `/pay/id/hash/` on `https://app.bountypay.h1ctf.com` forced us to believe there was an IDOR on early stages.\n1. Login screen on `https://software.bountypay.h1ctf.com` \n1. Not being able to download APK due to permission :D\n1. Since we were not expecting any OSINT in the first place, not being able to find any other endpoint on api was so annoying\n1. Before realizing it was loading multiple templates with arrays, we realized each time updating profile was changing cookie value so thought we must decode cookie which was using some custom alphabet base64 and regular base64 over it which is really hard to achieve :D\n1. Open redirect whitelist needs `/` at the end of URL which forced me and many other to believe there was something else :D\n1.  `app_styles` param on the very last 2FA many believed it would be SSRF due to the user agent at first until they realized it's actually imitating a human being.\n\n## After event findings\n\nSince we always getting failed amount data with CSS exfiltration, realized it was actually due to not using **double quote** on input name and value and using `*~` in between of input and style, so it is actually causing some issues with chrome and not processing all styles, fixed php code for my PoC can be found on this [pastebin](https://pastebin.com/VnUrDx5T), since I already made two posts for attachments and didn't want to make another one.\n\nAndroid APK is saving API token right after completing PartOneActivity, so other parts of the event could be skipped by a person who reads and analyzes entire codes :)\n\nOpen redirect whitelist for google is actually checking if `REST` is part of a query string so you can just use `https://www.google.com/?REST` :)\n\nOn first 2FA challenge you can ignore **challenge_answer** since it's not checking length of data send by user and directly push `d41d8cd98f00b204e9800998ecf8427e` as challenge hash which is md5 value of null :)\n\n## Shoutouts\n\n@ziot @superhero exchanging ideas with me during the event, @NahamSec @b3nac and @Adamtlangley for an amazing CTF.\n\n@zeroxyele for letting me figure out issue with CSS exfiltration after finishing it as well during our convo for rabbit holes and issues encountered, he mentioned he was using [Jonathan Omisore's CSS keylogger](https://github.com/JonathanOmisore/CSS-Keylogging/blob/master/css-keylogger-extension/keylogger.css) so after viewing I realized issue for how Chromium was failing to handle CSS files.\n\nI tried to make this write up as much as from my view and wanted to show using different tools and ways is possible to achieve the same results, instead of relying on one tool. I hope whoever reads this write up will enjoy it as much as I enjoyed the CTF and writing this up :)",
      "user": {
        "id": 404926,
        "username": "nukedx",
        "name": "Mustafa Can IPEKCI",
        "bio": "Just here for fun",
        "cleared": true,
        "verified": true,
        "website": "https://www.nukedx.com",
        "location": "milw0rm",
        "created_at": "2018-11-13T13:33:43.946Z",
        "url": "https://hackerone.com/nukedx",
        "hackerone_triager": false,
        "hackerone_employee": false,
        "user_type": "hacker",
        "profile_picture_urls": {
          "small": "https://profile-photos.hackerone-user-content.com/variants/CejJr9DapQ8cLv4WyHaDx6LB/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c",
          "medium": "https://profile-photos.hackerone-user-content.com/variants/CejJr9DapQ8cLv4WyHaDx6LB/f4a495c04fdb224bac8ec64587537e511aa8c4925e7955bee0a19e0ed7d891dc",
          "xtralarge": "https://profile-photos.hackerone-user-content.com/variants/CejJr9DapQ8cLv4WyHaDx6LB/114764ec8f01b1a3e153599212c9f011fb3b0bce3a4fdc1f9a3c551f8c94acf8"
        }
      },
      "can_view?": true,
      "can_create?": false,
      "attachments": []
    }
  ]
}
