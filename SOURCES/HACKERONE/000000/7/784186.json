{
  "id": 784186,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC83ODQxODY=",
  "url": "https://hackerone.com/reports/784186",
  "title": "napi_get_value_string_X allow various kinds of memory corruption",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "high",
  "readable_substate": "Resolved",
  "created_at": "2020-01-27T16:49:36.768Z",
  "submitted_at": "2020-01-27T16:49:36.768Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "tniessen",
    "url": "/tniessen",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 22984,
    "url": "https://hackerone.com/nodejs",
    "handle": "nodejs",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Node.js",
      "twitter_handle": "nodejs",
      "website": "https://nodejs.org",
      "about": "The Node.js JavaScript Runtime"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": true,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2020-8174"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2020-07-02T19:53:41.174Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2020-06-02T19:53:24.048Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "**Summary:**\n\n`napi_get_value_string_latin1`, `napi_get_value_string_utf8`, `napi_get_value_string_utf16` are vulnerable to buffer overflows, partially due to an integer underflow.\n\n**Description:**\n\n`napi_get_value_string_latin1`, `napi_get_value_string_utf8`, and `napi_get_value_string_utf16` behave like this:\n\n1. If the output pointer is `NULL`, return.\n2. Write `min(string_length, bufsize - 1)` bytes to the output buffer. Note that `bufsize` is an unsigned type, so this leads to an integer underflow for `bufsize == 0`. Since this is a `size_t`, the underflow will cause the entire string to be written to memory, no matter how long the string is.\n3. Finally, write to `buf[copied]`, where `copied` is the number of bytes previously written. Even if step 2 hadn't written out of bounds, this would (for `bufsize == 0`).\n\n## Steps To Reproduce:\n\n```cpp\nNapi::Value Test(const Napi::CallbackInfo& info) {\n  char buf[1];\n  // This should be a valid call, e.g., due to a malloc(0).\n  napi_get_value_string_latin1(info.Env(), info[0], buf, 0, nullptr);\n  return info.Env().Undefined();\n}\n```\n\n```js\nconst binding = require('bindings')('validation');\nconsole.log(binding.test('this could be code that might later be executed'));\n```\n\nRunning the above script corrupts the call stack:\n\n```bash\ntniessen@local-vm:~/validation-fails$ node .\n*** stack smashing detected ***: <unknown> terminated\nAborted (core dumped)\n```\n\nThe best outcome is a crash, but a very likely outcome is data corruption. If the attacker can control the string's contents, they can even insert code into the process heap, or modify the call stack. Depending on the architecture and application, this can lead to various issues, up to remote code execution.\n\nIt is perfectly valid to pass in a non-NULL pointer for `buf` while specifying `bufsize == 0`. For example, `malloc(0)` is not guaranteed to return `NULL`.  A npm package might correctly work on one machine based on the assumption that `malloc(0) == NULL`, but might create severe security issues on a different host. Passing a non-NULL pointer is also not ruled out by the documentation of N-API, so it is not valid to assume that `buf` will always be `NULL` if `bufsize == 0`.\n\n## Impact\n\nnpm packages and other applications that use N-API may involuntarily open up severe security issues, that might even be exploitable remotely. Even if `buf` is a valid pointer, passing `bufsize == 0` allows to write outside of the boundaries of that buffer.\n\nStep 2 of the description allows an attacker to precisely define what is written to memory by passing in a custom string. Depending on whether the pointer points to heap or stack, possible results include data corruption, crashes (and thus DoS), and possibly even remote code execution, either by writing instructions to heap memory or by corrupting the stack.\n\nMany attacks are likely caught by kernel and hardware protection mechanisms, but that depends on the specific hardware, kernel, and application, and memory layout. Even if they are caught, the entire process will crash (which is still good compared to other outcomes).",
  "bounty_amount": "250.0",
  "formatted_bounty": "$250",
  "weakness": {
    "id": 2,
    "name": "Memory Corruption - Generic"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2020-07-02T19:53:24.119Z",
  "allow_singular_disclosure_after": -114111785.84353559,
  "singular_disclosure_allowed": true,
  "vote_count": 7,
  "voters": [
    "tniessen",
    "dwisiswant0",
    "donotenter",
    "tr1n1ty8",
    "ubn",
    "ohioguy",
    "beforedayone"
  ],
  "severity": {
    "rating": "high",
    "score": 8.5,
    "author_type": "User",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "high",
      "privileges_required": "low",
      "user_interaction": "none",
      "scope": "changed",
      "confidentiality": "low",
      "integrity": "high",
      "availability": "high"
    }
  },
  "structured_scope": {
    "databaseId": 666,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/nodejs/node",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
