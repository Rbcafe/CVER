{
  "id": 730779,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC83MzA3Nzk=",
  "url": "https://hackerone.com/reports/730779",
  "title": "HTTP header values do not have trailing OWS trimmed",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "high",
  "readable_substate": "Resolved",
  "created_at": "2019-11-06T17:46:12.794Z",
  "submitted_at": "2019-11-06T17:46:12.794Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "alyssawilk",
    "url": "/alyssawilk",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 22984,
    "url": "https://hackerone.com/nodejs",
    "handle": "nodejs",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Node.js",
      "twitter_handle": "nodejs",
      "website": "https://nodejs.org",
      "about": "The Node.js JavaScript Runtime"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2019-15606"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2020-02-24T17:48:42.993Z",
  "bug_reporter_agreed_on_going_public_at": "2020-02-24T17:48:42.940Z",
  "team_member_agreed_on_going_public_at": "2020-02-06T19:32:33.795Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "[I suspect I may have tagged the wrong vulnerability type -I'm failing to find \"insufficient validation of user input\"]\n\nAccording to the HTTP-spec, http values are\n       field-value    = *( field-content | LWS )\nhttp_parser does not appear to trim trailing LWS. This means if a user sends \"Host: foo\\r\\n\" the string literal \"foo\" is passed up, but if the user sends \"Host: foo \\r\\n\" the string literal \"foo \" is passed up, complete with trailing LWS.\n\n## Steps To Reproduce:\n\n(Add details for how we can reproduce the issue)\n\nIf one hands \"GET / HTTP/1.1\\r\\nHost: foo.com \\r\\nHello: World\\r\\n\\r\\n\"\nto http_parser, http_parser sends on_header_value \"foo.com \" instead of \"foo.com\"\n\n## Impact: [add why this issue matters]\n\nWe are trying to address an issue with Envoy, where if \n\"GET / HTTP/1.1\\r\\nHost: my-super-private-domain.com \\r\\nHello: World\\r\\n\\r\\n\"\nis passed to Envoy, and Envoy is configured to block any requests to \"my-super-private-domain.com\", the matcher fails due the trailing whitespace, and external users can tunnel requests that should be blocked.\n\nOriginally we were going to address this by doing whitespace trimming in Envoy, but this should probably be fixed upstream in http_parser in case other users are affected, so we're reaching out to see what folks on your end think.\n\n## Supporting Material/References:\n\nMy Envoy regression test verifies this lack of LWS trimming, but this is current under envoy security embargo, so please don't share\n\nTEST_F(Http1ServerConnectionImplTest, LWS) {                                                         \n  initialize();                                                                                      \n                                                                                                     \n  InSequence sequence;                                                                               \n                                                                                                     \n  Http::MockStreamDecoder decoder;                                                                   \n  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));                             \n                                                                                                     \n  TestHeaderMapImpl expected_headers{                                                                \n      {\"Test\", \"value \"},      // note the LWS after value is passed up from http_parser to Envoy :-(                                                                       \n      {\"Hello\", \"World\"},                                                                            \n      {\":path\", \"/\"},                                                                                \n      {\":method\", \"GET\"},                                                                            \n  };                                                                                                 \n  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), true)).Times(1);            \n                                                                                                     \n  Buffer::OwnedImpl buffer(\"GET / HTTP/1.1\\r\\nTest: value \\r\\nHello: World\\r\\n\\r\\n\");                \n  codec_->dispatch(buffer);                                                                          \n  EXPECT_EQ(0U, buffer.length());                                                                    \n}\n\n## Impact\n\nAs said above, this could allow privileged escalation, where if one uses an http_parser  enabled server configured to block specific domains, those blocks can be trivially bypassed using white-space. It's possible there are other attacks bypassing http_parser header value checks with whitespace, but I haven't investigated beyond the most obvious exploit",
  "weakness": {
    "id": 107,
    "name": "Improper Input Validation"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2020-03-07T19:32:33.877Z",
  "allow_singular_disclosure_after": -124221511.87568486,
  "singular_disclosure_allowed": true,
  "vote_count": 11,
  "voters": [
    "a_d_a_m",
    "rut00",
    "b69fb2ebda43240ece9dbeb",
    "viicius",
    "ubn",
    "ohioguy",
    "ranulldd",
    "donotenter",
    "b7818470ba6a56b3da0f4f3",
    "bountyhuntersforthewin",
    "and 1 more..."
  ],
  "severity": {
    "rating": "high",
    "score": 7.4,
    "author_type": "User",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "low",
      "privileges_required": "none",
      "user_interaction": "required",
      "scope": "changed",
      "confidentiality": "low",
      "integrity": "low",
      "availability": "none"
    }
  },
  "structured_scope": {
    "databaseId": 666,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/nodejs/node",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
