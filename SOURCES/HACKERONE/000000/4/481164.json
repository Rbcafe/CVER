{
  "id": 481164,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC80ODExNjQ=",
  "url": "https://hackerone.com/reports/481164",
  "title": "Monero can leak unitialized memory",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "medium",
  "readable_substate": "Resolved",
  "created_at": "2019-01-16T21:33:28.884Z",
  "submitted_at": "2019-01-16T21:33:28.884Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "guido",
    "url": "/guido",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 7731,
    "url": "https://hackerone.com/monero",
    "handle": "monero",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": false,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Monero",
      "twitter_handle": "monero",
      "website": "https://getmonero.org",
      "about": " Monero: the secure, private, untraceable cryptocurrency"
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2019-07-02T22:49:44.832Z",
  "bug_reporter_agreed_on_going_public_at": "2019-06-03T14:19:44.708Z",
  "team_member_agreed_on_going_public_at": "2019-07-02T22:49:44.413Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "See this proof of concept:\n\n```cpp\n#include <net/http_client.h>\n#include <rpc/core_rpc_server_commands_defs.h>\n#include <storages/http_abstract_invoke.h>\n\nINITIALIZE_EASYLOGGINGPP\n\ntemplate <class T>\nstatic void invoke_http_json(void)\n{\n    typename T::request ireq;\n    typename T::response ires;\n\n    std::string req_param;\n    if(!epee::serialization::store_t_to_json(ireq, req_param)) {\n        return;\n    }\n    printf(\"%s\\n\", req_param.c_str());\n}\n\nint main(void)\n{\n    while ( true ) {\n        const unsigned char which = rand() % 65;\n        printf(\"which: %u\\n\", which);\n        switch ( which ) {\n            case 0:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_HEIGHT>();\n                break;\n\n            case 1:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCKS_FAST>();\n                break;\n\n            case 2:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCKS_BY_HEIGHT>();\n                break;\n\n            case 3:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_ALT_BLOCKS_HASHES>();\n                break;\n\n            case 4:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_HASHES_FAST>();\n                break;\n\n            case 5:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_ADDRESS_TXS>();\n                break;\n\n            case 6:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_ADDRESS_INFO>();\n                break;\n\n            case 7:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_UNSPENT_OUTS>();\n                break;\n\n            case 8:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_RANDOM_OUTS>();\n                break;\n\n            case 9:\n                invoke_http_json<cryptonote::COMMAND_RPC_SUBMIT_RAW_TX>();\n                break;\n\n            case 10:\n                invoke_http_json<cryptonote::COMMAND_RPC_LOGIN>();\n                break;\n\n            case 11:\n                invoke_http_json<cryptonote::COMMAND_RPC_IMPORT_WALLET_REQUEST>();\n                break;\n\n            case 12:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTIONS>();\n                break;\n\n            case 13:\n                invoke_http_json<cryptonote::COMMAND_RPC_IS_KEY_IMAGE_SPENT>();\n                break;\n\n            case 14:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TX_GLOBAL_OUTPUTS_INDEXES>();\n                break;\n\n            case 15:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN>();\n                break;\n\n            case 16:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_OUTPUTS>();\n                break;\n\n            case 17:\n                invoke_http_json<cryptonote::COMMAND_RPC_SEND_RAW_TX>();\n                break;\n\n            case 18:\n                invoke_http_json<cryptonote::COMMAND_RPC_START_MINING>();\n                break;\n\n            case 19:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_INFO>();\n                break;\n\n            case 20:\n                invoke_http_json<cryptonote::COMMAND_RPC_STOP_MINING>();\n                break;\n\n            case 21:\n                invoke_http_json<cryptonote::COMMAND_RPC_MINING_STATUS>();\n                break;\n\n            case 22:\n                invoke_http_json<cryptonote::COMMAND_RPC_SAVE_BC>();\n                break;\n\n            case 25:\n                invoke_http_json<cryptonote::COMMAND_RPC_GETBLOCKTEMPLATE>();\n                break;\n\n            case 27:\n                invoke_http_json<cryptonote::COMMAND_RPC_GENERATEBLOCKS>();\n                break;\n\n            case 28:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_LAST_BLOCK_HEADER>();\n                break;\n\n            case 29:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HASH>();\n                break;\n\n            case 30:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCK_HEADER_BY_HEIGHT>();\n                break;\n\n            case 31:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCK>();\n                break;\n\n            case 32:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_PEER_LIST>();\n                break;\n\n            case 33:\n                invoke_http_json<cryptonote::COMMAND_RPC_SET_LOG_HASH_RATE>();\n                break;\n\n            case 34:\n                invoke_http_json<cryptonote::COMMAND_RPC_SET_LOG_LEVEL>();\n                break;\n\n            case 35:\n                invoke_http_json<cryptonote::COMMAND_RPC_SET_LOG_CATEGORIES>();\n                break;\n\n            case 36:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTION_POOL>();\n                break;\n\n            case 37:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTION_POOL_HASHES_BIN>();\n                break;\n\n            case 38:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTION_POOL_HASHES>();\n                break;\n\n            case 39:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTION_POOL_BACKLOG>();\n                break;\n\n            case 40:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_TRANSACTION_POOL_STATS>();\n                break;\n\n            case 41:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_CONNECTIONS>();\n                break;\n\n            case 42:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BLOCK_HEADERS_RANGE>();\n                break;\n\n            case 43:\n                invoke_http_json<cryptonote::COMMAND_RPC_STOP_DAEMON>();\n                break;\n\n            case 44:\n                invoke_http_json<cryptonote::COMMAND_RPC_FAST_EXIT>();\n                break;\n\n            case 45:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_LIMIT>();\n                break;\n\n            case 46:\n                invoke_http_json<cryptonote::COMMAND_RPC_SET_LIMIT>();\n                break;\n\n            case 47:\n                invoke_http_json<cryptonote::COMMAND_RPC_OUT_PEERS>();\n                break;\n\n            case 48:\n                invoke_http_json<cryptonote::COMMAND_RPC_IN_PEERS>();\n                break;\n\n            case 49:\n                invoke_http_json<cryptonote::COMMAND_RPC_START_SAVE_GRAPH>();\n                break;\n\n            case 50:\n                invoke_http_json<cryptonote::COMMAND_RPC_STOP_SAVE_GRAPH>();\n                break;\n\n            case 51:\n                invoke_http_json<cryptonote::COMMAND_RPC_HARD_FORK_INFO>();\n                break;\n\n            case 52:\n                invoke_http_json<cryptonote::COMMAND_RPC_GETBANS>();\n                break;\n\n            case 53:\n                invoke_http_json<cryptonote::COMMAND_RPC_SETBANS>();\n                break;\n\n            case 54:\n                invoke_http_json<cryptonote::COMMAND_RPC_FLUSH_TRANSACTION_POOL>();\n                break;\n\n            case 55:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_OUTPUT_HISTOGRAM>();\n                break;\n\n            case 56:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_VERSION>();\n                break;\n\n            case 57:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_COINBASE_TX_SUM>();\n                break;\n\n            case 58:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_BASE_FEE_ESTIMATE>();\n                break;\n\n            case 59:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_ALTERNATE_CHAINS>();\n                break;\n\n            case 60:\n                invoke_http_json<cryptonote::COMMAND_RPC_UPDATE>();\n                break;\n\n            case 61:\n                invoke_http_json<cryptonote::COMMAND_RPC_RELAY_TX>();\n                break;\n\n            case 62:\n                invoke_http_json<cryptonote::COMMAND_RPC_SYNC_INFO>();\n                break;\n\n            case 63:\n                invoke_http_json<cryptonote::COMMAND_RPC_GET_OUTPUT_DISTRIBUTION>();\n                break;\n\n            case 64:\n                invoke_http_json<cryptonote::COMMAND_RPC_POP_BLOCKS>();\n                break;\n        }\n    }\n\n    return 0;\n}\n```\n\nCompile:\n\n```\ng++ -std=c++11 -I $MONERO_PATH/src -I $MONERO_PATH/contrib/epee/include -I $MONERO_PATH/external/easylogging++ $MONERO_PATH/external/easylogging++/easylogging++.cc uninitialized-memory-send.cpp -lpthread -lboost_system -lcrypto -lssl\n```\n\nRun:\n\n```\n./a.out | head -n1000000 | sort -u >output\n```\n\nIf you examine ```output```, you'll see that JSON is generated with random data. This is uninitialized memory created at the instantiation of ```ireq```.\n\nTo solve this, initialize ```ireq```. For example, change\n\n```\n    typename T::request ireq;\n```\n\nto\n\n```\n    boost::value_initialized<typename T::request> _ireq;\n    typename T::request& ireq = _ireq;\n\n```\n\nCompile and run again, and you'll see that the random data is now gone.\n\nAmong other places, ```src/wallet/wallet2.cpp``` contains many calls to ```invoke_http_json```, with some ```::request``` structs initialized with ```AUTO_VAL_INIT```, but some not.\n```invoke_http_json``` serializes the ```::request``` struct exactly like in my proof-of-concept which is then sent to the RPC server:\n\n\n```\nnamespace epee\n{\n  namespace net_utils\n  {\n    template<class t_request, class t_response, class t_transport>\n    bool invoke_http_json(const boost::string_ref uri, const t_request& out_struct, t_response& result_struct, t_transport& transport, std::chrono::milliseconds timeout = std::chrono::seconds(15), const boost::string_ref method = \"GET\")\n    {   \n      std::string req_param;\n      if(!serialization::store_t_to_json(out_struct, req_param))\n        return false;\n\n      http::fields_list additional_params;\n      additional_params.push_back(std::make_pair(\"Content-Type\",\"application/json; charset=utf-8\"));\n\n      const http::http_response_info* pri = NULL;\n      if(!transport.invoke(uri, method, req_param, timeout, std::addressof(pri), std::move(additional_params)))  \n      ...\n      ...\n```\n\nAny outbound traffic (bootstrap node/public RPC server/other) where the ```::request``` struct is not explicitly initialized, is thus susceptible to leaking uninitialized memory. Uninitialized memory is never literally uninitialized -- it contains remnants of previous use of the same memory region, and this can include cryptographic or other private material.\n\n## Impact\n\nLeaking sensitive data to untrusted network peers.",
  "weakness": {
    "id": 18,
    "name": "Information Disclosure"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2019-07-03T14:19:44.786Z",
  "allow_singular_disclosure_after": -145666611.5125104,
  "singular_disclosure_allowed": true,
  "vote_count": 5,
  "voters": [
    "ali",
    "guido",
    "tiago-danin",
    "armansameer",
    "lovebugpaul"
  ],
  "severity": {
    "rating": "medium",
    "author_type": "User"
  },
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
