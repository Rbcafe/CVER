{
  "id": 685909,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC82ODU5MDk=",
  "url": "https://hackerone.com/reports/685909",
  "title": "Searching from Hacktivity returns hits for words in limited disclosure reports that are not visible",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "medium",
  "readable_substate": "Resolved",
  "created_at": "2019-09-01T11:28:31.585Z",
  "submitted_at": "2019-09-01T11:28:31.585Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "nathand",
    "url": "/nathand",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/NY2oTeWofAnqK1X5MRNFCDXy/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 13,
    "url": "https://hackerone.com/security",
    "handle": "security",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/000/013/fa942b9b1cbf4faf37482bf68458e1195aab9c02_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/000/013/fa942b9b1cbf4faf37482bf68458e1195aab9c02_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "HackerOne",
      "twitter_handle": "Hacker0x01",
      "website": "https://hackerone.com",
      "about": "Vulnerability disclosure should be safe, transparent, and rewarding."
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2019-11-08T21:27:56.007Z",
  "bug_reporter_agreed_on_going_public_at": "2019-11-08T21:27:55.912Z",
  "team_member_agreed_on_going_public_at": "2019-11-08T20:47:16.366Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "**Summary:**\n\nIt appears I'm able to discover words used in limited disclosed reports, that are not publicly visible, by using the search function available from the Hactivity page.\n\n**Description:**\n\nRecently I was investigating a finding for another program which involved exploiting XSS ████. I wondered how relevant exploiting ████ was to programs these days, so I set about searching Hackerone for relevant reports. Normally I'd just use Google for this, but this time I decided to use the Hackerone search in the Hacktivity stream page. To find relevant reports, I first searched for:\n\n```\nxss ███████\n```\n\nOr in URL form: ██████\n\nThis returned a lot of clearly relevant reports. However, when I came across the report #413412 in the search results, entitled \"Reflected XSS on secure.chaturbate.com\", I noticed something a bit odd - it doesn't mention ███████ anywhere in the report that is publicly visible (and in fact that string is nowhere to be found in its markup such as keyword meta data):\n\nhttps://hackerone.com/reports/413412\n\nHowever, in the results, Chaturbate does have a report ██████████ involving XSS ████, so it seems probable this limited report is referencing ██████████, even though what's publicly available does not mention this.\n\nThis had me wondering if I stumbled across a bug in Hackerone report searching, where by I am able to reveal words contained within the hacker's description and/or comments of limited disclosed reports. To test this theory, I wrote a script to perform this search, but while also adding other words, and seeing if this report still gets returned in the results, and try and reveal more content that is not available in the limited public report. For which words to add I used a list of the 'top 3000 English words' and ignored words that are 3 characters or shorter in length, or are very common (than, that, your etc).\n\nThe results proved successful, in the sense I was able to build a lengthy search query that only returns this report, of words that are not found in the limited report (but still seem fairly likely to be matches, given the context). This search string was:\n\n```\nxss ████████ against application attack dangerous detect convince deliver direct mail mechanism occur publicly reference remove request responsible scheme script security supply themselves under victim vulnerable\n```\n\nOr in URL form: ███████\n\nWhile this particular example did not reveal any sensitive information for this specific report, I thought this worth reporting due to the obvious potential here to find details in reports that the program may not want to be public.\n\n### Steps To Reproduce\n\n1. Go to the Hacktivity page.\n2. Search for `xss ███ against application attack dangerous detect convince deliver direct mail mechanism occur publicly reference remove request responsible scheme script security supply themselves under victim vulnerable`\n3. Note the single result as report #413412, and other than \"XSS\", none of these words appear in the limited disclosed public report.\n\n## Impact\n\nBy abusing this, an attacker could reveal content hidden in a limited disclosed report.",
  "weakness": {
    "id": 18,
    "name": "Information Disclosure"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2019-12-08T20:47:16.509Z",
  "allow_singular_disclosure_after": -131992820.26234855,
  "singular_disclosure_allowed": true,
  "vote_count": 126,
  "voters": [
    "nohats",
    "m4t35z",
    "ak-ka",
    "dirk",
    "taha",
    "njmulsqb",
    "oxecho",
    "phys",
    "vampirex",
    "p1stachios",
    "and 116 more..."
  ],
  "severity": {
    "rating": "medium",
    "score": 4.4,
    "author_type": "Team",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "high",
      "privileges_required": "none",
      "user_interaction": "none",
      "scope": "unchanged",
      "confidentiality": "low",
      "integrity": "none",
      "availability": "none"
    }
  },
  "structured_scope": {
    "databaseId": 3,
    "asset_type": "URL",
    "asset_identifier": "hackerone.com",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "id": 18809,
      "category": "team",
      "content": "@nathand reported a security vulnerability to HackerOne that allowed a user to determine redacted or private information through search results in very specific cases. We applaud @nathand's thoroughness and effort for disclosing this security vulnerability to us. HackerOne conducted a root cause analysis of the vulnerability and determined that it affected a few publicly disclosed reports. No signs of exploitation were found.\n\n# Root cause analysis\nTo analyze the root cause, it is important to understand the timeline first of the security vulnerability that was reported.\n\n| **Date** | **Item** |\n| ------ | ------ |\n| September 24, 2018 | `glc` submits a [security vulnerability](https://hackerone.com/reports/413412) with `██████` in the title. |\n| September 24, 2018 | `williammmllc` (team member) requests limited disclosure of [#413412](https://hackerone.com/reports/413412). | \n| October 17, 2018 | `glc` (reporter) agrees to disclosure of [#413412](https://hackerone.com/reports/413412). | \n| November, 2018 | HackerOne engineering team rolls out a data migration to backfill the search vector that would be used when Hacktivity Search would be launched (somewhere in the future). At this point, `██████` was stored in the search vector because it was part of the report title. |\n| May 1, 2019| `williammmllc` updates the title and removes the word `██████`. The search vectors are **expected** to be updated, but aren't. |\n| September 1, 2019 | `nathand` submits a security vulnerability to HackerOne that the report shows up in the search results when they search for `██████`. |\n\nThe engineering team that implemented the search functionality designed the feature in a way that the backfill should get the search vectors in the exact same state as when the report would be submitted after the backfill. The backfill ran before Hacktivity Search was released to the public. One of the architectural decisions the team made to keep search vectors up to date, was by hooking into the `after_commit` hook in the `Report` model. This hook would then validate whether the vector had to be updated. Below is an excerpt of that code.\n\n```ruby\nclass Report < ActiveRecord::Base\n  # ...\n  after_commit do\n    update_hacktivity_search_content_async\n  end\n\n  # ...\n\n  def update_hacktivity_search_content_async\n    return unless should_update_hacktivity_search_content?\n\n    # schedule a job to update the vector\n  end\n\n  def should_update_hacktivity_search_content?\n    new? ||\n      previous_changes.keys.include?('title') ||\n      previous_changes.keys.include?('vulnerability_information') ||\n      previous_changes.keys.include?('weakness_id') ||\n      previous_changes.keys.include?('structured_scope_id') ||\n      previous_changes.keys.include?('team_id') ||\n      previous_changes.keys.include?('public_view') ||\n      previous_changes.keys.include?('disclosed_at')\n  end\n\n  # ...\nend\n```\n\nAs can be seen in the code, whenever one of the attributes mentioned in the `should_update_hacktivity_search_content` method would be changed, an asynchronous job would be scheduled to update the vector. This meant that the team didn't have to go through every code path and make sure they triggered the correct job to update the vector. At HackerOne, usage of ActiveRecord hooks is generally discouraged due to the complexity it adds to a request or transaction lifecycle.\n\nThe team looked into the behaviors of the `previous_changes` hash in combination with the `after_commit` hook. Small code snippets were used to track down the exact behavior. Some of those code examples are shared below. \n\nRunning the code below invokes an update of the vector, as expected:\n\n```ruby\nreport = Report.find 123\nreport.update title: 'new title'\n```\n\nBecause the `after_commit` hook is used, it'll execute the code after the transaction has been completed OR immediately when the SQL query is not ran in a transaction block. The following code, when run on a Rails console, will call the hook twice:\n\n```ruby\nreport = Report.find 123\nreport.update title: 'new title'\nreport.update vulnerability_information: 'new information'\n```\n\nHowever, when the code is ran in a transaction block, the Postgres state and Ruby memory state start to diverge. This means that the following code will only trigger the hook once:\n\n```ruby\nActiveRecord::Base.transaction do\n  report = Report.find 123\n  report.update title: 'new title'\n  report.update vulnerability_information: 'new information'\nend\n```\n\nIt is important to know that *every* request (except `show` and `index` actions) is automatically wrapped in a transaction. Subsequently, a number of service objects explicitly create transactions. The behavior described above does *not* change with nested transactions.\n\nThis all matters because a code path that updates a single `Report` object multiple times in a single transaction may cause the `after_commit` hook to miss columns that the engineers expected it to be stored in the `previous_changes` hash. This is especially confusing because in integration tests for some interactions, individual service object are tested, which are not necessarily wrapped in a transaction. This means the behavior in the test suite was not representative of the behavior of other environments.\n\nWhen conducting the root cause analysis, HackerOne established a code pattern that could be used to identify code paths that update `Report` models multiple times during a request lifecycle. A number of code paths were identified, including the scenario where a team member requested disclosure, the reported agreed, and then the team member would update the title of the report. Below is an excerpt of that code path.\n\n**app/controllers/reports_controller.rb**\n```ruby\nclass ReportsController < ApplicationController\n  # ...\n\n  def update\n    report = Report.find_by(id: params[:id])\n\n    # ...\n        interact Interactors::Reports::UpdateTitle, report: report, title: params[:title]\n\n    # ...\n  end\n\n  # ...\nend\n```\n\nThe controller dispatches the interaction to the `UpdateTitle` service object. Because it's called through a controller action, the interaction is automatically wrapped in a transaction.\n\n**app/backend/interactors/reports/update_title.rb**\n```ruby\nmodule Interactors\n  module Reports\n    class UpdateTitle < HackeroneInteractor\n      # ...\n\n      def execute\n        old_title = report.title\n\n        return unless report.update(title: title) # <-- FIRST UPDATE CALL\n\n        interact ::Interactors::Activities::Create, # <-- LOGGING THE TITLE CHANGE\n          # ...\n      end\n\n      # ...\n    end\n  end\nend\n```\n\nThe interaction above contains the first `update` call. If the title is updated, an activity will be created to track the change.\n\n**app/backend/interactors/activities/create.rb**\n```ruby\nmodule Interactors\n  module Activities\n    class Create < HackeroneInteractor\n      # ...\n\n      def execute\n        activity = nil\n\n        ActiveRecord::Base.transaction do # <-- NESTED TRANSACTION\n          activity = interact Commands::Activities::Create,\n            # ...\n\n          if activity.persisted?\n            if subject.is_a? Report\n              # ...\n\n              if !activity.internal? &&\n                  current_user.is_a?(User) &&\n                  current_user.member_of_team?(subject.team) &&\n                  !activity.is_a?(::Activities::BugFiled)\n                subject.stop_timer Report::TIMER_FIRST_PROGRAM_RESPONSE\n                subject.save! # <-- SECOND UPDATE\n        # ...\n      end\n    end\n  end\nend\n```\n\nFollowing the logic above, `subject.save!` is called when the program member updates the title. The `TIMER_FIRST_PROGRAM_RESPONSE` had already stopped for report #413412, but calling `save!` on a model without changes will still clear out the `previous_changes` hash. This means that when the transaction block is committed, `previous_changes` will be an empty hash -- resulting in the job to update the vector **not** to be scheduled. This proved the security vulnerability as reported by @nathand.\n\nWhen going through other code paths, a functional error was discovered, too. After every created activity in the backend of HackerOne, a side effect is called that updates a cache on the `Report` model to track certain dates; for example, when the last public activity was posted and when the last internal activity was posted. Because this was called every time the `Interactors::Activities::Create` service object was invoked, the `previous_changes` hash would typically only contain those attributes and disregard any other attribute that was updated in the request. This resulted in a functional bug where the vector wouldn't be updated at all and default to the name of the program, handle of the program, and the username of the reporter.\n\n# Remediation\nThe engineering team wrote a regression spec to prove the security vulnerability and functional bug. It turned out that [a number of other engineers outside of HackerOne have run into similar problems](https://medium.com/ruby-on-rails/activerecord-transaction-gotchas-277c048dc3ca), letting them to develop a [library that solves this problem](https://github.com/dylanahsmith/ar_transaction_changes). They have proposed to merge this change back into ActiveRecord and [make it a first class citizen of the Rails / ActiveRecord family](http://github.com/dylanahsmith/ar_transaction_changes/issues/16). HackerOne has leveraged this library to mitigate the reported security vulnerability.",
      "user": {
        "id": 2,
        "username": "jobert",
        "name": "Jobert Abma",
        "bio": "Co-founder of HackerOne. ಠ_ಠ",
        "cleared": true,
        "verified": true,
        "website": "https://hackerone.com",
        "location": "San Francisco, CA",
        "created_at": "2013-03-08T01:17:12.256Z",
        "url": "https://hackerone.com/jobert",
        "hackerone_triager": false,
        "hackerone_employee": true,
        "user_type": "company",
        "profile_picture_urls": {
          "small": "https://profile-photos.hackerone-user-content.com/variants/ht4b9SmcYNqmpbyCFXd7cxHB/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
          "medium": "https://profile-photos.hackerone-user-content.com/variants/ht4b9SmcYNqmpbyCFXd7cxHB/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937",
          "xtralarge": "https://profile-photos.hackerone-user-content.com/variants/ht4b9SmcYNqmpbyCFXd7cxHB/60f411638706d89ae3052af6fe8b88fa9a798e291deee40f6a22e81418d78d5f"
        }
      },
      "can_view?": true,
      "can_create?": false,
      "attachments": []
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
