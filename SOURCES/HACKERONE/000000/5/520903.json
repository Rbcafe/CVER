{
  "id": 520903,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81MjA5MDM=",
  "url": "https://hackerone.com/reports/520903",
  "title": "Apache HTTP [2.4.17-2.4.38] Local Root Privilege Escalation",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "high",
  "readable_substate": "Resolved",
  "created_at": "2019-04-02T15:17:43.204Z",
  "submitted_at": "2019-04-02T15:17:43.204Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "real",
    "url": "/real",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 54349,
    "url": "https://hackerone.com/ibb",
    "handle": "ibb",
    "profile_picture_urls": {
      "small": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ5A3QBGAF%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T132034Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDOmRjyw5I%2FTlNnXkSaQt0HWBvcx4KUqlbsBDywYvgMjAIgc1T3omLkZfSHGnxG7u3M%2BDm3ZU5hXXACm6d42GSb7EAqsQUIdhADGgwwMTM2MTkyNzQ4NDkiDI1cp4QslnXVHIUCaCqOBecH%2BJNC0KwQ%2BfCYMGM86f%2FOS1Dm%2BIA%2BHjSlOORnFjZmELOvSSorEYFhUaPaxwQcFsTE7OMurOw%2BQnTNbwJzmGH%2FjDpGT%2FxwOi1Yf0v9t5xHdyje9QeqWvWnPlxRuLTKdeHLfuYjPaGYHjDPk%2ByYZLTVi%2F6fLFk1LMc7Dx726KzEvXPKCa4bME8qI31URj4F9nDQiBGwytvr7Hm1EMgKGmVAK6%2Fbzd%2BJiZVqxHd3sYJSTbmtS%2BAl2zqAc8BSfBosM0X88oi3lBTlSqMNhfG3CaAXBePpXwzrVOqz74NfDYXdsP4VQdYegntsv6fFEZFiKkjhlglh0X4pAXPbvFNkY8C7BzpUD2tNRzacCXSlRaco9RM5vUg086o63M3dgo9tb8DkSAwOHamrNu%2F2KO2aggnlYsi1aZ7EJQTnQ4h%2BcjkM2D28%2Bxcxlpa3Ec2gB5yd%2BQcUjU%2BzbbmFbStd4UJXYiE38Skp99somT%2BpCEikiE7WFVYA5Pgb9J6BqOzjaorE7DzLysbe4e0jMnv06eVq4H%2Bz42eH%2FkluYPtzip94lWrairjO%2BPy%2BVDKDVJai6d1iVpfcEFmbncPaNpU53sKrhSNhpvIUbUDu5YaFK6X%2FbL%2BeFksXVgGaf0JwUeSzAh%2FGbxLEuo6xDzuhAOmMHndLW%2FF8uphSoqM7NkjvQNWF4znkPMyfsDxu0sKfOHhED1nQ5geErhYuMeCPDWNlWvJKC2X93i%2B8i8WntV0NtA21WXhLXSnrHVz2HCPlDghBMIvH7mgPpfyFhSMGQDeGjpSbj3uInocAFuDTAgJeZIwRGGMYeOXoRMIVrM6FWdeiP%2FaI3a0LUECdOBOPVvRMLQuf7VJvF0078t1crT4PlcQMPTC%2Fwq2uBjqxAVnkBdxFUTWQ4ZupRlHVu9PZr1k7xqw4QHDS7pllKyJWE05aIrKtcQLI8f74A6IlC2qLL0KpjvsW622557lHAqxIiBIxR28dhgaLkoywMH6F6KWd%2BowMbbVNahcgFgF8sWKuHHJPaj4kiHcEz7czNhJgm88FkmgTRhhw7HW2Z01FS2x%2BrnGRx5%2BvOZPEvDu%2BIRvDNGu%2FVrwK5wtu%2BRwxD8V7oEVMXOuAFSFlduj5GO6kbQ%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=c59e4d1a35f49ce7353f159a7a36b0d7df9471be00892d4098b4c1ff93e1fb09",
      "medium": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/v0qywgoh5hm4cbhuanu8mqdtowhr/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937?response-content-disposition=inline%3B%20filename%3D%22ibb%20revision%205%20copy.png%22%3B%20filename%2A%3DUTF-8%27%27ibb%2520revision%25205%2520copy.png&response-content-type=image%2Fpng&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ5A3QBGAF%2F20240213%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240213T132034Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJ3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDOmRjyw5I%2FTlNnXkSaQt0HWBvcx4KUqlbsBDywYvgMjAIgc1T3omLkZfSHGnxG7u3M%2BDm3ZU5hXXACm6d42GSb7EAqsQUIdhADGgwwMTM2MTkyNzQ4NDkiDI1cp4QslnXVHIUCaCqOBecH%2BJNC0KwQ%2BfCYMGM86f%2FOS1Dm%2BIA%2BHjSlOORnFjZmELOvSSorEYFhUaPaxwQcFsTE7OMurOw%2BQnTNbwJzmGH%2FjDpGT%2FxwOi1Yf0v9t5xHdyje9QeqWvWnPlxRuLTKdeHLfuYjPaGYHjDPk%2ByYZLTVi%2F6fLFk1LMc7Dx726KzEvXPKCa4bME8qI31URj4F9nDQiBGwytvr7Hm1EMgKGmVAK6%2Fbzd%2BJiZVqxHd3sYJSTbmtS%2BAl2zqAc8BSfBosM0X88oi3lBTlSqMNhfG3CaAXBePpXwzrVOqz74NfDYXdsP4VQdYegntsv6fFEZFiKkjhlglh0X4pAXPbvFNkY8C7BzpUD2tNRzacCXSlRaco9RM5vUg086o63M3dgo9tb8DkSAwOHamrNu%2F2KO2aggnlYsi1aZ7EJQTnQ4h%2BcjkM2D28%2Bxcxlpa3Ec2gB5yd%2BQcUjU%2BzbbmFbStd4UJXYiE38Skp99somT%2BpCEikiE7WFVYA5Pgb9J6BqOzjaorE7DzLysbe4e0jMnv06eVq4H%2Bz42eH%2FkluYPtzip94lWrairjO%2BPy%2BVDKDVJai6d1iVpfcEFmbncPaNpU53sKrhSNhpvIUbUDu5YaFK6X%2FbL%2BeFksXVgGaf0JwUeSzAh%2FGbxLEuo6xDzuhAOmMHndLW%2FF8uphSoqM7NkjvQNWF4znkPMyfsDxu0sKfOHhED1nQ5geErhYuMeCPDWNlWvJKC2X93i%2B8i8WntV0NtA21WXhLXSnrHVz2HCPlDghBMIvH7mgPpfyFhSMGQDeGjpSbj3uInocAFuDTAgJeZIwRGGMYeOXoRMIVrM6FWdeiP%2FaI3a0LUECdOBOPVvRMLQuf7VJvF0078t1crT4PlcQMPTC%2Fwq2uBjqxAVnkBdxFUTWQ4ZupRlHVu9PZr1k7xqw4QHDS7pllKyJWE05aIrKtcQLI8f74A6IlC2qLL0KpjvsW622557lHAqxIiBIxR28dhgaLkoywMH6F6KWd%2BowMbbVNahcgFgF8sWKuHHJPaj4kiHcEz7czNhJgm88FkmgTRhhw7HW2Z01FS2x%2BrnGRx5%2BvOZPEvDu%2BIRvDNGu%2FVrwK5wtu%2BRwxD8V7oEVMXOuAFSFlduj5GO6kbQ%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=d93dc4312ddf7d1ae240dc7b924e1d0c24f49838cd984e6aef23c5434721e5cb"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Internet Bug Bounty",
      "twitter_handle": "",
      "website": "https://www.hackerone.com/internet-bug-bounty",
      "about": "The Internet Bug Bounty rewards security research into vulnerabilities impacting Open Source Software Projects."
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2019-0211",
    "CVE-2019-6977"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2019-09-11T09:46:31.808Z",
  "bug_reporter_agreed_on_going_public_at": "2019-09-11T09:46:31.730Z",
  "team_member_agreed_on_going_public_at": "2019-09-10T20:32:52.357Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Hello,\n\nI reported a Local Root privilege escalation vulnerability on Apache HTTPd at the beginning of the year. Apache has now patched it, [as you can see here](https://httpd.apache.org/security/vulnerabilities_24.html#CVE-2019-0211).\nThe vulnerability affects mod_prefork, mod_event, and mod_worker, the most used mods on Linux.\nBasically, this is an arbitrary function call as root triggered whenever the server gracefully restarts, which is generally once a day.\n\nHere is the article I plan to publish soon, as MarkDown (careful, wall of text):\n\n# Introduction\n\nFrom version 2.4.17 (Oct 9, 2015) to version 2.4.38 (Apr 1, 2019), Apache HTTP suffers from a local root privilege escalation vulnerability due to an out-of-bounds array access leading to an arbitrary function call.\nThe vulnerability is triggered when Apache gracefully restarts (`apache2ctl graceful`).\nIn standard Linux configurations, the `logrotate` utility runs this command once a day, at 6:25AM, in order to reset log file handles.\n\n*The vulnerability affects `mod_prefork`, `mod_worker` and `mod_event`. The following bug description, code walkthrough and exploit target `mod_prefork`.*\n\n# Bug description\n\nIn MPM prefork, the main server process, running as `root`, manages a pool of single-threaded, low-privilege (`www-data`) worker processes, meant to handle HTTP requests.\nIn order to get feedback from its workers, Apache maintains a shared-memory area (SHM), `scoreboard`, which contains various informations such as the workers PIDs and the last request they handled.\nEach worker is meant to maintain a `process_score` structure associated with its PID, and has full read/write access to the SHM.\n\n*ap_scoreboard_image: pointers to the shared memory block*\n```\n(gdb) p *ap_scoreboard_image \n$3 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p ap_scoreboard_image->servers[0]\n$5 = (worker_score *) 0x7f4a93240820\n```\n\n*Example of shared memory associated with worker PID 19447*\n```\n(gdb) p ap_scoreboard_image->parent[0]\n$6 = {\n  pid = 19447, \n  generation = 0, \n  quiescing = 0 '\\000', \n  not_accepting = 0 '\\000', \n  connections = 0, \n  write_completion = 0, \n  lingering_close = 0, \n  keep_alive = 0, \n  suspended = 0, \n  bucket = 0 <- index for all_buckets\n}\n(gdb) ptype *ap_scoreboard_image->parent\ntype = struct process_score {\n    pid_t pid;\n    ap_generation_t generation;\n    char quiescing;\n    char not_accepting;\n    apr_uint32_t connections;\n    apr_uint32_t write_completion;\n    apr_uint32_t lingering_close;\n    apr_uint32_t keep_alive;\n    apr_uint32_t suspended;\n    int bucket; <- index for all_buckets\n}\n```\n\nWhen Apache gracefully restarts, its main process kills old workers and replaces them by new ones.\nAt this point, every old worker's `bucket` value will be used by the main process to access an array of his, `all_buckets`.\n\n*all_buckets*\n```\n(gdb) p $index = ap_scoreboard_image->parent[0]->bucket\n(gdb) p all_buckets[$index]\n$7 = {\n  pod = 0x7f19db2c7408, \n  listeners = 0x7f19db35e9d0, \n  mutex = 0x7f19db2c7550\n}\n(gdb) ptype all_buckets[$index]\ntype = struct prefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; <--\n}\n(gdb) ptype apr_proc_mutex_t\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; <--\n    int curr_locked;\n    char *fname;\n    ...\n}\n(gdb) ptype apr_proc_mutex_unix_lock_methods_t\napr_proc_mutex_unix_lock_methods_t {\n    ...\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); <--\n    ...\n}\n```\n\nNo bound checks happen. Therefore, a rogue worker can change its `bucket` index and make it point to the shared memory, in order to control the `prefork_child_bucket` structure upon restart. Eventually, and before privileges are dropped, `mutex->meth->child_init()` is called.\nThis results in an **arbitrary function call as root**.\n\n# Vulnerable code\n\nWe'll go through `server/mpm/prefork/prefork.c` to find out where and how the bug happens.\n\n- A rogue worker changes its `bucket` index in shared memory to make it point to a structure of his, also in SHM.\n- At 06:25AM the next day, `logrotate` requests a graceful restart from Apache.\n- Upon this, the main Apache process will first kill workers, and then spawn new ones.\n- The killing is done by sending `SIGUSR1` to workers. They are expected to exit ASAP.\n- Then, `prefork_run()` ([L853](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L853)) is called to spawn new workers. Since `retained->mpm->was_graceful` is `true` ([L861](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L861)), workers are not restarted straight away.\n- Instead, we enter the main loop ([L933](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L933)) and monitor dead workers' PIDs. When an old worker dies, `ap_wait_or_timeout()` returns its PID ([L940](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L940)).\n- The index of the `process_score` structure associated with this PID is stored in `child_slot` ([L948](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L948)).\n- If the death of this worker was not fatal ([L969](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L969)), `make_child()` is called with `ap_get_scoreboard_process(child_slot)->bucket` as a third argument ([L985](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L985)). As previously said, `bucket`'s value has been changed by a rogue worker.\n- `make_child()` creates a new child, `fork()`ing ([L671](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L671)) the main process.\n- The OOB read happens ([L691](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L691)), and `my_bucket` is therefore under the control of an attacker.\n- `child_main()` is called ([L722](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L722)), and the function call happens a bit further ([L433](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L433)).\n- `SAFE_ACCEPT(<code>)` will only execute `<code>` if Apache listens *on two ports or more*, which is often the case since a server listens over HTTP (80) and HTTPS (443).\n- Assuming `<code>` is executed, `apr_proc_mutex_child_init()` is called, which results in a call to `(*mutex)->meth->child_init(mutex, pool, fname)` with mutex under control.\n- Privileges are dropped a bit later in the execution ([L446](https://github.com/apache/httpd/blob/23167945c17d5764820fdefdcab69295745a15a1/server/mpm/prefork/prefork.c#L446)).\n\n# Exploitation\n\nThe exploitation is a four step process:\n1. Obtain R/W access on a worker process\n2. Write a fake `prefork_child_bucket` structure in the SHM\n3. Make `all_buckets[bucket]` point to the structure\n4. Await 6:25AM to get an arbitrary function call\n\nAdvantages:\n- The main process never exits, so we know where everything is mapped by reading `/proc/self/maps` (ASLR/PIE useless)\n- When a worker dies (or segfaults), it is automatically restarted by the main process, so there is no risk of DOSing Apache\n\nProblems:\n- PHP does not allow to read/write `/proc/self/mem`, which blocks us from simply editing the SHM\n- `all_buckets` is reallocated after a graceful restart (!)\n\n## 1. Obtain R/W access on a worker process\n\n### PHP UAF 0-day\n\nSince `mod_prefork` is often used in combination with `mod_php`, it seems natural to exploit the vulnerability through PHP. [CVE-2019-6977]() would be a perfect candidate, but it was not out when I started writing the exploit. I went with a 0day UAF in PHP 7.x (which seems to work in PHP5.x as well):\n\n*PHP UAF*\n```php\n<?php\n\nclass X extends DateInterval implements JsonSerializable\n{\n  public function jsonSerialize()\n  {\n    global $y, $p;\n    unset($y[0]);\n    $p = $this->y;\n    return $this;\n  }\n}\n\nfunction get_aslr()\n{\n  global $p, $y;\n  $p = 0;\n\n  $y = [new X('PT1S')];\n  json_encode([1234 => &$y]);\n  print(\"ADDRESS: 0x\" . dechex($p) . \"\\n\");\n\n  return $p;\n}\n\nget_aslr();\n```\n\nThis is an UAF on a PHP object: we unset `$y[0]` (an instance of `X`), but it is still usable using `$this`.\n\n### UAF to Read/Write\n\nWe want to achieve two things:\n- Read memory to find `all_buckets`' address\n- Edit the SHM to change `bucket` index and add our custom mutex structure\n\nLuckily for us, PHP's heap is located before those two in memory.\n\n*Memory addresses of PHP's heap, `ap_scoreboard_image->*` and `all_buckets`*\n```\nroot@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p\n7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so\n\n(gdb) p *ap_scoreboard_image \n$14 = {\n  global = 0x7f4a9323e008, \n  parent = 0x7f4a9323e020, \n  servers = 0x55835eddea78\n}\n(gdb) p all_buckets \n$15 = (prefork_child_bucket *) 0x7f4a9336b3f0\n```\n\nSince we're triggering the UAF on a PHP object, any property of this object will be UAF'd too; we can convert this `zend_object` UAF into a `zend_string` one.\nThis is useful because of `zend_string`'s structure:\n\n```\n(gdb) ptype zend_string\ntype = struct _zend_string {\n    zend_refcounted_h gc;\n    zend_ulong h;\n    size_t len;\n    char val[1];\n}\n```\n\nThe `len` property contains the length of the string. By incrementing it, we can read and write further in memory, and therefore access the two memory regions we're interested in: the SHM and Apache's `all_buckets`.\n\n### Locating `bucket` indexes and `all_buckets`\n\nWe want to change `ap_scoreboard_image->parent[worker_id]->bucket` for a certain `worker_id`. Luckily, the structure always starts at the beginning of the shared memory block, so it is easy to locate.\n\n*Shared memory location and targeted process_score structures*\n```\nroot@apaubuntu:~# cat /proc/6318/maps | grep rw-s\n7f4a9323e000-7f4a93252000 rw-s 00000000 00:05 57052                      /dev/zero (deleted)\n\n(gdb) p &ap_scoreboard_image->parent[0]\n$18 = (process_score *) 0x7f4a9323e020\n(gdb) p &ap_scoreboard_image->parent[1]\n$19 = (process_score *) 0x7f4a9323e044\n```\n\nTo locate `all_buckets`, we can make use of our knowledge of the `prefork_child_bucket` structure. We have:\n\n*Important structures of bucket items*\n```\nprefork_child_bucket {\n    ap_pod_t *pod;\n    ap_listen_rec *listeners;\n    apr_proc_mutex_t *mutex; <--\n}\n\napr_proc_mutex_t {\n    apr_pool_t *pool;\n    const apr_proc_mutex_unix_lock_methods_t *meth; <--\n    int curr_locked;\n    char *fname;\n\n    ...\n}\n\napr_proc_mutex_unix_lock_methods_t {\n    unsigned int flags;\n    apr_status_t (*create)(apr_proc_mutex_t *, const char *);\n    apr_status_t (*acquire)(apr_proc_mutex_t *);\n    apr_status_t (*tryacquire)(apr_proc_mutex_t *);\n    apr_status_t (*release)(apr_proc_mutex_t *);\n    apr_status_t (*cleanup)(void *);\n    apr_status_t (*child_init)(apr_proc_mutex_t **, apr_pool_t *, const char *); <--\n    apr_status_t (*perms_set)(apr_proc_mutex_t *, apr_fileperms_t, apr_uid_t, apr_gid_t);\n    apr_lockmech_e mech;\n    const char *name;\n}\n```\n\n`all_buckets[0]->mutex` will be located in the same memory region as `all_buckets[0]`. Since `meth` is a static structure, it will be located in `libapr`'s `.data`. Since `meth` points to functions defined in `libapr`, each of the function pointers will be located in `libapr`'s `.text`.\n\nSince we have knowledge of those region's addresses through `/proc/self/maps`, we can go through every pointer in Apache's memory and find one that matches the structure. It will be `all_buckets[0]`.\n\nAs I mentioned, `all_buckets`'s address changes at every graceful restart. This means that when our exploit triggers, `all_buckets`'s address will be different than the one we found. This has to be taken into account; we'll talk about this later.\n\n## 2. Write a fake `prefork_child_bucket` structure in the SHM\n\n### Reaching the function call\n\nThe code path to the arbitrary function call is the following:\n\n```\nbucket_id = ap_scoreboard_image->parent[id]->bucket\nmy_bucket = all_buckets[bucket_id]\nmutex = &my_bucket->mutex\napr_proc_mutex_child_init(mutex)\n(*mutex)->meth->child_init(mutex, pool, fname)\n```\n\n![Call:reach](images/carpe-diem-cve-2019-0211-apache-local-root/1.png)\n\n### Calling something proper\n\nTo exploit, we make `(*mutex)->meth->child_init` point to `zend_object_std_dtor(zend_object *object)`, which yields the following chain:\n\n```\nmutex = &my_bucket->mutex\n[object = mutex]\nzend_object_std_dtor(object)\nht = object->properties\nzend_array_destroy(ht)\nzend_hash_destroy(ht)\nval = &ht->arData[0]->val\nht->pDestructor(val)\n```\n\n`pDestructor` is set to `system`, and `&ht->arData[0]->val` is a string.\n\n![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/2.png)\n\nAs you can see, both leftmost structures are superimposed.\n\n## 3. Make `all_buckets[bucket]` point to the structure\n\n### Problem and solution\n\nRight now, if `all_buckets`' address was unchanged in between restarts, our exploit would be over:\n\n- Get R/W over all memory after PHP's heap\n- Find `all_buckets` by matching its structure\n- Put our structure in the SHM\n- Change one of the `process_score.bucket` in the SHM so that `all_bucket[bucket]->mutex` points to our payload\n\nAs `all_buckets`' address changes, we can do two things to improve reliability: spray the SHM and use every `process_score` structure - one for each PID.\n\n### Spraying the shared memory\n\nIf `all_buckets`' new address is not far from the old one, `my_bucket` will point close to our structure. Therefore, instead of having our `prefork_child_bucket` structure at a precise point in the SHM, we can spray it all over unused parts of the SHM. The problem is that the\nstructure is also used as a `zend_object`, and therefore it has a size of (5 * 8 =) 40 bytes to include `zend_object.properties`.\nSpraying a structure that big over a space this small won't help us much.\nTo solve this problem, we superimpose the two center structures, `apr_proc_mutex_t` and `zend_array`, and spray their address in the rest of the shared memory.\nThe impact will be that `prefork_child_bucket.mutex` and `zend_object.properties` point to the same address.\nNow, if `all_bucket` is relocated not too far from its original address, `my_bucket` will be in the sprayed area.\n\n![Call:exec](images/carpe-diem-cve-2019-0211-apache-local-root/3.png)\n\n### Using every `process_score`\n\nEach Apache worker has an associated `process_score` structure, and with it a `bucket` index.\nInstead of changing one `process_score.bucket` value, we can change every one of them, so that they cover another part of memory. For instance:\n\n```\nap_scoreboard_image->parent[0]->bucket = -10000 -> 0x7faabbcc00 <= all_buckets <= 0x7faabbdd00\nap_scoreboard_image->parent[1]->bucket = -20000 -> 0x7faabbdd00 <= all_buckets <= 0x7faabbff00\nap_scoreboard_image->parent[2]->bucket = -30000 -> 0x7faabbff00 <= all_buckets <= 0x7faabc0000\n```\n\nThis multiplies our success rate by the number of apache workers. Upon respawn, only one worker have a valid `bucket` number, but this is not a problem because the others will crash, and immediately respawn.\n\n### Success rate\n\nDifferent Apache servers have different number of workers. Having more workers mean we can spray the address of our mutex over less memory, but it also means we can specify more `index` for `all_buckets`. This means that having more workers improves our success rate. After a few tries on my test Apache server of 4 workers (default), I had **~80% success rate**.\n\nAgain, if the exploit fails, it can be restarted the next day as Apache will still restart properly. Apache's `error.log` will nevertheless contain notifications about its workers segfaulting.\n\n## 4. Await 6:25AM for the exploit to trigger\n\nWell, that's the easy step.\n\n# Vulnerability timeline\n\n- 2019-02-22 Initial contact email to `security[at]apache[dot]org`, with description and POC\n- 2019-02-25 Acknowledgment of the vulnerability, working on a fix\n- 2019-03-07 Apache's security team sends a patch for I to review, CVE assigned\n- 2019-03-10 I approve the patch\n- 2019-04-01 Apache HTTP version 2.4.39 released\n\nApache's team has been prompt to respond and patch, and nice as hell. Really good experience. PHP never answered regarding the UAF.\n\n# Exploit\n\nI'm not releasing it just yet !\n\n## Impact\n\nYou generally obtain root privileges from www-data privileges.",
  "bounty_amount": "1500.0",
  "formatted_bounty": "$1,500",
  "weakness": {
    "id": 75,
    "name": "Privilege Escalation"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2019-10-10T20:32:52.463Z",
  "allow_singular_disclosure_after": -137090861.7267313,
  "singular_disclosure_allowed": true,
  "vote_count": 119,
  "voters": [
    "rioru",
    "real",
    "hacktus",
    "m0chan",
    "un4gi",
    "bsysop",
    "sameerphad72",
    "bl4de",
    "ali",
    "leonishan",
    "and 109 more..."
  ],
  "severity": {
    "rating": "high",
    "score": 7.8,
    "author_type": "User",
    "metrics": {
      "attack_vector": "local",
      "attack_complexity": "low",
      "privileges_required": "low",
      "user_interaction": "none",
      "scope": "unchanged",
      "confidentiality": "high",
      "integrity": "high",
      "availability": "high"
    }
  },
  "structured_scope": {
    "databaseId": 84129,
    "asset_type": "OTHER",
    "asset_identifier": "Apache (Legacy)",
    "max_severity": "none"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
