{
  "id": 591302,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81OTEzMDI=",
  "url": "https://hackerone.com/reports/591302",
  "title": "Denial of service to WP-JSON API by cache poisoning the CORS allow origin header",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "medium",
  "readable_substate": "Resolved",
  "created_at": "2019-05-28T08:24:13.932Z",
  "submitted_at": "2019-05-28T08:24:13.932Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "nathand",
    "url": "/nathand",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/NY2oTeWofAnqK1X5MRNFCDXy/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 111,
    "url": "https://hackerone.com/automattic",
    "handle": "automattic",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Automattic",
      "twitter_handle": "",
      "website": "https://automattic.com",
      "about": "WordPress.com, Jetpack, Texts, Akismet, Gravatar, WooCommerce, Crowdsignal, Tumblr and more!"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2020-04-16T11:47:55.468Z",
  "bug_reporter_agreed_on_going_public_at": "2020-03-26T06:09:20.243Z",
  "team_member_agreed_on_going_public_at": "2020-04-16T11:47:55.369Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "The WP-JSON implementation on some wordpress.com websites I've tested is vulnerable to denial of service where by an attacker can provide an arbitrary `Origin` header in the request, which is then echoed back in the response via the `Access-Control-Allow-Origin` header, which is cached and served to other requests.\n\nThis response header is used by browsers to determine whether the requesting origin (if it is a cross origin request) is allowed to read the response in the request. In the event the victim website had another origin that used the WP-JSON API to request data from their wordpress.com site (e.g. a sub domain), this cache poisoning would deny access to such requests due to failed a CORS access control check. It appears that this vulnerability is only a concern if the WP-JSON API responses are cached, which you can determine by the presence of a `X-Cache: hit` header in the response.\n\n## Proof of concept\n\nFor this test, I'm going to target `█████████.com`, a wordpress.com site. I will be doing this with a cache busting technique that doesn't really poison the live site's cache (by supplying a bespoke query string value) so this should be safe to repeat verbatim.\n\n  1. First, open a HTTPS website - it doesn't matter which website, as long as it isn't `https://█████████.com` (to trigger browser CORS). For my test, I used my own website https://nathandavison.com.\n  1. Open the javascript console and execute the following 5-10 times (to make sure the cache is poisoned across backends): `fetch('https://██████████.com/wp-json/?dontreallypoison1').then(res => res.json()).then(json => console.log(json))`\n  1. Now, open another HTTPS website - it also doesn't matter which site it is, as long as it too isn't `https://███████.com`. Execute the same fetch as above.\n  1. You should now experience a CORS error in your browser, such as: `Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://█████████.com/wp-json/?dontreallypoison1. (Reason: CORS header ‘Access-Control-Allow-Origin’ does not match ‘https://nathandavison.com’).`\n\nWhat's going on here? because the WP-JSON response is CORS aware, it is responding with a `Access-Control-Allow-Origin` header value. Presumably to offer wide support for CORS, the `Origin` value in the request is being echoed back. So far, I believe this is standard Wordpress WP-JSON behavior. However, automattic/wordpress.com is caching this response and is not keying the cache based on the request `Origin` value (which is `https://nathandavison.com` in step 1 above), so therefore is serving the poisoned response in step 4, and because the other origin is not `https://nathandavison.com`, CORS in the browser blocks the response coming back into the DOM.\n\nI believe any wordpress.com website that caches WP-JSON responses is vulnerable to this. A quick way, as an attacker, to find potential victims would be a query like this:\n\nhttps://publicwww.com/websites/%22If%20you're%20reading%20this,%20you%20should%20visit%20automattic.com%22/\n\n## Attach scenario\n\nTo attack this, a victim site would have to:\n\n  1. Use WP-JSON is a meaningful way in a browser context (or any other context that respects CORS headers)\n  1. Use it from an origin that triggers CORS. For example, if the WP-JSON API is used on \"foo.████.com\" to request the blog posts from \"█████.com\". Another example may be a \"headless\" Wordpress site (e.g. api.x.com is Wordpress and x.com is the frontend, which uses the WP-JSON plugin to interact with the WP backend).\n\nOnce a target is found that satisfies these conditions, an attacker would then simply poison the CORS response with regular requests to specific endpoints. This poisoning would result (in the example above) in visitors to \"foo.██████.com\" failing to load the WP-JSON API requests to \"██████████.com\" due to CORS failures, causing a DoS for whatever service relies on this functionality.\n\n## Fix\n\nI believe to fix this, automattic should make sure that edge caches for WP-JSON requests are using the `Origin` header in the request to key the cache, so one value can't affect the cache served to another value. Preventing the echoing back of the `Origin` into the `Access-Control-Allow-Origin` response header without first passing through a configurable whitelist would also be a potential solution, but this may be harder to implement. \n\n## More information\n\nPlease see the following blog post for more information on this:\n\nhttps://nathandavison.com/blog/corsing-a-denial-of-service-via-cache-poisoning\n\nI wrote this post in response to disclosing a very similar vulnerability to another Wordpress SaaS provider.\n\n## Impact\n\nThe impact of this vulnerability depends on how and where a client uses the WP-JSON plugin. If a wordpress.com customer uses WP-JSON in a context that relies on CORS, this technique could deny service to the WP-JSON endpoints in use.",
  "weakness": {
    "id": 48,
    "name": "Denial of Service"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2020-04-25T06:09:20.344Z",
  "allow_singular_disclosure_after": -120035633.97824763,
  "singular_disclosure_allowed": true,
  "vote_count": 388,
  "voters": [
    "smokes-0044",
    "mr-medi",
    "6r0w5e",
    "a_d_a_m",
    "nagli",
    "battle_angel",
    "wh0ru",
    "mashoud1122",
    "holyfield",
    "matanber",
    "and 378 more..."
  ],
  "severity": {
    "rating": "medium",
    "author_type": "User"
  },
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
