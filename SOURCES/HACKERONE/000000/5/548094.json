{
  "id": 548094,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81NDgwOTQ=",
  "url": "https://hackerone.com/reports/548094",
  "title": "Internal Hostname disclosure from multiple Apache servers via blank host header method",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "low",
  "readable_substate": "Resolved",
  "created_at": "2019-04-24T23:05:45.505Z",
  "submitted_at": "2019-04-24T23:05:45.505Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "jackb898",
    "url": "/jackb898",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/CBcmZYZbwyyEjGj5BP7AQ4FK/ede8cd84a64d5392a2bb88ecb598721116469c27c015c2caa77148f11e211d58"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 25188,
    "url": "https://hackerone.com/pingidentity",
    "handle": "pingidentity",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/025/188/95e54845d1cd7b8af42716695136b86fd11d0cf1_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/025/188/95e54845d1cd7b8af42716695136b86fd11d0cf1_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Ping Identity",
      "twitter_handle": "pingidentity",
      "website": "https://www.pingidentity.com/",
      "about": ""
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "no-content",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2020-03-12T22:25:58.127Z",
  "bug_reporter_agreed_on_going_public_at": "2020-03-03T01:44:05.821Z",
  "team_member_agreed_on_going_public_at": "2020-03-12T22:25:57.931Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "",
  "bounty_amount": "150.0",
  "formatted_bounty": "$150",
  "weakness": {
    "id": 18,
    "name": "Information Disclosure"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 20,
  "voters": [
    "sebd",
    "thaivu",
    "base_64",
    "mik317",
    "sodium_",
    "brodie_codie",
    "map1e",
    "zimmer75",
    "cryptographer",
    "0xm1racle",
    "and 10 more..."
  ],
  "severity": {
    "rating": "low",
    "author_type": "Team"
  },
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "id": 20699,
      "category": "team",
      "content": "This vulnerability was due to a general misconfiguration of Apache servers; this is a good example of the importance of \"Secure Defaults\" in open-source projects. An example of a generic request and response would be:\n\nopenssl s_client -connect apache.example.com:443\nGET apache.example.com/foo HTTP/1.0\nHost:\nConnection: keep-alive\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3\nAccept-Encoding: gzip, deflate, br\nAccept-Language: en-US,en;q=0.9\n\nHTTP/1.1 400 Bad Request\nDate: Thu, 3 Feb 2020 13:14:15 GMT\nServer: Apache\nContent-Length: 335\nContent-Type: text/html; charset=iso-8859-1\nStrict-Transport-Security: max-age=15768000; preload;\nX-Content-Type-Options: nosniff\nConnection: keep-alive\n\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>400 Bad Request</title>\n</head><body>\n<h1>Bad Request</h1>\n<p>Your browser sent a request that this server could not understand.<br />\n</p>\n<hr>\n<address>Apache Server at aws-ec2.example.internal Port 443</address>\n</body></html>\nclosed\n\nAs reported by the researcher:\n\nSummary:\nI found 3 subdomains vulnerable to a method that essentially \"tricks\" websites into leaking their own internal hostname. \n\nVulnerability Description\nThis is the \"very detailed\" explanation, if you just want to test/reproduce it, just scroll past this to \"Steps to Reproduce\"\n\nNow I'll explain the issue that leaks these internal hostnames. Essentially, it has to do with website behavior towards empty host headers. So the original method comprises of setting up a GET request to the website, just the main directory. Next, you test it for typical host header injection by changing the Host header to anything like foo.com. Send this request, and if the response contains foo.com anywhere, it may be vulnerable to blank host header info. leakage. However when I was testing your site, I noticed it simply gave a 302 and tried to redirect back to the correct host. I found a way to bypass this though; setting up the request to a nonexistent directory, and including the CR character, like this: /foo%0A, makes it give a 404 and return the host header at the bottom of the page.\n\nNow that we have host header injection, here's where you use that to leak the internal information. Firstly, change the protocol from HTTP/1.1 to HTTP/1.0 (this is to allow blank host headers). Next, remove the host header and send the request. Look in the same spot that the host header was displayed previously, and the internal hostname/ip will be displayed there.\n\nSuggested Remediation\nTo prevent this, you need to prevent host header injection, or at least prevent the host header from being returned anywhere in the response.\n\nThe best way to do this is using something like Cloudfront protection, which prevents host header injection.\n\nImpact\nIt is a bad idea to leak internal hostnames, as they can be used by attackers to exploit the network or server. They can chain issues to launch specific attacks against the internal infrastructure; in other words, leaking internal IPs or hostnames leads to normally non-issues becoming vulnerabilities.",
      "user": {
        "id": 693290,
        "username": "volcanic82",
        "name": "volcanic82",
        "bio": "",
        "cleared": false,
        "verified": false,
        "website": null,
        "location": "",
        "created_at": "2019-07-30T21:11:25.957Z",
        "url": "https://hackerone.com/volcanic82",
        "hackerone_triager": false,
        "hackerone_employee": false,
        "user_type": "hacker",
        "profile_picture_urls": {
          "small": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png",
          "medium": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png",
          "xtralarge": "/assets/avatars/default-25f7248a18bdf9e2dc8310319b148d66cff430fa0fade6c5f25fee1b8d7f27ed.png"
        }
      },
      "can_view?": true,
      "can_create?": false,
      "attachments": []
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
