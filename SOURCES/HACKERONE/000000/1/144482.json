{
  "id": 144482,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xNDQ0ODI=",
  "url": "https://hackerone.com/reports/144482",
  "title": "StringIO strio_getline() can divulge arbitrary memory",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2016-06-13T14:39:10.077Z",
  "submitted_at": "2016-06-13T14:39:10.077Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "guido",
    "url": "/guido",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 7724,
    "url": "https://hackerone.com/ruby",
    "handle": "ruby",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Ruby",
      "twitter_handle": "",
      "website": "https://www.ruby-lang.org",
      "about": "A Programmer's Best Friend"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2016-06-21T00:56:33.515Z",
  "bug_reporter_agreed_on_going_public_at": "2016-06-17T23:49:48.746Z",
  "team_member_agreed_on_going_public_at": "2016-06-21T00:56:27.877Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "(originally send by e-mail on 4 Jun 2016)\n\nThe problem is this line in ext/stringio/stringio.c strio_getline():\n\n```c\n1002     if (limit > 0 && s + limit < e) {\n1003     e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n1004     }\n```\n\nThis works as intended as long as the sum of s (pointer) and limit\n(long) doesn't overflow. So if on a 32 bit system 's' happens to be\n0xBF000000, and limit is 0x7FFFFFFF, the sum of both values is\n0x3EFFFFFF, which is a completely unrelated address. From there, there\nare several paths to be chosen from based on what the first parameter to\nthe function is ('str').\n\n```c\n  1005\t    if (NIL_P(str)) {\n            ...\n            ...\n  1008\t    else if ((n = RSTRING_LEN(str)) == 0) {\n            ...\n            ...\n  1024\t    else if (n == 1) {\n            ...\n            ...\n  1030\t    else {\n            ...\n            ...\n```\n\nAll these paths eventually call strio_substr(). A wrong 'pos' parameter\nto this function is not possible because it was checked earlier:\n\n```c\n   996\t    if (ptr->pos >= (n = RSTRING_LEN(ptr->string))) {\n   997\t\treturn Qnil;\n   998\t    }\n```\n\na wrong 'len' parameter to this function doesn't matter as it will\ncorrect it itself:\n\n```c\n    98\tstatic VALUE\n    99\tstrio_substr(struct StringIO *ptr, long pos, long len)\n   100\t{\n   101\t    VALUE str = ptr->string;\n   102\t    rb_encoding *enc = get_enc(ptr);\n   103\t    long rlen = RSTRING_LEN(str) - pos;\n   104\t\n   105\t    if (len > rlen) len = rlen;\n   106\t    if (len < 0) len = 0;\n   107\t    if (len == 0) return rb_str_new(0,0);\n   108\t    return rb_enc_str_new(RSTRING_PTR(str)+pos, len, enc);\n   109\t}\n```\n\nAs for the first path ('str' is nil, line 1005), it will call\nstrio_substr() with an invalid 'len' value, which doesn't matter because\nstrio_substr() corrects it:\n\n```c\n  1005\t    if (NIL_P(str)) {\n  1006\t\tstr = strio_substr(ptr, ptr->pos, e - s);\n  1007\t    }\n```\n\nWithin the second path ('str' is an empty string, line 1008), there is\nthe risk of an OOB read here, because this routine's logic is based on\nthe belief that 'e' denotes the end of the buffer. 'p' will never become\n'e' because either 1) a null pointer dereference will occur (once it\nreads at address 0x00000000) or 2) no \\n character is found before 'p'\nreaches an invalid memory page. In theory an attacker could use this\nmishap to find the \\n character at various places in memory (by\nadjusting the 'limit' variable), but that is usually not very useful.\n(The way an attacker can know at which the \\n character is found will\nbecome clear later).\n\n```c\n  1009\t\tp = s;\n  1010\t\twhile (*p == '\\n') {\n  1011\t\t    if (++p == e) {\n  1012\t\t\treturn Qnil;\n  1013\t\t    }\n  1014\t\t}\n  1015\t\ts = p;\n  1016\t\twhile ((p = memchr(p, '\\n', e - p)) && (p != e)) {\n  1017\t\t    if (*++p == '\\n') {\n  1018\t\t\te = p + 1;\n  1019\t\t\tbreak;\n  1020\t\t    }\n  1021\t\t}\n  1022\t\tstr = strio_substr(ptr, s - RSTRING_PTR(ptr->string), e - s);\n```\n\nThe third path ('str' is 1 character large, line 1024) is similar to the\nsecond path except that memchr is used to find the desired character:\n\n```c\n  1025\t\tif ((p = memchr(s, RSTRING_PTR(str)[0], e - s)) != 0) {\n  1026\t\t    e = p + 1;\n  1027\t\t}\n  1028\t\tstr = strio_substr(ptr, ptr->pos, e - s);\n```\n\nThe fourth path is entered if 'str' is 2 or more bytes large (line\n1030). The first condition is always true if a very high 'limit' value\nis chosen (the premise of this vulnerability):\n\n```c\n  1031\t\tif (n < e - s) {\n```\n\nThe first subpath is never true in this case:\n\n```c\n  1032\t\t    if (e - s < 1024) {\n```\n\nSo the second subpath is entered. This can be used to find the arbitrary\nstring 'str' across the totality of virtual memory:\n\n```c\n  1040\t\t    else {\n  1041\t\t\tlong skip[1 << CHAR_BIT], pos;\n  1042\t\t\tp = RSTRING_PTR(str);\n  1043\t\t\tbm_init_skip(skip, p, n);\n  1044\t\t\tif ((pos = bm_search(p, n, s, e - s, skip)) >= 0) {\n  1045\t\t\t    e = s + pos + n;\n  1046\t\t\t}\n  1047\t\t    }\n```\n\nAfter any of these paths have been traversed, the attacker can read the\n'pos' attribute to get the relative location of the string that has been\nfound somewhere in memory:\n\n```c\n  1051\t    ptr->pos = e - RSTRING_PTR(ptr->string);\n```\n\nBy subtracting this current 'pos' from the previous 'pos' the attacker\ncan know the position of string that was searched for relative to the\nbase string.\n\nMy hypothesis is that, if we assume that the attacker can control the\n'limit' variable as well as the string that has to be searched for and\nthey can invoke strio_getline an arbitrary number of times, they can\nmake Ruby divulge arbitrary information such as private keys (if they\nare loaded in memory), by searching for 'BEGIN PGP PRIVATE KEY BLOCK'\nand adjust the 'limit' parameter in combination with all alphanumeric\ncharacters to deduce the entire base64-encoded private key.\n\nNote that a pointer address can naturally be very high (on 32 bit\nanyway), such as 0xFFFF0000. In that event, a 'limit' of 0x10000 can be\nenough to overflow this computation:\n\n```c\n1002     if (limit > 0 && s + limit < e) {\n```\n\nHere is code that can be used to trigger the vulnerability.\n\n```ruby\nrequire \"stringio\"\ns = StringIO.new\ns.puts(\"abc\")\ns.rewind()\nx = s.gets('xxx', 0x7FFFFFFFFFFFFFF0)\nputs(s.pos)\n```\n\nThe vulnerability is more likely to trigger on 32 bit than on 64 bit,\nsince on 32 bit, the chance that the base string is allocated beyond the\nhalf of the virtual address space (0x80000000 or above, like 0xBF000000\nin my initial example) than on 64 bit (where it needs to be allocated at\n0x8000000000000000 or above). I did all of my testing on 32 bit.\n\nPlease let me know if you request a CVE, or if you need more information\nfrom me.\n\nGuido",
  "weakness": {
    "id": 2,
    "name": "Memory Corruption - Generic"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2016-07-17T23:49:48.859Z",
  "allow_singular_disclosure_after": -239027031.40394276,
  "singular_disclosure_allowed": true,
  "vote_count": 13,
  "voters": [
    "lukasreschke",
    "mdv",
    "guido",
    "zawad",
    "temmyscript",
    "kaito",
    "mogyhacker",
    "martijn",
    "zeroknife",
    "dyabla",
    "and 3 more..."
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
