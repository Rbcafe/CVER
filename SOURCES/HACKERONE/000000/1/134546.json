{
  "id": 134546,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMzQ1NDY=",
  "url": "https://hackerone.com/reports/134546",
  "title": "WordPress Flash XSS in *flashmediaelement.swf*",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2016-04-26T06:34:20.780Z",
  "submitted_at": "2016-04-26T06:34:20.780Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "cure53",
    "url": "/cure53",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/072/123/1c801729a8988a0b6873c3d9ccf131e2a1488011_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 111,
    "url": "https://hackerone.com/automattic",
    "handle": "automattic",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Automattic",
      "twitter_handle": "",
      "website": "https://automattic.com",
      "about": "WordPress.com, Jetpack, Texts, Akismet, Gravatar, WooCommerce, Crowdsignal, Tumblr and more!"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2016-07-10T12:51:12.764Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2016-06-10T12:51:04.174Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Intro\n==\n\nWordPress is vulnerable against a reflected XSS that stems from an insecure URL sanitization problem performed in the file *flashmediaelement.swf*. The code in the file attempts to remove *flashVars* [¹](https://helpx.adobe.com/flash/kb/pass-variables-swfs-flashvars.html) in case they have been set GET parameters but fails to do so, enabling XSS via *ExternalInterface* [²](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html).\n\nThe attack technique was first described by Soroush Dalili in 2013 [³](https://soroush.secproject.com/blog/2013/10/catch-up-on-flash-xss-exploitation-bypassing-the-guardians-part-1/). The vulnerability in *flashmediaelement.swf* was discovered in April 2016, first identified as SOME[⁴](http://www.benhayak.com/2015/06/same-origin-method-execution-some.html) bug by Kinugawa. Then, after a team review, the XSS potential was discovered and analyzed by Heiderich, Kinugawa and Inführ. Finally, it was discovered, that this file comes packaged with latest WordPress and the issue was reported here by Heiderich et al. \n\n**PoC:**\nhttps://example.com/wp-includes/js/mediaelement/flashmediaelement.swf?%#jsinitfunctio%gn=alert`1`\n\nBackground\n==\n\nIn the browser-world, a Flash file can be fed with parameters in multiple ways.\n\n**Way One:** *flashVars*\n\n```html\n<embed src=\"myFlashMovie.swf\"\n    quality=\"high\"\n    bgcolor=\"#ffffff\"\n    width=\"550\"\n    height=\"400\"\n    name=\"myFlashMovie\"     \n    FlashVars=\"myVariable=Hello%20World&mySecondVariable=Goodbye\"\n    align=\"middle\"\n    allowScriptAccess=\"sameDomain\"\n    allowFullScreen=\"false\"\n    type=\"application/x-shockwave-flash\"\n    pluginspage=\"http://www.adobe.com/go/getflash\"\n/>\n```\n\n**Way Two:** GET parameters\n\n```\nmyFlashMovie.swf?myVariable=Hello%20World&mySecondVariable=Goodbye\n```\n\nQuite obviously, *flashVars* via GET give an attacker more leverage, especially in case the Flash file can be opened directly in the browser. No need to embed it, just attach the *flashVars* via GET and the fun begins. \n\nNot unlike many other Flash files, *flashmediaelement.swf* attempts to protect itself from *flashVars* being set via GET.\n\nAttackers often abuse *flashVars* to exploit Flash XSS bugs originating from insecure handling of `navigateToURL`[⁵](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/package.html), `ExternalInterface.call`[⁶](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html#call%28%29) and other risky methods. So, why not get rid of GET parameters in the first place:\n\n```actionscript\n// get parameters\n// Use only FlashVars, ignore QueryString\nvar params:Object, pos:int, query:Object;\n\nparams = LoaderInfo(this.root.loaderInfo).parameters;\npos = root.loaderInfo.url.indexOf('?');\nif (pos !== -1) {\n\tquery = parseStr(root.loaderInfo.url.substr(pos + 1));\n\n\tfor (var key:String in params) {\n\t\tif (query.hasOwnProperty(trim(key))) {\n\t\t\tdelete params[key];\n\t\t}\n\t}\n}\n\n[...]\n\nprivate static function parseStr (str:String) : Object {\n\tvar hash:Object = {},\n\t\tarr1:Array, arr2:Array;\n\n\tstr = unescape(str).replace(/\\+/g, \" \");\n\n\tarr1 = str.split('&');\n\tif (!arr1.length) {\n\t\treturn {};\n\t}\n\n\tfor (var i:uint = 0, length:uint = arr1.length; i < length; i++) {\n\t\tarr2 = arr1[i].split('=');\n\t\tif (!arr2.length) {\n\t\t\tcontinue;\n\t\t}\n\t\thash[trim(arr2[0])] = trim(arr2[1]);\n\t}\n\treturn hash;\n}\n```\n\nFrom: https://github.com/johndyer/mediaelement/blob/master/src/flash/FlashMediaElement.as\n\nThe code shown above parses the URL query string and checks, if the GET parameter names spotted in there are also present among the flashVars (or vice versa). If a parameter name appears in both URL and the *flashVars* array, then the parameter must have been set via GET. If not, all is fine - and the parameter must have been set via *flashVars*. \n\nLet's call this code \"The GET Killer\"!\n\nThis way of \"scrubbing\" *flashVars* and making sure that no GET parameters can be used is fairly common and assumed to work well. But it can be bypassed using a dirty trick: invalid characters in the name of the GET parameters. Let's have a quick look at our PoC again:  \n\n**PoC:**\nhttps://example.com/wp-includes/js/mediaelement/flashmediaelement.swf?%#jsinitfunctio%gn=alert`1`\n\nNotice something? We obfuscate the name of our GET parameter a bit.\n\n```\njsinitfunctio%gn < see the %g?\n```\n\nThe Flash player is very tolerant when handling input via GET. Invalid URL escapes for example will simply be stripped! This means, that despite us calling the GET parameter `jsinitfunctio%gn`, the parameter that really arrived in the Flash file is again called `jsinitfunction` because the invalid parts are stripped.\n\nThat of course messes up the \"The GET Killer\". Because now, the label it checks for based on the parsed URL string contains the `%g` but the actual flashVar does not! No match, no scrub. We can submit data by using GET again. \n\nJust like this: `({'jsinitfunctio%gn':''}).hasOwnProperty('jsinitfunction') // false`\n\nBut that's not all. The file *flashmediaelement.swf* ships more defensive mechanisms. One of them if for example a black-list that checks, that the parameter values paired with risky methods don't contain characters like parenthesis. Because that would indicate, that someone tries to smuggle in some executable code, like an `alert(1)` instead of just providing a callback, like `alert`.\n\n```actionscript\nprivate function isIllegalChar(s:String, isUrl:Boolean):Boolean {\n\tvar illegals:String = \"' \\\" ( ) { } * + \\\\ < >\";\n\tif (isUrl) {\n\t\tillegals = \"\\\" { } \\\\ < >\";\n\t}\n\tif (Boolean(s)) { // Otherwise exception if parameter null.\n\t\tfor each (var illegal:String in illegals.split(' ')) {\n\t\t\tif (s.indexOf(illegal) >= 0) {\n\t\t\t\treturn true; // Illegal char found\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n\nFrom: https://github.com/johndyer/mediaelement/blob/master/src/flash/FlashMediaElement.as\n\nAs you can see, the method shown above checks the input for malicious characters that indicate executable JavaScript. Parenthesis, curlies, operators and all the nasty characters. From the ECMAScript 5 world. \n\nWhat is missing? The new ways of executing code offered by ECMAScript 6 by using back-ticks[⁷](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/template_strings). Let's have a look at the PoC again:\n\n**PoC:**\nhttps://example.com/wp-includes/js/mediaelement/flashmediaelement.swf?%#jsinitfunctio%gn=alert`1`\n\nNotice something? We don't use parenthesis to execute the alert. We use back-ticks instead. And they are not blacklisted of course.\n\nBut we are still not finished, there is yet another security mechanism installed by *flashmediaelement.swf* to make the attacker's life harder. And this is a check for the `ExternalInterface.objectID`[⁸](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html#objectID). This particular member is only present, in case the embedding HTML element (`<embed>` or `<object>`) is applied with an \"ID\" attribute. Here is the important bit of code:\n\n\n```actionscript\nif (_output != null) {\n\t_output.appendText(txt + \"\\n\");\n\tif (ExternalInterface.objectID != null && ExternalInterface.objectID.toString() != \"\") {\n\t\tvar pattern:RegExp = /'/g; //'\n\t\tExternalInterface.call(\"setTimeout\", _jsCallbackFunction + \"('\" + ExternalInterface.objectID + \"','message','\" + txt.replace(pattern, \"’\") + \"')\", 0);\n\t}\n} \n```\n\nFrom: https://github.com/johndyer/mediaelement/blob/master/src/flash/FlashMediaElement.as\n\nSo, again. If the Flash file wasn't properly embedded but opened directly, the whole thing will not work.\n\nNow, let's have a look how browsers actually embed Flash files when they are supposed to open them \"directly\" (by requesting the Flash/SWF file from the affected server). Because browers generate quite a bit of markup when opening an SWF directly.\n\n**Firefox does this:**\n```html\n<html><head><meta name=\"viewport\" content=\"width=device-width; height=device-height;\"></head><body marginwidth=\"0\" marginheight=\"0\"><embed height=\"100%\" width=\"100%\" name=\"plugin\" src=\"test.swf\" type=\"application/x-shockwave-flash\"></body></html>\n```\n\n**MSIE does this:**\n```html\n\"<html><head><style>@-ms-viewport {width:device-width;}html, body {margin:0;padding:0;width:100%;height:100%;overflow:hidden;}</style></head><body><embed width=\"100%\" height=\"100%\" src=\"test.swf\" type=\"application/x-shockwave-flash\" fullscreen=\"yes\"></body></html>\"\n```\n\n**Chrome however dies this:**\n```html\n<html><body style=\"background-color: rgb(38,38,38); height: 100%; width: 100%; overflow: hidden; margin: 0\"><embed width=\"100%\" height=\"100%\" name=\"plugin\" id=\"plugin\" src=\"test.swf\" type=\"application/x-shockwave-flash\"></body></html>\n```\n\nThe embed code generated by MSIE and Firefox contains no `id` attribute. But Chrome's does! That means, that without any actual effort from the attacker, Chrome automatically \"bypasses\" the third layer of protection.\n\nAnd that makes the attack work. Let's reiterate:\n\n1. We bypass \"The GET Killer\" using invalid URL escapes\n1. We bypass the blacklist using ES6 backticks\n1. Chrome \"bypasses\" the check for the `ExternalInterface.objectID`\n\nAnd that is it. \n\nWell, not exactly. Maybe also have a look at the other SWF files WordPress ships. They are buggy too. But it's not as bad a s this issue. So we will talk about these later. \n\nAffected Systems\n==\n\nAll WordPress instances that allow to directly call this file. That should be the absolute majority. Google finds a couple of 100k of them but we assume it is actually significantly more[⁹](https://www.google.com/search?q=inurl:/wp-includes/js/mediaelement/flashmediaelement.swf+ext:swf&channel=fs&start=10).\n\nHere is some numbers that other people guesstimate:\n * https://managewp.com/14-surprising-statistics-about-wordpress-usage\n * https://www.quora.com/How-many-websites-are-built-on-Wordpress\n * https://wordpress.com/activity/\n\nFurther note, browser-based XSS filters will not detect the attack and hence not protect here.\n\nMitigation\n==\n\n* Prevent direct access to all Flash files in the WordPress folder (`Content-Disposition` headers might help)\n* Configure your WAF to block direct access to this file\n* Wait for the fix and update Wordpress",
  "weakness": {
    "id": 60,
    "name": "Cross-site Scripting (XSS) - Generic"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2016-07-10T12:51:04.430Z",
  "allow_singular_disclosure_after": -239671048.35958633,
  "singular_disclosure_allowed": true,
  "vote_count": 67,
  "voters": [
    "static",
    "yxw21",
    "sourc7",
    "d1m0ck",
    "konqi",
    "bobrov",
    "harisec",
    "hunter",
    "michiel",
    "wkcaj",
    "and 57 more..."
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
