{
  "id": 138025,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMzgwMjU=",
  "url": "https://hackerone.com/reports/138025",
  "title": "Heap corruption via memarea.c",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2016-05-11T20:00:34.272Z",
  "submitted_at": "2016-05-11T20:00:34.272Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "guido",
    "url": "/guido",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 1800,
    "url": "https://hackerone.com/torproject",
    "handle": "torproject",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/3c7b305354c9073c106ae3d1701798defaaf5be844fb8fdfa49ca62f991a2c2c",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/f4a495c04fdb224bac8ec64587537e511aa8c4925e7955bee0a19e0ed7d891dc"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Tor",
      "twitter_handle": "torproject",
      "website": "https://www.torproject.org/",
      "about": "Anonymity Online"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2017-10-19T10:16:01.417Z",
  "bug_reporter_agreed_on_going_public_at": "2017-10-19T10:16:01.366Z",
  "team_member_agreed_on_going_public_at": "2017-10-19T09:35:39.803Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Hello again,\n\nThere is a potential vulnerability in memarea.c.\n\ncommon/memarea.c:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {\n233   memarea_chunk_t *chunk = area->first;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz < SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk->next_mem+sz > chunk->U_MEM+chunk->mem_size) {\n```\n\nThe vulnerability lies in the addition of a pointer and an integer on line 240:\n\n```c\n240   if (chunk->next_mem+sz ...\n```\nTo which address ```chunk->next_mem``` points is not within the application's (tor) purview, since it originates from within malloc() (which is accessed via tor_malloc()) and to some extent the system's kernel memory management), and malloc() is implemented in the libc with which tor was linked.\nMy point is that no or few assumptions can be made about the virtual address to which chunk->next_mem points.\n\n```sz``` is variable and may be influenced by an external party on the network.\n\nFurthermore, it is guaranteed that ```sz``` is smaller than SIZE_T_CEILING, which is 0x80000000 on 32 bit:\n\n```c\ntor_assert(sz < SIZE_T_CEILING);\n```\n\nThe above predicates imply that 1) given a 32 bit system, where 2) chunk->next_mem happens to point to a virtual address of 0x80000000 or higher and 3) ```sz``` >= ```0x100000000 - chunk->mem_next``` an overflow will occur in the addition of the pointer ```chunk->next_mem+sz```, thus unduly evading this check, which was meant to assert whether is sufficient memory in the current block.\n\nIn other words, if chunk->next_mem is 0xA0000000, and memarea_alloc is called to request ```0x60000000``` bytes, then the following will happen:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {     \n233   memarea_chunk_t *chunk = area->first;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz < SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk->next_mem+sz > chunk->U_MEM+chunk->mem_size) {\n...\n...   This code is not executed\n...\n254   } \n255   result = chunk->next_mem;\n256   chunk->next_mem = chunk->next_mem + sz;\n```\n\nIn this case, line 256 translate to:\n\n```\n256   chunk->next_mem = 0xA0000000 + 0x60000000;\n```\n\nEg. ```chunk->next_mem``` now equals 0.\n\nThe higher the value of ```chunk->next_mem```, and the higher the maximum value of ```sz``` that a potential attacker can enforce to be allocated, the higher the odds of yielding a ```chunk->next_mem``` value that points to real data (eg. a block of heap memory allocated by tor).\n\nI've used 32 bit in this example. 64 bit is theoretically possible too (SIZE_T_CEILING is larger on 64 bit as well), but less likely.\n\nAn easy way to test this is by changing this line in memarea.c alloc_chunk():\n\n```c\nres = tor_malloc(chunk_size);\n```\n\nto\n\n```c\nres = mmap((void*)0xF0000000, chunk_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n```\n\n(also include ```#include <sys/mman.h>```)\n\nthen this code will trigger a segmentation fault\n\n```\n  memarea_t *area;\n  area = memarea_new();\n  char *mem = memarea_alloc(area, 0x10000000);\n  memset(mem, 0, 0x10000000);\n```\n\n(be aware that this example applies to 32 bit, so compile with ```CFLAGS=\"-m32\"```)\n\nGuido",
  "weakness": {
    "id": 2,
    "name": "Memory Corruption - Generic"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2017-11-18T09:35:40.030Z",
  "allow_singular_disclosure_after": -196828480.8801547,
  "singular_disclosure_allowed": true,
  "vote_count": 6,
  "voters": [
    "geeknik",
    "eveeez",
    "mr_r3boot",
    "spetr0x",
    "b4155f7c29acd42c27d007a",
    "mycel"
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
